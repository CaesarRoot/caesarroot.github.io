---
title: 软件架构实践翻译&&笔记（一）--可用性
date: 2019-09-19 08:21:28
categories: [读书笔记，翻译]
tags: [读书笔记, 架构, 翻译]
cover_img: https://s2.ax1x.com/2019/09/19/nbUhq0.jpg
feature_img: https://s2.ax1x.com/2019/09/19/nbUhq0.jpg
description:
keywords:
---

### 可用性

系统的可用时间占总时间的百分比

#### Tactics

##### 1. Detect Faults（检测错误）

- Ping/echo：指的是一对节点之间异步的请求/相应信息，用来检测在相关联的网络路径上的的**可达性**和**延迟。**也用来决定被ping的组件（component）存活并且正确响应。ping通常是由一个系统监控器（monitor）发出。Ping/echo 要求设置一个**时间期限**(threshold)；这个时限告诉发出ping信号的组件要等待echo信号多久，否则就认为被ping的组件失效（超时）。一个ping/echo的标准实现是通过IP的节点互连。

- Monitor：一个监视器（monitor）是一个用于**监视系统其他部分**（例如处理器，进程，IO，内存等）健康状态的组件。系统监视器可以**检测错误**或者**网络拥塞**，或者**其他共享资源**，例如拒绝服务攻击等。它使用这个分类中的**其他方法**检测故障组件，保证整个系统的协调运行。例如，系统监视器可以初始化自检测（self-tests），或者检测错误的时间戳、失常的心跳（heartbeats）。

- Heartbeat：通过**在系统监视器（monitor）和被监视进程之间周期性的信息交换**来实现的一个错误检测机制。心跳的一个特殊例子是被监视进程周期性地重置系统监视器上的监视定时器（watchdog timer）来防止自身被认为失效（引发错误）。当一个系统的可扩展性是一个关注点的时候，传送和提前处理（心跳信息）可以通过如下方式来减少：**将心跳信息放在其他控制信息中**，在被监视进程和分布式系统控制器之间交换。心跳和ping/echo的一个极大的不同点是：谁来发起初始化心跳检测，是系统监视器还是组件自身（如果是monitor发起，那么是ping/echo；反之则是heartbeat）。

  > watchdog：当一个检测机制是采用周期性地重制一个计数器或者计时器时，这个特殊的系统监视器就被称为watchdog。在一个流程中，被监视进程会周期性地重置此计数器或计时器来说明它正常工作，这有时被称作petting the watchdog。

- Time stamp：这个策略（tactic）被用来**测检不正确的时间序列**，主要用在分布式的消息传送系统中。事件的时间戳可以用如下方式来建立：在事件发生后，立即设置一个**本地时钟的状态**给该事件。一串简单的**顺序数字**也可以被用作这个目的（如果时间信息不重要的话）。

- Sanity checking：检查一个组件特定操作或者输出的**合理性和正确性**。这个策略基于内部设计—**系统的状态**或者**正常情况下的信息特性**。主要用于接口检测特定的信息流。

- Condition monitoring：检查一个设备或者进程的**状态**，或者**验证**设计过程中的猜想。通过检测状态（condition），此策略防止系统产生出错误的行为。计算检验和（checksums）是一个典型的例子。但是，监视器（monitor）本身必须是足够**简单的（形式完美的（ideally），可被证明的（provable））**来确保它不会引发新的错误。（*PS（译者注）*：例如检验和的算法必须是数学上证明正确的）。

- Voting：这个策略最普遍的实现是三模块冗余（TMR）——用三个模块来做相同的事情，每一个模块接收相同的输入，并将他们产生的结果输入投票逻辑（logic），用来检测三个输出是否一致。如果不一致，那么投票机制会**报告一个错误**，而且它也必须**决定采取哪一个输出**。采用多数原则，或者计算不同输出的平均值。这个策略严重依赖于具体的投票逻辑，这个逻辑通常是简单的，被严格检验和测试过的，以确保发生错误的概率尽量低。

- Replication：投票（voting）机制的简单形式。**组件互相复制**（clones）。有多个组件的拷贝可以有效地**防止硬件的随机错误**，但是这**不能保证软件或者硬件中设计或者实现的错误**，因为这个策略没有多样性。（*PS（译者注）*：其实是同一个组件，不过有好几份，所以如果组件本身逻辑有错误，那么错误依然会发生；投票机制中多个组件可以是不同实现的，只不过期望的功能相同。）

- Functional redundancy：投票策略的一个形式，用来解决软件或者硬件中**设计或者实现的错误**。基于相同的输入，组件必须给出相同的输出，但是他们设计和实现上是不同的。（*PS（译者注）*：这个就是上面那种情况的升级版，即几个组件只是**功能上的冗余**，实现并不相同）。

- Analytic redundancy：不仅允许设计和实现的不同，还**允许组件输入输出不同**。这个策略容忍规格上的的错误——通过使用不同的需求规格（？？？）。在嵌入式系统中，分析冗余（analytic redundancy）用于**输入资源不可获得**的情况下。例如航空程序有多种方法可以计算飞机海拔，例如气压方法，雷达方法或者通过直线距离和仰角等来计算。这种使用分析冗余的投票机制相比于多数原则或计算平均值需要考虑得更多。它可能需要理解哪一个传感器是可靠的，而且有可能需要给出一个**比任何组件具有更高可信度**的值 —— 通过分析和综合各个不同的结果。

- Exception detection：检测系统中改变正常执行流程的状态，可被进一步细分：

  1. System exceptions：处理器硬件架构，除0错误，总线错误，地址错误，非法程序指令等。
  2. Parameter fence：采用一个预先确定好的数据格式来替换一个对象的可变长参数。这允许运行时检查重写对象可变长参数的内存分配的错误。
  3. Parameter typing：用一个基础的类型来定义一些功能和数据长度、格式等。派生的类型用基础类型的功能来实现其他功能。用强类型来传递信息有更高的可用性——相比于弱类型看待任何类型都是字节流。当然任何设计都有权衡，当使用强类型时，获得了更高的可用性，但是丧失了部分演化（evolution）的便捷。 
  4. Timeout：当一个组件检测到它或者其他组件超过规定的**时间期限**时，抛出一个异常。例如，当一个组件等待另一个组件响应的时候，当等待时间超过一个确定的值时，抛出一个异常。

- Self-test：组件（或者整个子系统）可以运行一个程序来检测自身是否执行正确的操作。自测程序可以由**组件自己发起**，或者时不时地由一个**系统监视器发起**。它们可能会用一些条件监控中的策略，例如检验和等。

##### 2. Recover from Faults（从错误状态恢复）

**2.1 Preparation-and-repaire**

这种策略包含了大量重试以及冗余策略。

- Active redundancy(hot spare)：在一个保护组（见注解）所有节点（主节点或者冗余节点）**同时接收并且处理相同的输入**，这保证了冗余节点和主节点保持同步状态。由于冗余备份和主节点有着相同的状态，所以在主节点失效时，它可以很快地接替主节点。一个简单的情况是一个主节点配备一个冗余节点 —— 这被称为1+1冗余。Active redundancy也可以被用作设备保护，主要的网络连接和备用的网络连接一同确保网络连接的高可用性。

  注：protection group指的是一群工作节点，这些节点中有一个或者多个节点是"active"（主节点），剩下的节点是冗余备份。

- Passive redundancy(warm spare)：在一个保护组中，**只有主节点处理输入**，它们周期性地给冗余节点提供更新。因为冗余节点的状态和主节点的状态并**不是完全同步**（loosely coupled），这种冗余节点也被叫做warm spares。取决于系统的可用性需求程度，**被动的冗余提供了一个折衷方案**，即在高可用但是计算更加密集的active redundancy和低可用但是更简单的cold spare中做权衡。

- Spare(cold spare)：Cold sparing指的是在一个保护组中，冗余节点完全不工作，直到一个错误发生。这时，**在冗余节点能提供服务之前，必须要执行一个启动程序**。由于恢复的性能低下，cold sparing更适用于只有高可靠的需求而不适用于有高可用的需求的系统。

- Exception handling：一旦检测到一个异常，系统必须以某种方式来处理异常。**最简单的情况是崩溃，但是从可用性，易用性，可测试性和直觉上考虑，这是一个糟糕的主意**。处理异常的机制很大程度上取决于所使用的**编程环境**，从简单地返回错误码到复杂的异常类。软件可以用异常类包含的各种信息来检查错误。

- Rollback：**这个策略允许系统返回到前一个已知的正确状态**，在检测到错误的时候进行时间的回滚。一旦达到了正确状态，那么程序就可以继续运行。**这个策略常常和active或者passive redundancy一起使用，这样的话，当回滚发生的时候，备用版本就可以替换主版本**。回滚依赖于前一个正确状态的**备份（检查点）是可获得的**。检查点可以存储在一个**固定的位置并且被定期更新，或者在一些方便或者重要的时候更新**，例如一个复杂操作完成的时候。

- Software upgrade：**在系统运行的时候更新可执行代码而不影响正常的服务**。实现方式可以是一个函数的补丁，或者类的补丁，或者无中断运行中软件更新（ISSU）。函数补丁用于结构化编程中，使用一个增加的linker或者loader来将更新后的函数装载到预先分配好的目标内存位置中。**新版本的函数会使用弃用函数的入口和出口**。而且，装载新函数的时候，符号表必须被更新，并且之前的指令缓存也要被认为是非法的。**类补丁用于面向对象设计中**。类的定义中包含了一个后门，这可以用来在运行中加入新的成员函数和函数。（PS*译者注：*例如java中的反射）ISSU利用了active或者passive redundancy策略来达到更新但是不影响软件正常提供服务。在实践中，函数补丁和类补丁用于修复bug，而ISSU用于提供新功能。

- Retry：重试策略假设引起失效的错误是**瞬时**的，并且**重试这个操作可能可以成功**。这个策略用于网络和服务器，在这些地方失效被认为是常态。应该**限制重试的次数**，超过这个次数就认为永久失效。

- Ignore faulty behavior：这个策略**忽略特定来源**的信息，这些信息被认为是伪造的。例如，我们会忽略来自引发拒绝服务访问的外部组件的信息，这可以通过建立访问控制列表来完成。

- Degradation：此策略在系统失效的时候，只维持**最为重要的系统功能**，而放弃次要的功能。当某个组件的失效**只是降低了系统的功能而不是导致整个系统失效**的时候，我们可以采用此功能。

- Reconfiguration：此策略通过给仍在发挥作用的资源（很可能是受限的）**重新分配职责**，尝试从组件的错误中恢复。以此来维持尽可能多的功能可用。（PS*译者注：例如windows的安全模式*）

**2.2 Reintroduction**

这种策略用于失效组件在被修正后重新引入。

- Shadow：这个策略指的是运行一个**先前失效**的或是**服务中更新(in-service upgraded)**的组件在一个"影子模式"中，持续一段预先定好的时间后，让组件重新回到正常的工作状态。在这段持续时间中，组件的行为会被监视，并且它可以重新恢复它的状态。
- State resynchronization：此策略适用于active redundancy和passive redundancy这两种preparation-and-repair策略的重引入。当使用active redundancy策略的时候，状态重同步有组织地发生，因为主组件和备用组件同时各自接收和处理相同的输入。**在实践中，主组件和备用组件周期性地互相比较来确保同步**。这种比较可能是基于循环冗余校验或者系统提供的安全服务，例如一种信息摘要计算(message digest calculation)。当使用passive redundancy策略时，**状态的重同步只是基于主组件周期性地给备用组件传递信息，通常是通过检查点的方式**。这种策略的一个特殊例子是无状态服务，任何一种资源可以响应一个已经失效的资源的请求。
- Escalating restart：此策略允许系统**调整组件重启的粒度**，**减小受影响的服务范围**来从一个失效中恢复过来。例如，假设一个系统支持4个等级的重启。最低等级的重启（等级0），对服务有最小的影响，使用passive redundancy，错误组件的所有子线程被杀死和重新创建。通过这种方法，只有关联于子线程的数据会被释放和重新初始化。下一个等级（等级1）的重启会释放和初始化所有不受保护的内存（保护中的内容不受影响）。再下一个等级（等级2）释放和重新初始化所有的内存，包括所有受保护和不受保护的部分，强迫所有的应用重新加载并重新初始化。最后一个等级（等级3）完全重新加载和重新初始化可执行映像和所有有关的数据段。**支持范围重启策略对降级(graceful degradation)特别有用**。系统能够减少它提供的服务，并且维持一些重要的任务和安全相关的应用。
- Non-stop forwarding(NSF)：这个概念来源于路由器设计。在这个设计中，功能被分为两个部分：**监视，或控制通路（管理着连通性和路由信息），和数据通路（在发送者和接收者之间交换包）**如果路由的监控部分失效，那么它仍然可以在已知的路由器（邻居路由器）中继续传输包；当控制通路被重启时——有时被称为是"graceful restart" —— 增量重建路由协议数据库，此时数据通路仍然在继续工作。

##### 3. Prevent Faults（预防错误）

- Removal from service：次策略指的是**暂时将一个系统组件从工作状态切换成非工作状态，为了减轻潜在的系统失效**。一个例子是终止和重启一个组件，使得潜在的错误（例如内存泄漏，碎片化，或在不受保护的缓存中的软错误（soft errors））不会累积从而影响正常服务。此策略的另一个名称是软件再生（software rejuvenation）。
- Transactions：高可用的系统服务降低事务的语义来保证在分布式的组件中传递的同步信息是**原子的(atomic)、一致的(consistent)、分离(isolated)的和可持久(durable)的**。这四个属性被称为ACID属性。最常见的实现是"two-phase commit"协议。这个策略阻止了竞争情况，这种情况是由两个进程同时试图更新相同的数据引起的。
- Predictive model：一个预测模型，和一个监视器结合，用来监视系统进程的健康状态，**确保系统的操作是基于预定的操作参数，并且当预测到发生错误的可能性时，可以采取正确的措施**。被监视的操作性能指标用来预测错误的发生，这样的例子包括session建立的频率（在一个HTTP server中），跨越阈值（对一些约束检测预警线的高低），或是维持进程状态的数据（服务中，不在服务中，维修中，等待中），消息队列长度数据等等。
- Exception prevention：此策略预防系统发生异常。**异常类的使用**，允许系统从异常状态恢复而不被用户感知，这之前已经讨论过了。另一个阻止异常的例子包括**一些抽象数据类型**，例如智能指针，以及用包裹器来预防错误，例如野指针和信号量反问违规。智能指针通过指针边界检查和确保资源被正确回收来预防错误发生。
- Increase competence set：**一个程序的功能集合指的是状态的集合，这种状态是它能够进行操作的**。例如，分母为0的情况超出了大部分除法程序的功能范围。当一个组件抛出一个异常时，表明它发现情况超出了它的功能范围；本质上，它并不知道如何解决，因此抛出了异常。**增加一个组件的功能集合意味着将它设计地能处理更多情况 —— 错误 —— 也成为了正常操作的一部分**。例如，一个组件假设它有权限访问共享资源，当它发现它的权限被阻止的时候，它可能会抛出一个异常；另一个组件可能只是会一直等待授予权限，或者立即返回，并带有一个提示 —— 下次它有权限的时候，它将完成此操作。在这个例子中，第二个组件相比第一个有着更大的功能集合。











