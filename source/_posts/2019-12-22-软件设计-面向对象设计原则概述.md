---
title: 软件设计--面向对象设计原则概述
date: 2019-12-22 11:21:29
categories: 软件设计
tags: 软件设计
cover_img:
feature_img:
description:
keywords:
---

# 软件的可维护性和可复用性

**软件的复用(Reuse)或重用**拥有众多优点，如可以提高软件的开发效率，提高软件质量，节约开发成本，**恰当的复用还可以改善系统的可维护性**。

面向对象设计复用的目标在于**实现支持可维护性的复用**。

在面向对象的设计里面，**可维护性复用都是以面向对象设计原则为基础的**，这些设计原则首先都是复用的原则，遵循这些设计原 则可以有效地提高系统的复用性，同时提高系统的可维护性 。



笔记：

复用和维护通常情况下目标是相同的，但是有时候会有抵触，中的目标是既能复用，又将维护成本降低到最小。

对算法、数据结构的复用通常会破坏可维护性，面向对象设计就是为了解决复用和维护的矛盾。



# 重构

重构(Refactoring)是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。 



# 面向对象设计原则

常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。 

**地位不同：目标、具体操作、指导思想**

![image](https://s2.ax1x.com/2019/12/22/QxypdJ.png)



## 单一职责原则

Single Responsibility Princip SRP

**是一个目标**

### 定义

一个对象应该只包含单一的职责，并且该职责被完整地封装
在一个类中

笔记：

控制类的粒度，有利于复用，需要改动的可能降低到最低

复用的粒度是类



### 分析

一个类(或者大到模块，小到方法)承担的职责越多，它被复用的可能性越小 

类的职责主要包括两个方面：**数据职责和行为职责**，**数据职责通过其属性来体现，而行为职责通过其方法来体现。**

单一职责原则是实现高内聚、低耦合的指导方针 



### 实例

![image](https://s2.ax1x.com/2019/12/22/QxysyT.png)

![image](https://s2.ax1x.com/2019/12/22/QxyyOU.png)



## 开闭原则

是最高目标

Open-Closed Principle, OCP

### 定义

一个软件实体应当**对扩展开放，对修改关闭**。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。

**软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。**



### 分析

**抽象化**是开闭原则的关键

开闭原则还可以通过一个更加具体的“**对可变性封装原则**”来描述，对可变性封装原则(**Principle of Encapsulation of Variation, EVP**)要求找到系统的可变因素并将其封装起来



### 实例

![image](https://s2.ax1x.com/2019/12/22/Qx6Zpq.png)

可以看到Button是变化的部分，应该要单独抽象出来，形成一个抽象接口

![image](https://s2.ax1x.com/2019/12/22/Qx6J91.png)

 

## 里氏代换原则

Liskov Substitution Principle, LSP

### 定义

所有引用基类(父类)的地方必须能透明地使用其子类的对象



笔记：

**继承和多态：并不是为了复用，而是为了提供一个稳定的抽象层。把不确定的，变化的部分封装起来形成一个稳定的抽象层。不使用具体方法，而是使用抽象的方法。新的类只要实现这些抽象方法，就可以被直接使用**



### 分析

在软件中如果能够使用基类对象，那么一定能够使用其子类对象。 

里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子 类对象，因此**在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**。



笔记：

父类都是抽象方法，子类都要实现

子类的额外方法是**私有方法**

**不依赖具体子类**，而是在运行时使用具体子类，来**替换父类**

**行为上一样；语法上可替换**

**子类的前置条件更弱，后置条件更强**



### 实例

和开闭原则中的例子差不多

![image](https://s2.ax1x.com/2019/12/22/QxcAbD.png)

![image](https://s2.ax1x.com/2019/12/22/QxcK2t.png)



## 依赖倒转原则

Dependence Inversion Principle, DIP

### 定义

高层模块**不应该依赖低层模块**，它们都应该**依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。**

**要针对接口编程，不要针对实现编程**



### 分析

代码要**依赖于抽象的类**，而不要依赖于具体的类；要**针对接口或抽象类编程**，而不是针对具体类编程



依赖倒转原则的常用实现方式之一是**在代码中使用抽象类，而将具体类放在配置文件中**

“**将抽象放进代码，将细节放进元数据**” 



笔记：

修改的时候改配置文件就行了，**尽量将具体类的使用延后**



类之间的耦合关系：

零耦合关系（没有任何关系）

具体耦合关系（和具体类耦合）

抽象耦合关系（至少有一方是抽象类）

**以抽象方式耦合是依赖倒转原则的关键**



依赖注入：

构造注入(Constructor Injection):通过构造函数注入实例变量。 

设值注入(Setter Injection):通过Setter方法注入实例变量 。 

接口注入(Interface Injection):通过接口方法注入实例变量。 



### 实例

一般来说看到类图中没有抽象类，都可以考虑用依赖倒转

![image](https://s2.ax1x.com/2019/12/22/QxgFWn.png)

![image](https://s2.ax1x.com/2019/12/22/QxgEQ0.png)



## 接口隔离原则

Interface Segregation Principle, ISP 



### 定义

客户端不应该依赖那些它不需要的接口。 

一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。



### 分析

接口隔离原则是指使用**多个专门的接口，而不使用单一的总接口**（接口是一组方法的集合）

1. 一个接口就只代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫做“角色隔离原则”。（**类似于单一职责**）
2. 接口仅仅提供客户端需要的行为，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可 能小的单独的接口，而不要提供大的总接口。 （**语言层面的要求**）



首先必须满足**单一职责原则**，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。
 可以在进行系统设计时采用**定制服务**的方式，即为不同的客户端提供**宽窄不同**的接口，只提供用户需要的行为，而隐藏用户不需要的行为。



### 实例

看到巨大的接口就要拆分

![image](https://s2.ax1x.com/2019/12/22/Qxgrlt.png)

![image](https://s2.ax1x.com/2019/12/22/QxgyOf.png)



## 合成复用原则

Composite Reuse Principle, CRP

合成：组合和聚合都算合成



### 定义

**尽量使用对象组合（合成），而不是继承来达到复用的目的**



### 分析

合成复用原则就是指在一个新的对象里通过**关联关系(包括组合关系和聚合关系)**来使用一些已有的对象，使之成 为新对象的一部分;新对象通过**委派调用已有对象的方法达到复用其已有功能的目的**。简言之:**要尽量使用组合/聚合关系，少用继承**。



继承复用和组合复用：

继承复用:实现简单，易于扩展。破坏系统的封装性; 从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性;只能在有限的环境中使用。 (“**白箱**”复用 ) 

组合/聚合复用:耦合度相对较低，选择性地调用成员对象的操作;可以在运行时动态进行。(“**黑箱**”复用 ) 



**一般首选使用组合/聚合来实现复用**

 

笔记：

如果是改写接口的返回值等进行复用，那么可以用组成（**不涉及中间步骤的更改，只是在头尾修改**）
如果要改变其中几个步骤，那么需要用继承



正确的观点：

**继承复用的是抽象接口**
**合成复用的是具体实现**

并且**合成的还是抽象耦合，使用的还是抽象类型**



### 实例

一般来说就是改继承为组合

![image](https://s2.ax1x.com/2019/12/22/Qxgb0U.png)

![image](https://s2.ax1x.com/2019/12/22/QxgXtJ.png)



## 迪米特法则

Law of Demeter, LoD

又称为最少知识原则(Least Knowledge Principle, LKP)



### 定义

1. **不要和“陌生人”说话**
2. **只与你的直接朋友通信**

3. **每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位**

在狭义的迪米特法则中，**如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用**，如果其中的一个类需要调用另一个类的某一个方法的话， 可以通过**第三者转发这个调用**

因为要转发，因此**通常和效率是矛盾的**

广义的迪米特法则:指对对象（模块）之间的信息流量、流向以及信息的影响的控制，主要是对**信息隐藏**的控制，控制信息的过载

 

朋友：

1. 当前对象本身(this); 

2. 以参数形式传入到当前对象方法中的对象; 

3. 当前对象的成员对象; 

4. 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友; 

5. 当前对象所创建的对象。

    

陌生人：

调用其他方法返回出来的对象



指导行为：

1. 在类的划分上，应当尽量创建**松耦合**的类，类之间的耦合度 越低，就越有利于复用，一个处在松耦合中的类一旦被修改 ，不会对关联的类造成太大波及; 
2. 在类的结构设计上，每一个类都应当尽量**降低其成员变量和成员函数的访问权限; **
3. 在类的设计上，只要有可能，一个类型应当设计成**不变类;**
4.  在对其他类的引用上，一个对象对其他对象的**引用应当降到最低** 



### 实例

一般来说就是通信非常复杂，就引入中间层

![image](https://s2.ax1x.com/2019/12/22/Qx2Ehd.png)

![image](https://s2.ax1x.com/2019/12/22/Qx28hj.png)



# 什么是设计模式

设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结

设计模式不会给出具体的代码实现，需要结合需求来给出实现

设计模式不是发明出来的，而是发现的

设计模式和设计原则大部分都是针对解决变化这个问题，允许系统的一部分单独变化而不会影响其他部分

设计模式提供了共同语言

设计模式被证实是一种好的面向对象设计经验



# 为什么需要设计模式

设计模式形成了术语，节约交流成本，可以让开发人员在设计层面上思考问题，而不是更细节的层面。注重设计，而不会迷失在细节当中

设计模式的名字就可以概括一大堆设计中的细节和特点，交流付出的代价更小

可以让年轻的设计人员更快上手



只了解设计原则还不够，好的设计人员需要想的更多，让软件可维护性更好，更加灵活，可以应对更多变化。这就是设计模式的意义。但是设计原则是一个很好的指导。设计模式可以给出一个好的设计，符合设计原则的设计



# 设计模式和类库和框架的关系

设计模式比类库的层次更高，它知道我们如果解决一类问题，而不是着眼于一个具体的问题

框架和类库不是设计模式，它们提供了具体的实现。但是它们的实现过程中使用了大量设计模式



# 类行为型模式和对象行为型模式

只有继承关系，没有对象关联关系，是类的行为型模式
类行为型模式：继承来实现