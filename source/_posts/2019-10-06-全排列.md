---
title: 全排列
date: 2019-10-06 16:20:51
categories: [算法]
tags: [刷题, 暴搜]
cover_img:
feature_img:
description:
keywords:
---

# 题目

给定一个没有重复数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/permutations



# 思路

回溯即可。

注意一下vector的引用问题。



# 题解

```c++
#include <iostream>
using namespace std;

class Solution {
private:
    vector<vector<int>> ans;
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<int> left(nums.size(), 0);  // 初始化为全0
        vector<int> now;
        DFS(nums, now, left);
        return ans;
    }

    /*
    now表示现在加到结果中的vector
    left表示还可以加入的位置。1表示已经加入，0表示还可以加入
    */
    void DFS(vector<int>& nums, vector<int> now, vector<int> left){  // 这里的now不能是引用
        int full = true;
        for(int i=0; i<left.size(); i++){  // 遍历left，如果还有0，那么表示还可以加入
            if(left[i] != 1){
                full = false;
                now.push_back(nums[i]);  // 加入
                left[i] = 1;
                DFS(nums, now, left);  // 回溯
                now.erase(now.end()-1);
                left[i] = 0;
            }
        }
        if(full){  // 不可以再加入，就加入答案集合中
            ans.push_back(now);
        }
        return ;
    }
};
```



