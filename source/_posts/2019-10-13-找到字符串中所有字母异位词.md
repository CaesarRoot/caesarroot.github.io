---
title: 找到字符串中所有字母异位词
date: 2019-10-13 16:54:25
categories: [算法]
tags: [刷题, 双指针]
cover_img:
feature_img:
description:
keywords:
---

# 题目

给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

说明：

字母异位词指字母相同，但排列不同的字符串。
不考虑答案输出的顺序。
示例 1:

输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。
 示例 2:

输入:
s: "abab" p: "ab"

输出:
[0, 1, 2]

解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string



# 思路

双指针。

注意一下这里每个字符的数量要完全匹配。



注意一下基本上连续的子串可以考虑动态规划，各个答案着的情况可以考虑双指针。



# 题解

两种写法。

第一种考虑当某个字符变多的时候。

例如窗口中有两个a，但是p中只有一个a，这时需要缩小窗口，直到只有一个a，同时注意更新match

当match达到要求，直接就可以得到结果

```c++
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int count[256] = {0};
        int diff = 0;
        int match = 0;
        for(auto c: p){
            if(count[c]==0) diff++;
            count[c] += 1;
        }
        int window[256] = {0};
        int r = 0, l = 0;
        vector<int> ans;
        while(r < s.size()){
            window[s[r]]++;
            if(window[s[r]] == count[s[r]]){
                match++;
            } else {
                while(window[s[r]] > count[s[r]]){
                    window[s[l]]--;
                    if(window[s[l]] == count[s[l]]-1) match--;
                    l++;
                }
            }

            if(match == diff){
               ans.push_back(l);
            }

            r++;
        }
        return ans;
    }
};
```



第二种是不管字符数目超过，一直累加到match达到要求，此时要注意窗口中字符种类虽然达到要求，但是个数不一定符合。所以需要缩小窗口，直到窗口大小如果等于p的长度，且match仍然符合要求，那么得到一个结果。

```c++
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int count[256] = {0};
        int diff = 0;
        int match = 0;
        for(auto c: p){
            if(count[c]==0) diff++;
            count[c] += 1;
        }
        int window[256] = {0};
        int r = 0, l = 0;
        vector<int> ans;
        while(r < s.size()){
            window[s[r]]++;
            if(window[s[r]] == count[s[r]])
                match++;

            while(match == diff){
                if(r-l+1 == p.size()){
                    ans.push_back(l);
                }
                window[s[l]]--;
                if(window[s[l]] == count[s[l]]-1) {
                    match--;
                }
                l++;
            }

            r++;
        }
        return ans;
    }
}
```

