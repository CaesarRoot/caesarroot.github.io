---
title: 使用最小花费爬楼梯
date: 2019-09-04 20:39:01
categories: leetcode
tags: [动态规划, 刷题]
cover_img: https://s2.ax1x.com/2019/09/04/nZ567F.png
feature_img: https://s2.ax1x.com/2019/09/04/nZ567F.png
description:
keywords:
---

# 题目

数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

示例 1:

输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
 示例 2:

输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
注意：

cost 的长度将会在 [2, 1000]。
每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs

# 思路

如果便利所有情况的话显然过于复杂，具体的情况数应该是斐波那契数列的某一项，复杂度太高。

如果考虑用贪婪的话也不太对，因为存在一种情况是首选一个花费较大的，但是之后可能存在一个花费更小的，例如 [0, 1, 2, 2]，如果是贪婪的话选择0-1-2，但是最小的花费应该是0-2

用贪婪的问题是，这实际上是一个累加的问题，不是基于当前情况就能判断的问题，必须要是前面所有的积累

故而就想到遍历所有情况，因为若是不知道之后的情况，似乎也是没法确定是否选择当前的走法

这时候就要转化一下思路，想一想dp的解法

dp的解法是：

dp[i] = min(dp[i-1],dp[i-2]) + cost[i] （第0和第1个位置是dp的初始值）

即要走到第i个台阶，考虑它之前的两个台阶，取小的那个加上当前台阶的花费即可。这样当我们求出最后两个台阶的dp时，就可以取小的那个，然后走完全部台阶



# 解法

按照上面的想法翻译一下代码即可，需要注意的是最后还要判断一下dp的最后两个位置，取小的值作为结果返回

``` c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        // dp[i] = min(dp[i-1],dp[i-2]) + cost[i]
        int a = cost[0], b = cost[1];
        int c = 0;
        for(int i=2; i<cost.size(); i++){
            c = a>b?b:a;
            c += cost[i];
            a = b;
            b = c;
        }
        return a>c?c:a;
    }
};
```



# 总结

写出状态转移方程就会清晰很多