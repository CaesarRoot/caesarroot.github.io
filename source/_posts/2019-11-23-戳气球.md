---
title: 戳气球
date: 2019-11-23 10:09:57
categories: [算法]
tags: [刷题,暴搜]
cover_img:
feature_img:
description:
keywords:
---

# 题目

有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

说明:

你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100
示例:

输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/burst-balloons



# 思路

容易想到逐个枚举气球来戳爆，时间复杂度是O(n!)

当逐个选择气球戳爆的时候，左右两边发生了变化，因此后一个要依赖前一个

当逐个枚举气球不戳爆的时候，这个气球将整个数组分成了左右两个部分，分别求这两边戳爆的最大值，再加上戳爆这个气球的值，就是最后的答案

这样有个好处就是实际上会变成枚举区间，加上记忆化，那么最终复杂度就是O(n^2)



# 题解

```c++
#include <iostream>
#include <vector>
using namespace std;

class Solution {
    int memory[600][600];
public:
    int maxCoins(vector<int>& nums) {
        memset(memory, 0, sizeof(memory));
        return dfs(0, nums.size()-1, nums);
    }

    int dfs(int start, int end, const vector<int>& nums){
        if(start >= 0 && end < nums.size() && start <= end && memory[start][end] != 0) return memory[start][end];
        int left = (start == 0) ? 1 : nums[start-1];
        int right = (end == (nums.size() - 1)) ? 1 : nums[end+1];
        if(start == end) {
            memory[start][end] = left * nums[start] * right;
            return left * nums[start] * right;
        }
        int max = 0;
        for(int i = start; i <= end; i++){
            int temp = left * nums[i] * right + dfs(start, i-1, nums) + dfs(i+1, end, nums);
            if(max < temp){
                max = temp;
                memory[start][end] = max;
            }
        }
        return max;
    }
};
```

