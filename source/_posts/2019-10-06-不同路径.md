---
title: 不同路径
date: 2019-10-06 19:11:46
categories: [算法]
tags: [刷题, 动态规划, 暴搜]
cover_img:
feature_img:
description:
keywords:
---

# 题目

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/unique-paths
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



# 思路

一开始想用DFS，写起来容易，就是超时了。

DFS重复计算了很多，即经过一个格子的时候其实早就经过了，当然可以用记忆化搜索来优化，用一个二维数组来存储一下即可。

考虑用动态规划，用一个二维数组来表示某位置到终点的情况数，(x,y)位置的次数等于(x+1,y) + (x, y+1)，这样就有递推关系了，然后原始条件就是右下角的那几个。

其实二维数组套两层循环，一次也只是用到了一维数组，因此可以稍微优化一下。这里稍微画一个图看着写就行了。



# 题解

优化前：

```c++
#include <iostream>
using namespace std;

class Solution {
private:
    int ans;
    int m;
    int n;
public:
    int uniquePaths(int m, int n) {
        int dp[m+1][n+1];
        for(int i=1;i<=n;i++) dp[m][i] = 1;
        for(int j=1;j<=m;j++) dp[j][n] = 1;
        for(int i=m-1;i>=1;i--){
            for(int j=n-1;j>=1;j--){
                dp[i][j] = dp[i+1][j] + dp[i][j+1];
            }
        }
        return dp[1][1];
    }
}
```



优化后：

```c++
#include <iostream>
using namespace std;

class Solution {
private:
    int ans;
    int m;
    int n;
public:
    int uniquePaths(int m, int n) {
        int dp[m+1];
        for(int j=1;j<=m;j++) dp[j] = 1;
        for(int i=n-1;i>=1;i--){
            for(int j=m-1;j>=1;j--){
                dp[j] = dp[j] + dp[j+1];
            }
        }
        return dp[1];
    }
}   
```

