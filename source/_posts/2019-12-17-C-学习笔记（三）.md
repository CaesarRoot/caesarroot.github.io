---
title: C++学习笔记（三）
date: 2019-12-17 09:23:25
categories: c++
tags: c++
cover_img:
feature_img:
description:
keywords:
---

# 拷贝赋值和销毁

## 拷贝构造函数

形式：

![image](https://s2.ax1x.com/2019/12/17/QIVR9f.png)

即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数

合成的拷贝构造函数的默认行为：对于类类型的成员，会使用其拷贝构造函数来拷贝，内置类型直接拷贝，对于数组，一个一个拷贝数组类型的成员，如果数组类型是类类型，则使用元素的拷贝构造函数来进行拷贝。注意以上的拷贝为浅拷贝



### 调用时机

![image](https://s2.ax1x.com/2019/12/17/QIVXgU.png)



## 拷贝赋值运算符

形式：

```c++
class Foo {
public:
  Foo& operator=(const Foo&);
}
```

通常应该返回一个指向其左侧对象的引用



### 合成拷贝赋值运算符

与拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为生成一个合成拷贝构造函数。行为和合成的拷贝构造函数一样



## 析构函数

与构造函数相反，销毁对象的非static数据成员



### 形式

```c++
class Foo {
public:
  	~Foo();
}
```



### 合成析构函数

如果没有定义自己的析构函数，那么会合成一个析构函数，默认函数体为空。析构函数体自身并不直接销毁成员。成员是在析构函数之后隐含的析构阶段中被销毁的，整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的



## 三五法则

![image](https://s2.ax1x.com/2019/12/17/QIe1oR.png)



## =default

https://stackoverflow.com/questions/6502828/what-does-default-mean-after-a-class-function-declaration

```c++
class C {
  C(const C&) = default;
  C(C&&) = default;
  C& operator=(const C&) & = default;
  C& operator=(C&&) & = default;
  virtual ~C() { }
};
```

只能对具有合成版本的成员函数使用=default，来显式地要求编译器生成合成的版本



## 阻止拷贝

阻止拷贝行为，因为对于有些类来说拷贝没有意义，例如io



### 定义删除的函数

=delete关键字表明不希望定义这些成员

但是注意析构函数不能是删除的成员，因为如果析构函数被喊出，就无法销毁此类型的对象了，但是可以动态分配这种类型的对象，只是无法释放



### private

通过将拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝



## 自我赋值

自我赋值处理不当可能会导致内存泄漏，正确的处理自我赋值的情况：

![image](https://s2.ax1x.com/2019/12/17/QImrB4.png)

![image](https://s2.ax1x.com/2019/12/17/QImfgK.png)













