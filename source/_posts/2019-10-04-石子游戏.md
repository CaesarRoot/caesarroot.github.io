---
title: 石子游戏
date: 2019-10-04 10:41:25
categories: 算法
tags: [刷题, 动态规划]
cover_img:
feature_img:
description:
keywords:
---

# 题目

亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。

游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。

亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/stone-game

# 思路

有个题解写的蛮好，就直接参考了他的思路



1. 先找方程

   需要起始位置，还有能区别两个人的first和second

   ![image](https://s2.ax1x.com/2019/10/04/uBc72q.png)

2. 再找递推关系

   ![image](https://s2.ax1x.com/2019/10/04/uBcqMV.png)

   就是先收后手的转化以及比较

3. 找原始递推条件

   一路递推下去起始就是i=j的时候

   ![image](https://s2.ax1x.com/2019/10/04/uBgZIH.png)

4. 画出矩阵图

   ![image](https://s2.ax1x.com/2019/10/04/uBgGdg.png)

   这一步主要是为了写起来更直观

   

# 题解

参考题解：

作者：labuladong
链接：https://leetcode-cn.com/problems/stone-game/solution/jie-jue-bo-yi-wen-ti-de-dong-tai-gui-hua-tong-yong/
来源：力扣（LeetCode）



c++代码如下

```c++ 
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        int N = piles.size();
        pair<int, int> dp[1000][1000];
        for (int i = 0; i < N; i++) 
            for (int j = i; j < N; j++){
            dp[i][j].first = 0;
            dp[i][j].second = 0;
        }
        for(int i=0;i<N;i++){
            dp[i][i].first = piles[i];
            dp[i][i].second = 0;
        }
        for(int i=0;i<N;i++){
            for(int j=1;j<N;j++){
                if(i+j<N) {
                    int left = piles[i] + dp[i+1][i+j].second;
                    int right = piles[j] + dp[i][i+j-1].second;
                    dp[i][i+j].first = max(left, right);
                    if(left > right){
                        dp[i][i+j].second = dp[i+1][i+j].first;
                    } else
                        dp[i][i+j].second = dp[i][i+j-1].second;
                }
            }
        }
        return dp[0][N-1].first > dp[0][N-1].second;
    }
};
```

