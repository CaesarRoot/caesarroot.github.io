---
title: 先序遍历构造二叉树
date: 2019-10-04 23:17:12
categories: 算法
tags: [刷题, 暴搜, 树]
cover_img:
feature_img:
description:
keywords:
---

# 题目

返回与给定先序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。

(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 < node.val，而 node.right 的任何后代，值总 > node.val。此外，先序遍历首先显示节点的值，然后遍历 node.left，接着遍历 node.right。）

 

示例：

输入：[8,5,1,7,10,12]
输出：[8,5,10,1,7,null,12]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal



# 思路

因为是先序遍历，且是二叉搜索树

所以第一个节点必然是根节点，然后找到第一个大于根节点的树，划分左右子树，递归建树



# 题解

```c++
#include <vector>
using namespace std;

struct TreeNode { 
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    TreeNode* bstFromPreorder(vector<int>& preorder) {
        return buildTree(preorder, 0, preorder.size()-1);
    }

    TreeNode* buildTree(vector<int>& preorder, int left, int right){
        if(left > right) return NULL;
        if(left == right) return new TreeNode(preorder[left]);
        TreeNode* root = new TreeNode(preorder[left]);
        int border = findBorder(preorder, left, right);
        TreeNode* leftChild = buildTree(preorder, left+1, border-1);
        TreeNode* rightChild = buildTree(preorder, border, right);
        root -> left = leftChild;
        root -> right = rightChild;
        return root;
    }

    int findBorder(vector<int>& preorder, int left, int right){
        int num = preorder[left];
        for(int i=left+1; i<=right; i++){
            if(preorder[i] > num) return i;
        }
        return right+1;
    }
};
```

特别注意一下findBorder方法里面，如果没有找到大于根节点的数，那么返回right+1，递归到下一层会自动返回一个NULL节点