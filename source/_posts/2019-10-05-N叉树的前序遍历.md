---
title: N叉树的前序遍历
date: 2019-10-05 10:33:04
categories: 算法
tags: [刷题, 暴搜, 树]
cover_img:
feature_img:
description:
keywords:
---

# 题目

给定一个 N 叉树，返回其节点值的前序遍历。

例如，给定一个 3叉树 :

![image](https://s2.ax1x.com/2019/10/05/us9c4S.png)

返回其前序遍历: [1,3,5,6,2,4]。

 

说明: 递归法很简单，你可以使用迭代法完成此题吗?



来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal



# 思路

1. 递归
2. 迭代



递归因为只需要处理一下当前节点即可，所以返回void即可；不需要全局数据，只要传入一个引用参数，修改引用参数即可。

迭代要用栈，注意压栈顺序是从右往左。



# 题解

```c++
#include<iostream>
#include<vector>
#include<stack>
using namespace std;

class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};

class Solution {
public:
    vector<int> preorder(Node* root) {
        vector<int> ans;
        if(root == NULL) return ans;
        stack<Node*> n;
        n.push(root);
        while(!n.empty()){
            root = n.top();
            n.pop();
            ans.push_back(root -> val);
            vector<Node*> c = root -> children;
            for(int i=c.size()-1;i>=0;i--)
                n.push(c[i]);
        }
        return ans;
    }
};
```



```c++
#include<iostream>
#include<vector>
#include<stack>
using namespace std;

class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};

class Solution {
public:
    vector<int> preorder(Node* root) {
        vector<int> ans;
        DFS(ans, root);
        return ans;
    }

    void DFS(vector<int>& ans, Node* node){
         if(node == NULL) return;
         ans.push_back(node -> val);
         for(auto n: node -> children){
             DFS(ans, n);
         }
    }
};
```



