---
title: C++学习笔记八
date: 2019-12-30 17:34:26
categories: c++
tags: c++
cover_img:
feature_img:
description:
keywords:
---

# 面向对象

## 为什么要有OO

解决名空间冲突问题

消除安全隐患（对成员的直接赋值和修改）

封装和信息隐藏

封装内部结构，提供统一接口，更多的类型检查



## 构造函数

### 重载构造函数

```c++
class A{
public:
    A(){ cout << "Default" << endl; }
    A(int i) { cout << "int i" << endl; }
    A(char *p) { cout << "char *p" << endl; }
};

int main(){
    A a1 = A(1); // 等价于A a1(1); A a1 = 1;
    A a2 = A(); // 等价于 A a2;
    A a3 = A("abcd"); // 调用A(char *p)
    A a[4]; // 调用a[0]、a[1]、a[2]、a[3]的A()
    A b[5] = { A(), A(1), A("abcd"), 2, "xyz" };
    return 0;
}
```



### 成员初始化表

初始化表先于构造函数，因此const和引用要用初始化表初始化

初始化表式按照对象的声明次序初始化

```c++
/*
引用和常量必须在初始化列表中初始化
*/
class A{
public:
    int x;
    const int y;
    int z;
    int &w;
    A():w(x),y(1),z(x),x(0){ x = 100; }
};

class CString{
public:
    char *p;
    int size;
    // 按声明顺序执行初始化表
    // 且初始化表是最先执行的
    // 而此时size还未初始化
    CString(int x):size(x),p(new char[size]){}
};

int main(){
    A a;
    cout << a.w << endl;  // 100，w设置成为了x的引用
    cout << a.x << endl;  // 100
    cout << a.y << endl;  // 1
    cout << a.z << endl;  // 0，初始化表先执行，且按照声明顺序，因此x先被赋值成0，然后z赋值成x

    CString s(10);
    return 0;
}
```

如果要调用某个成员函数的非默认构造函数，也要在成员初始化表里面显式写出

要调用父类的特定构造函数，也要在成员初始化表里面显式写出



## 析构函数

RAII

resoure acquisition is initialization

对象获得即初始化

核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源



强制在堆上分配空间：将析构函数设为private

```c++
class A{
private:
    ~A(){}
public:
    void destroy() { delete this; }
};

int main(){
    // A a; // 将会报错，因为析构函数是私有的，因此不能在栈上创建
    A* a = new A;
    // delete a; // 将会报错，因为delete默认调用析构函数
    a -> destroy();
    return 0;
}
```

除了destroy，还可以写成一个静态方法：

```c++
static void free(A* p){ delete p; }
A::free(p);
```



强制在栈上分配空间：将new操作符设为private

```c++
class A
{
private:
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的
    void operator delete(void* ptr){} // 重载了new就需要重载delete
public:
    A(){}
    ~A(){}
};

int main(){
    // 将new操作符访问级别设为private可以强制只能在栈上分配对象空间
    // A a = new A;
    return 0;
}
```



## 拷贝构造函数

调用时机：

1. 初始化的时候 A b = a;
2. 函数参数传递
3. 函数返回值



默认的拷贝构造函数是浅拷贝，指针指向同一块内存区域，这样当一个对象析构的时候，指向同一块内存区域的指针就会变成悬挂指针（野指针）



如果定义了自己的拷贝构造函数，那么就覆盖掉了默认生成的：

```c++
class A{
public:
    int x,y;
    A(){ x = y = 0;}
    void inc(){ x++; y++; }
};

class B{
public:
    int z;
    A a;
    B(){ z = 0; }
    B(const B& b):a(b.a){ z = b.z; }
    void inc(){ z++; a.inc(); }
};

int main(){
    B b1;  // b1.z = b1.a.x = b1.a.y = 0
    cout << b1.z << " " << b1.a.x << " " << b1.a.y << endl;
    b1.inc();  // b1.z = b1.a.x = b1.a.y = 1
    cout << b1.z << " " << b1.a.x << " " << b1.a.y << endl;
    B b2(b1);  
    // 如果是默认的拷贝构造函数，那么 b2.z = b2.a.x = b2.a.y = 1
    // 如果是自己的拷贝构造函数但是没有初始化列表，那么 b2.z = 1 b2.a.x = b2.a.y = 0
    // 如果是自己的拷贝构造函数且有初始化列表，那么 b2.z = b2.a.x = b2.a.y = 1
    cout << b2.z << " " << b2.a.x << " " << b2.a.y << endl;
    return 0;
}
```



## new 和 delete

### 为什么要有new和delete？

会调用构造函数和析构函数



### new vs malloc

和malloc不同的是，new返回的是有类型的指针，不用再强制类型转化；而malloc只返回void*

而且new可以重载，用于更加精细化内存管理，例如内存池模式



### 调用重载构造函数

new默认调用默认构造函数，如果要调用其他构造函数，要写成：

```c++
A p = new A(1);
```



new也可以用于内置基本类型



###动态数组

如果new申请的是一个数组，直接调用delete p而不是delete p[]，那么只会释放掉第一个对象的空间

delete void*会释放空间，因为分配的空间是和指针存放在一起的，但是不会调用析构函数

delete之后最好赋值成nullptr，可以防止二次delete（啥都不做）

```c++
class A{
public:
    A(){ cout << "A's default constructor" << endl; }
    A(int i){ cout << "A's int" << endl; }
    ~A(){ cout << "A's de-constructor" << endl; }
};

int main(){
    A *p = new A[10]{1};  // 调用1次带有参数的构造函数和9次默认的构造函数，且只能调用默认构造函数
    cout << p << endl;
    cout << &p[0] << endl;
    // delete p;  // 只调用一个析构函数，然后再调用delete []p会报错
    delete []p;  // 调用10个析构函数，且是逆序delete的

    void* vp = new A;
    delete vp;  // 会有编译警告，且不会调用析构函数
    return 0;
}
```



## const成员函数

实际上是this参数变为

```c++
void show(cosnt A* const this);
```

mutable关键字强调是可变的，因此可以在const成员函数里面修改mutable标记的变量

```c++
/*
本质上是函数的参数变为了 const A* const this

注意const重载的时候
自身是否是const不会重载
只有指向的是const还是非const才会构成重载
类的const成员函数就会构成这样的重载
*/
class A{
public:
    int x,y;
    int &indirect_int;
    mutable int m;
    A(int x1, int y1):indirect_int(*new int){};
    void f();
    // 非const和const形成了重载
    void show() const;
    void show();
};

void A::f(){
    x = 1;
    y = 1;
}

// 一定要写明到底有没有const
void A::show(){
    cout << "Not const" << endl;
}

// 一定要写明到底有没有const
void A::show() const {
    // 注意不能修改变量的值
    // x = 1;
    // 引用特殊，实际上引用就是const，修改的是引用指向的值
    // 事实上不存在const &，没有意义
    indirect_int = 1;
    // 标记为mutable的变量永远可修改
    m = 1;
    cout << "Const" << endl;
}

int main(){
    A a(0,0);
    // 调用的是非const的方法
    a.show();

    const A ca(0,0);

    // const对象不能调用非const的方法
    // ca.f();
    ca.show();

    return 0;
}
```



## 静态成员

同一个类的不同对象如何共享变量？

- 如果把这些共享变量定义为全局变量，则缺乏数据保护

- 名污染

使用static成员可以解决这个问题



头文件中只是声明静态成员变量，因此不会调用静态成员变量的构造函数

static变量初始化：

```c++
/*
引用、常量、静态

引用和常量必须在初始化列表中初始化
静态成员变量在类外初始化且不能再带有static关键字
*/
class A{
public:
    // 静态成员不能在类内部初始化
    // static int a = 0;
    static int o;

    // 但是静态的常量可以在类内初始化
    const static int a = 0;
    const static int b;
};

const int A::b = 1;

int A::o = 0;


int main(){
    A a;
    // const static 如果直接在类内给出值，那么用到的时候是作为常量直接替换，不会分配存储空间
    // cout << &a.a << endl;
    // 只有在类外定义才会有存储空间
    cout << &a.b << endl;
    return 0;
}
```



## 友元

### 为什么要有友元？

相对于c引入了访问权限，不能访问private成员，只能通过public方法，但是这会降低效率。既要有访问控制，又要有访问效率，因此就引入了友元，使得声明成友元的类或者方法可以直接使用该类的private成员



友元可以访问私有成员和私有方法

```c++
#include <iostream>
using namespace std;

class B{
public:
    void g();
};

class A{
private:
    int a;
    void f(){cout << "A's f()" << endl;}
    friend class B;
};

void B::g(){
    A a;
    // 友元类的成员函数可以调用私有方法
    a.f();
    // 友元类的成员函数可以调用私有成员
    cout << a.a << endl;
};

int main(){
    B b;
    b.g();
    return 0;
}
```



### 不完全声明

下面这个例子不能通过编译，因为看不到Vector的声明

编译器要提前计算每个数据的大小，由于引用或者指针都是一样大的，因此编译器只要知道类型的确存在就行了，所以只要写 class Vector; 就可以通过编译

注意这里是因为是引用或者指针才能用不完全声明来解决，如果要用到具体类型的成员方法或者成员变量，还是要看到具体的完全声明。因此如果是两个友元类的方法互相声明，那将无法解决

```c++
class Matrix
		{    ......
 		     friend void multiply(Matrix &m, Vector &v, Vector &r);
		};
class Vector
{    ......
  	friend void multiply(Matrix &m, Vector &v, Vector &r);
};

```





友元不具有传递性，也和继承体系无关



## 继承

### 访问权限

protected：外部访问不到，子类能访问；子类的友元也访问不到，只能通过子类来访问

```c++
#include <iostream>
using namespace std;

class A{
protected:
    void func1(){
        cout << "A's func1" << endl;
    }
};

class B: public A{
public:  
    // 子类中可以直接通过A来调用protected
    void func2(){
        A::func1();
    }
    // 不能通过A类型的对象来调用protected
    void fg(A a){
        // a.func1();
    }
    // 在B类中可以使用B对象的protected
    void g(B b){
        b.func1();
    }
    friend void gg();
};

void gg(){
    // 在友元中可以通过子类来使用protected
    B b;
    b.func1();
    // 友元中不能直接通过A来调用protected
    // A::func1();
}

int main(){
    B b;
    // 在B类的外部无法使用protected
    // b.func1();
    return 0;
}
```



### 继承权限

不管是哪一种权限，对自己的类没有影响

如果写成private，那么相当于把父类的public和protected改成自己的private

因此如果是private，那么它的子类啥都使用不了

如果是pretocted，就是把父类中的public变成自己的protected

默认是private，一般情况下没有意义



私有继承目的是复用基类的数据和方法，类似于组合，但是可以重载virtual function，更加灵活一点

私有继承而且还可以节省派生对象的大小，如果私有继承的子类没有成员函数，那么大小是0，组合的话还有一个组合对象的指针

注意私有继承在设计上没有意义，只是实现上复用方法以及节省空间

在设计上没有意义是因为私有继承和protected继承不能转化成基类

```c++
#include <iostream>
using namespace std;

class A{
public:
    virtual void func1(){
        cout << "A's func1" << endl;
    }
};

class B: public A{
private:  
    virtual void func1(){
        cout << "B's func1" << endl;
    }
};

int main(){
    // 有两点需要注意
    // 1. 如果在某个时刻，通过B的对象不能访问A的公有方法，那么此时B不能转化成A，指针和引用也不行
    // 2. 一旦B的某个形式可以转化成A，那么即使在B中为private，只要它是虚函数，通过A都可以访问到这个函数（编译器期间确定访问权限）
    A* a = new B;
    a -> func1();
    return 0;
}
```





### 不完全声明

```c++
//错误声明
Class Undergraduated_Student:public Student;
//正确声明
Class Undergraduated_Student;
// 不完全声明不需要指出继承关系
```



### 继承成员

如果子类中有同名的变量或者方法，会直接覆盖掉父类的

如果要保留父类的，那么要写明 A::f 或者 using A::f

```c++
#include <iostream>
using namespace std;

class Father{
public:
    void f(){cout << "Father f()" << endl;}
    void f(int){cout << "Father f(int)" << endl;}
};

class Son:public Father{
public:
    using Father::f;
    void f(){cout << "Son f()" << endl;}
};


int main(){
    Son s;
    s.f();
    // 使用了using就可以继承父类的所有同名方法了
    // 只会覆盖掉其中子类自定义的版本
    s.f(1);
    return 0;
}
```

using可以改变默认的访问权限

```c++
#include <iostream>
using namespace std;

class A{
public:
    void f(int){cout << "A's f(int)"<<endl;}
};

class B:private A{
public:
    // using 可以让private继承而来的函数变成public
    using A::f;
    void f(){cout << "B's f()"<<endl;}
};

int main(){
    B b;
    b.f(1);
    return 0;
}
```

对构造函数的处理特殊，见下



### 构造函数调用顺序

单继承：

从上往下调用构造函数

从下往上调用析构函数



### 继承构造函数

类不能继承默认、拷贝和移动构造函数，因为编译器会为派生类合成默认的

和"继承"别的函数一样，使用using即可，不过using完了之后，其他函数是直接照搬过来，但是对于构造函数，编译器会稍作修改

![image](https://s2.ax1x.com/2019/12/18/QTqAUJ.png)

还有一个区别就是，普通函数的using可以改变访问级别，例如我在private里面using，那么"继承"下来的函数就会是private的，但不是构造函数不一样，基类的私有构造函数在派生类中还是一个私有构造函数，而不管using出现在哪



![image](https://s2.ax1x.com/2019/12/18/QTqBVg.png)

![image](https://s2.ax1x.com/2019/12/18/QTqIIJ.png)



事实上，如果有private版本的重载函数（非构造函数），那么不能使用using

```c++
#include <iostream>
using namespace std;

class A{
private:
    A(int){}
    void f(int){cout << "A's f(int)"<< endl;}
public:
    A(){}
    void f(){cout << "A's f()" << endl;}
};

class B:public A{
public:
    // 如果有重载的版本为private的，那么不能继承，编译报错
    // 构造函数例外，编译不会报错，只是不会改变访问权限，仍然是private
    // using A::f;
    using A::A;
    void f(){cout << "B's f()"<<endl;}
};

int main(){
    B b;
    b.f();
    return 0;
}
```





## 虚函数

### 赋值相容，类型相容

可以通过=赋值的就是赋值相容的，例如可以把子类对象赋值给父类，对象切片，对象的身份发生了变化

类型相容是指保留了派生类的类型，例如通过指针或者引用来将派生类赋值给基类



### 前期绑定vs后期绑定

前期绑定

- 编译时刻
- 依据对象的静态类型
- 效率高、灵活性差

动态绑定：

- 运行时刻
- 依据对象的实际类型（动态）
- 灵活性高、效率低

c++注重效率，因此默认前期绑定，后期绑定需要显式指出(virtual)



### 限制

- 累的成员函数才可以是虚函数
- 静态成员函数不能是虚函数
- 内联成员函数不能是虚函数
- 构造函数不能是虚函数
- 析构函数可以（往往）是虚函数

**虚函数一定要有实现！！！纯虚函数例外**



### 虚析构函数

如果析构函数不是虚函数，那么派生对象得到的资源可能不会被释放
所以析构函数应该定义成虚函数

```c++
#include <iostream>
using namespace std;

class A{
public:
    int a;
    ~A(){
        cout << "A's de-constructor" << endl;
    }
    A(){}
    A(const A& a){
        cout << "A's copy function" << endl;
    }
};

class B:public A{
    int b;
public:
    ~B(){
        cout << "B's de-constructor" << endl;
    }
    B(){}
    B(const B& b){
        cout << "B's copy function" << endl;
    }
};

// 析构函数也会层层调用
// 调用如下函数，函数退出的时候
// 会依次调用B的析构函数和A的析构函数
void func(){
    B b;
    return;
}

int main(){
    A* a = new B;
    // 如果析构函数非虚，那么只会调用A的析构函数
    delete a;
    func();
    return 0;
}
```



### 原理

维护一张虚函数表

因此对对象做sizeof，除了成员变量的大小之外，还有虚函数表的指针大小

```c++
#include <iostream>
using namespace std;

class A{
    virtual void f(){}
};

class B:A{
    int a;
};

int main(){
    B b;
    // 大小比没有虚函数的大
    cout << sizeof(b) << endl;
    return 0;
}
```



### 到底调用哪个版本

**根据静态类型看能否调用；如果是virtual，且是通过指针和引用调用，根据动态类型找到调用哪个版本**



非虚调虚，行为变化（非虚接口）

虚调非虚，行为不变

注意如果是非指针的对象调用非虚函数，里面又调用了虚函数，仍然可以动态绑定。因为方法默认第一参数为*this是一个指针（非虚接口）



例子：

```c++
#include <iostream>
using namespace std;

class Father{
public:
    void f(){cout << "father's f()" << endl;}
    void f(int a){cout << "father's f(int)" << endl;}
    virtual void g() {cout << "father's g()" << endl;}
};

class Son:public Father{
public:
    void f(){cout << "son's f()" << endl;}
    void g() {cout << "son's g()" << endl;}
};

int main(){
    // 调用非虚函数，调用的都是父类的
    // 只有虚函数会动态调用到子类的
    Father *f = new Son;
    f->f(1);
    f->f();

    // 如果不是指针，那么即使是虚函数也不会动态调用
    Father ff = Son();
    ff.g();
    return 0;
}
```



```c++
#include <iostream>
using namespace std;

class Father{
public:
    virtual void f(){
        cout << "Father: f()"<<endl;
        g();
    }
    void f(int a){cout << "Father: f2(int a)"<<endl;}
    virtual void g(){cout << "Father: g()"<<endl;}

    void nvf(){
        cout << "Father: nvf()" << endl;
        g();
    }
};

class Son:public Father{
public:
    // using Father::f;
    void f(){
        cout << "Son: f()"<<endl;
        g();
    }

    void g(){
        cout << "Son: g()"<<endl;
    }
};

int main(){
    // 虚函数调用非虚函数和虚函数的行为都是一致的
    // 前提是子类没有同名的非虚函数
    Father *f = new Son;
    // 会调用子类的g()
    // 无论此时g是否是virtual
    f->f();
    cout << endl;

    Father *ff = new Father;
    ff->f();
    // 会调用父类的g()
    // 无论此时g是否是virtual
    cout << endl;



    // 非虚函数调用虚函数和非虚函数是有区别的
    // 这也是模版方法的实现基础
    // 这时候如果g是virtual，那么可以调用到子类的g()
    // 否则调用的是父类的g
    f->nvf();
    cout << endl;




    // 如果不是指针，那么只能调用父类的方法，与virtual无关
    Father f2 = Son();
    f2.f();
    cout << endl;

    Son s;
    // virtual与redefined无关
    // 如果有同名方法仍旧会被覆盖
    // 需要使用using
    // s.f(2);
    return 0;
}
```



特别注意下面这个例子，权限检查是静态时完成的，一旦静态类型检查通过，运行时就会动态调用：

https://www.zhihu.com/question/22526510

```c++
#include <iostream>
using namespace std;

class A{
public:
    virtual void f(){cout << "A's f()" << endl;}
};

class B:public A{
private:
    void f(){cout << "B's f()" << endl;}
};

int main(){
    A* a = new B;
    // 仍然可以调用B的私有方法
    // 权限检查是静态编译过程中就确定了的
    a -> f();
    return 0;
}
```





### 构造函数和析构函数中调用虚函数

不会有虚函数的特性，构造和析构到哪一步，调用那一步类型的对应函数



构造函数中B（子类）的虚函数表还没构造

因此调用的还是A（父类）的f

也可以理解成B还没构造完的时候，仍然是A对象

```c++
#include <iostream>
using namespace std;

class A{
public:
    A(){f();}
    virtual void f(){cout << "A's f()"<<endl;}
    virtual ~A(){f();}
};

class B:public A{
public:
    void f(){cout << "B's f()"<<endl;}
};

int main(){
    // 无论是构造过程还是析构过程
    // 调用的都是A的f()
    // 因为到A的时候
    // 1. B还没有构造
    // 2. B已经析构
    // 因此调用的都是A的f
    B b;
    return 0;
}
```





### final && override

见例子：

```c++
#include <iostream>
using namespace std;

class A{
public:
    virtual void f()final{}
    void g(){}
};

class B:public A{
public:
    void g(int a){}
};


// 只有虚函数才能被定义为final
// 不允许再被覆盖
int main(){
    A a;
    return 0;
}
```

```c++
#include <iostream>
using namespace std;

struct A{};
struct C:A{};

struct B{
    virtual void f1(int) const;
    virtual A& fc();
    virtual double fc2();
    virtual void f2();
    void f3();
    // 非虚函数不能用final修饰
    // void f5(int) final;

    virtual void f5(int) final;
};

struct D:B{
    // 正确
    void f1(int) const override;

    // 错误，virtual重载的返回类型也要一致
    // int f1(int) const override;

    // 正确，虽然要求返回值相同
    // 但是协变也是可以的
    // https://blog.csdn.net/gjggj/article/details/72626794
    C& fc()override;
    // 基本类型没有协变
    // int fc2()override;


    // 错误，因为没有重载任何函数
    // 因为不是const
    // void f1(int) override;


    // 下面这是重写的f1，而不是重载
    void f1(int);


    // 错误，没有重载任何函数
    // void f2(int) override;

    // 错误，f3不是virtual修饰，不能重载
    // 只能重写
    // void f3() override;

    // 因为f5是final，因此不能重载
    // void f5(int);
};

int main(){
    return 0;
}
```

另外注意，如果子类中没有virtual，那么调用的还是父类的版本

```c++
#include <iostream>
using namespace std;

class B{
public:    
    virtual void f1(){ cout << "father's f1()" << endl; };
};

class D:public B{
public:
    void f1(int){ cout << "son's f1()" << endl; };
};

int main(){
    B *b = new D;
    b -> f1();
    return 0;
}
```



### 纯虚函数

纯虚函数也可以有实现，但是不能是在类中实现，只能写在类外

有默认实现的纯虚函数仍然不能实例化，派生类仍然需要重写

可以显式调用纯虚函数的默认实现

抽象类不能被实例化，因此抽象类作为接口的时候，只能传递指针和引用，不会有对象切片的问题

```c++
#include <iostream>
using namespace std;

class A{
public:
    virtual void func1()=0;
    // 纯虚函数不能直接写inline实现
    // {
    //     cout << "default A func1" << endl;
    // }

    void func2()
    {
        // 普通函数或普通虚函数可以直接写inline实现
        cout << "default A func2" << endl;
    }
};

// 纯虚函数可以有实现，但是实现只能在类定义的外部，不能inline
void A::func1(){
    // 纯虚函数即使有默认实现，派生类仍然需要重写该方法
    cout << "default A func1" << endl;
}

class B: public A{
public:    
    void func1(){
        // 这样就可以调用纯虚函数的默认实现了
        A::func1();
        cout << "B func1" << endl;
    }
};

int main(){
    B b;
    b.func1();
    b.func2();
    return 0;
}
```



### 虚函数的默认参数

默认参数静态绑定，如果是动态绑定，那么调用的时候还要再查找一次默认参数的值
这样就要查表两次（找虚函数一次，找默认参数）效率低，因此编译的时候直接用值来替换默认参数，即对象中只记录虚函数的入口地址

```c++
#include <iostream>
using namespace std;

class A{
public:
    virtual void f(int a = 0) { cout << "A's f() " << a << endl;}
};

class B:public A{
public:
    void f(int a = 1) { cout << "B's f() " << a << endl;}
};

class C:public A{
public:
    void f(int a) { cout << "C's f() " << a << endl;}
};

int main(){
    // 默认参数静态绑定
    // 下面全都是打印0
    A *p_a;
    B b;
    p_a = &b;
    p_a -> f();

    A *p_a1;
    C c;
    p_a1 = &c;
    p_a1 -> f();
    return 0;
}
```



## 多继承

**非虚直线继承(单继承)**

B继承A，C继承B，那么C可以使用A中的成员变量和方法，但是不允许直接调用A的构造函数，**即只能负责直接基类的构造函数调用**

构造函数调用顺序为：

对C实例化，要先实例化B，要先实例化A

因此可以看到下面的输出为：

A's int a 2
B's int a 1
C's int a 0326696997（无意义的值）
A's f()（这个是在C的构造方法里面调用的A的f）

```c++
#include <iostream>
using namespace std;

class A{
protected:
    int a;
public:
    A(){}
    A(int a){cout << "A's int a " << a << endl;}
    void f(){cout << "A's f()" << endl;};
};

class B:public A{
public:
    B(){}
    B(int a):A(2){cout << "B's int a " << a << endl;}
};

class C:public B{
public:
    C(){}
    // 可以这样使用间接非虚拟基类的可访问的成员变量和成员方法（但是不能直接调用构造方法）
    C(int a):B(1){cout << "C's int a " << a << A::a << endl;A::f();}
    // 不允许使用间接非虚拟基类的构造函数
    // C(int a):A(1){cout << "C's int a" << endl;}
};

int main(){
    // 构造函数层层调用
    C c(0);
    return 0;
}
```



**非虚菱形继承**

构造函数的调用顺序为派生列表中基类的出现顺序保持一致

如果有同名变量要加上基类类型

```c++
#include <iostream>
using namespace std;

class A{
public:
    int a;
    A(){}
    A(int a):a(a){cout << "A's int a " << a << endl;}
};

class B:public A{
public:
    B(){}
    B(int a):A(2){cout << "B's int a " << a << endl;}
};

class C:public A{
public:
    C(){}
    C(int a):A(1){cout << "C's int a " << a << endl;}
};

class D:public C, public B{
public:
    D(){}
    // 可以通过::来访问不同父类中的同名变量
    // 该同名变量可能是父类自身的，也可能是父类继承而来的
    D(int a):B(1),C(2){cout << "D's int a in B is " << B::a << endl;}
};

int main(){
    // 构造函数层层调用
    // 顺序为派生类的继承列表顺序
    // 且此时因为B和C是非虚继承
    // 因此A会初始化两次
    D d(0);
    // D中的a不明确，二义性
    // cout << d.a << endl;
    // 正确的是要加上明确的父类
    cout << d.B::a << endl;
    return 0;
}
```

构造函数和析构函数的调用顺序

```c++
#include <iostream>
using namespace std;

class A{
public:
    int a;
    A(){}
    A(int a):a(a){cout << "A's constructor" << endl;}
    ~A(){cout << "A's deconstructor" << endl;}
};

class B:public A{
public:
    B(){}
    B(int a):A(2){cout << "B's constructor" << endl;}
    ~B(){cout << "B's deconstructor" << endl;}
};

class C:public A{
public:
    C(){}
    C(int a):A(1){cout << "C's constructor" << endl;}
    ~C(){cout << "C's deconstructor" << endl;}
};

class D:public C, public B{
public:
    D(){}
    D(int a):B(1),C(2){cout << "D's constructor" << endl;}
    ~D(){cout << "D's deconstructor" << endl;}
};

int main(){
    // 构造函数层层调用
    // 顺序为派生类的继承列表顺序
    // 且此时因为B和C是非虚继承
    // 因此A会初始化两次
    // 析构函数是相反的顺序
    D d(0);
    return 0;
}
```



**虚基类**

如果直接基类有公共的基类，则该公共基类中的成员变量，在多继承的派生类中有多个副本，**为了消除这种多副本的情况，使用虚基类**

下面这两种都行：

```c++
class A;
class B:virtual public A;
class C:public virtual A;
class D:B, C;
```

显然，整体设计好了之后才会知道哪些需要虚继承

is a关系变为has a关系，没有拷贝，B和C中只是有指向同一个A对象的指针，在没有实例化D时，虚基类不会构造，**虚基类的构造函数是由最新派生出的类（D）的构造函数来调用的（其他类对该基类的构造函数调用完全不起作用），且虚基类的构造函数优先非虚基类的构造函数执行**

```c++
#include <iostream>
using namespace std;

class A{
protected:
    int a;
public:
    A(){}
    A(int a):a(a){cout << "A's int a " << a << endl;}
};

class B:virtual public A{
protected:    

public:
    B(){}
    // 此时B不会调用A的构造函数
    B(int a):A(2){cout << "B's int a " << a << endl;}
    void f(){cout << "B's f()" << A::a << endl;}
};

class C:virtual public A{
protected:
    int a;
public:
    C(){}
    // 此时C不会调用A的构造函数
    C(int a):A(1){cout << "C's int a " << a << endl;}
    void f(){cout << "C's f()" << A::a << endl;}
};

class D:public C, public B{
protected:
    int a;
public:
    D(){}
    // 如果使用了虚继承，那么初始化A的责任就交到了D身上
    // 如果D没有调用A的构造函数，那么A不会被初始化，此时B::a因为是继承自A的，那么将会是任意值
    // 如果D指明调用A的构造函数，那么无论A在初始化列表中的位置如何，永远优先调用A的构造函数
    // B和C对于A的初始化完全没有作用
    D(int a):B(1),C(2),A(100){cout << "D's int a " << a << endl;}
    // 可以使用A::a来访问A的成员变量和方法
    // 如果存在vitual和非virtual，或者两个非virtual继承，那么都认为同名的变量或者方法是不明确的，不能使用A::a
    void f(){cout << "D's f()" << A::a << endl; B::f(); C::f();}
};

int main(){
    D d(0);
    // B和C公用同一个A，持有指向同一个a对象的指针
    d.f();
    return 0;
}
```

输出：

```c++
A's int a 100
C's int a 2
B's int a 1
D's int a 0
D's f()100
B's f()100
C's f()100
```



**虚继承和非虚继承同时存在**

```c++
#include <iostream>
using namespace std;

class A{
protected:
    int a;
public:
    A(){}
    A(int a):a(a){cout << "A's int a " << a << endl;}
};

class B:virtual public A{
protected:    

public:
    B(){}
    // 此时B不会调用A的构造函数
    B(int a):A(2){cout << "B's int a " << a << endl;}
    void f(){cout << "B's f()" << A::a << endl;}
};

class C:virtual public A{
protected:
    int a;
public:
    C(){}
    // 此时C不会调用A的构造函数
    C(int a):A(1){cout << "C's int a " << a << endl;}
    void f(){cout << "C's f()" << A::a << endl;}
};

class E:public A{
protected:
    int a;
public:
    E(){}
    E(int a):A(1000){cout << "E's int a " << a << endl;}
    void f(){cout << "E's f()" << A::a << endl;}
};

class D:public E,public C, public B{
protected:
    int a;
public:
    D(){}
    // 虚基类的构造函数优先非虚基类的构造函数执行
    D(int a):B(1),C(2),E(3),A(100){cout << "D's int a " << a << B::a << endl;}
    void f(){cout << "D's f()" << endl; B::f(); C::f();E::f();}
};

int main(){
    D d(0);
    // B和C公用同一个A，持用指向同一个a对象的指针，且和D中的相同
    // E有自己的A
    d.f();
    return 0;
}
```

输出为

```c++
A's int a 100
A's int a 1000
E's int a 3
C's int a 2
B's int a 1
D's int a 0100
D's f()
B's f()100
C's f()100
E's f()1000
```



### 小结和补充

一个子类可以继承多个类，每一个继承都可以有自己的继承方式，成员变量的情况和单继承一样，只不过是多个

多继承的构造函数的调用顺序为派生列表中基类的出现顺序保持一致，且子类只能负责直接基类的构造函数调用（非虚继承的情况下）

子类可以继承构造函数，但是如果继承而来的构造函数是一样的，那么就会出错，此时子类必须要有自定义版本的该构造函数

![](https://s2.ax1x.com/2019/12/31/l1XQEt.png)



**类型转化的二义性错误**

![](https://s2.ax1x.com/2019/12/31/l1XT2D.png)



**同名的变量或者方法的二义性错误**

![](https://s2.ax1x.com/2019/12/31/l1jzwR.png)

除非指明调用的版本

```c++
cout << d.B::a << endl;
```



**内存布局**

![](https://s2.ax1x.com/2019/12/31/l3SY0H.png)

