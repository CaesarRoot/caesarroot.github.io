---
title: 乘积最大子序列
date: 2019-09-10 13:59:39
categories: leetcode
tags: [刷题, 动态规划]
cover_img: https://s2.ax1x.com/2019/09/17/nI3qxg.jpg
feature_img: https://s2.ax1x.com/2019/09/17/nI3qxg.jpg
description:
keywords:
---

# 题目

给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-product-subarray

# 思路

连续最大的乘积序列，可以考虑什么时候连乘会变小—有时候是0，有时候是负数

对于负数而言，他会让之前正数连乘的积变成最小；同时也会让之前的负数连乘变成最大。因此我们要保留两个值：之前连乘的最大和最小值

对于可能出现0的情况，其实不用考虑，因为此时连乘的最大最小值都是0

为了保证每次都可以得到连乘的max和min，在每次计算乘积的时候，都要取计算的结果和当前位置的max或者min。例如，计算连乘max的时候，MAX = max(MAX*nums[i], nums[i])

遇到负数，交换最大最小，再计算



# 题解

参考：https://leetcode-cn.com/problems/maximum-product-subarray/solution/hua-jie-suan-fa-152-cheng-ji-zui-da-zi-xu-lie-by-g/


``` c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int result = -100000;
        int Max = 1;
        int Min = 1;
        for(int i=0; i<nums.size(); i++){
            if(nums[i]<0) {
                int temp = Max;
                Max = Min;
                Min = temp;
            }
            Max = max(Max*nums[i], nums[i]);
            Min = min(Min*nums[i], nums[i]);
            
            result = max(result, Max);
        }
        return result;
    }
};
```



