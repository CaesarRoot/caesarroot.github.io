---
title: 滑动谜题
date: 2019-11-24 10:09:57
categories: [算法]
tags: [刷题,暴搜]
cover_img:
feature_img:
description:
keywords:
---

# 题目

在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.

一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.

最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。

给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/sliding-puzzle



# 思路

要求最短路径，想到dfs或者bfs，bfs求出的答案直接就是最短路径

考虑一个棋盘，搜索就是将0滑动到其他方块，走到下一个状态。因此可以将棋盘当前的状态用一个string唯一记录，0滑动到下一个状态就可以用另一个string表示，用一个map来记录走过的所有棋盘状态以免重复

最终状态是可以确认的，因此就可以判断是否可以搜索到结果



# 题解

```c++
#include <iostream>
#include <vector>
#include <string>
#include <queue>
#include <map>
#include <string>
using namespace std;

class Solution {
public:
    int slidingPuzzle(vector<vector<int>>& board) {
        string dest = "123450";
        vector<vector<int>> pos{{1,3},{0,2,4},{1,5},{0,4},{1,3,5},{2,4}};
        string start = "";
        for(int i = 0; i < 2; i++){
            for(int j = 0; j < 3; j++){
                start += to_string(board[i][j]);
            }
        }
        map<string, int> memory;
        memory.insert(pair<string, int>{start, 1});
        queue<pair<string, int>> q;
        q.push(pair<string, int>{start,0});
        int found = -1;
        while(!q.empty()){
            pair<string,int> now = q.front();
            q.pop();
            if(now.first == dest){
                found = now.second;
                break;
            }
            int index = now.first.find('0');
            for(int i = 0; i < pos[index].size(); i++){
                string temp = now.first;
                temp[index] = temp[pos[index][i]];
                temp[pos[index][i]] = '0';
                if(memory.find(temp) == memory.end()){
                    memory.insert(now);
                    q.push(pair<string, int>{temp, now.second+1});
                }
            }
        }
        return found;
    }
};
```

