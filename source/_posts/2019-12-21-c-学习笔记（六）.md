---
title: c++学习笔记（六）
date: 2019-12-21 11:39:48
categories: c++
tags: c++
cover_img:
feature_img:
description:
keywords:
---

# C部分

## Data

数据包括：

1. 名
2. 值
3. 地址
4. 类型
5. 性质

其中类型指的是：取值范围和操作

c++是强类型，动静结合的语言（实际上还是静态）



## 基本数据类型

char int float double

修饰符：long short signed unsigned

char 只能用signed、unsigned修饰

float 不能被修饰

double 只能用long修饰

int 可以用以上4种修饰符组合修饰，例如long long int a;实际上为8个字节，和long long长度一样，当然长度是和机器有关的



一个char的大小和一个机器字节一样，8bits

wchar_t为宽字符类型，16bits



int short long 和 long long都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型，例如unsigned long，类型unsigned int可以缩写为unsigned

char有三种类型：char、signed char、unsigned char



### 类型别名typedef

typedef可以定义类型的别名，含有typedef的声明语句定义的不再是变量而是类型别名，如下：

![image](https://s2.ax1x.com/2019/12/21/QjdeEV.png)

再如：

pstring是char *的别名

![image](https://s2.ax1x.com/2019/12/21/QjdHaV.png)

pstring指代的类型要作为整体来看，不能直接带入原来的类型

![image](https://s2.ax1x.com/2019/12/21/QjdzrR.png)

上面的常量指针表达好像有点问题，见下面这个例子

```c++
int main(){
    int i = 1;
    const pa i1 = &i;
    // 正确
    // i1并不是指向常量，而是指针本身不可修改
    *i1 = 2;
    const int *i2 = &i;
    // 错误
    // i2指向常量
    // *i2 = 2;
    return 0;
}
```



typedef和数组

```c++
typedef int A[10];

void f(int (&a)[11]){

}

int main(){
    A a;
    cout << sizeof(a)/sizeof(a[0]) << endl;
    // 错误
    // A是长度为10的数组
    // f的参数为长度为11的数组的引用，不兼容
    // f(a);
    return 0;
}
```



## 表达式求值

副作用值得是求值次序引起的结果不确定：例如y+ ++y



### 计算中的类型转换

```c++
int main(){
    int x=10;
    int y=3; double d=2.0 ;
    // 因为计算顺序问题会产生不同的结果
    // cout << d + x/y*d + ++y << endl;

    // 因为x/y仍然是整数，因此结果为8
    cout << d + x/y*d << endl;
    // 因为d*x/y是浮点数，因此结果为浮点数
    cout << d + d*x/y << endl;

    // 要注意下面这样其实是没用的，结果还是3
    cout << 1.0*(x / y) << endl;
    return 0;
}
```



### 三目操作符的嵌套

```c++
int main(){
    int x = -100;
    // 三目运算符可以嵌套
    // 遵循就近原则
    // 结果为-1
    cout << (x > 0? 1: x == 0? 0 : -1) << endl;
    return 0;
}
```



### 逗号表达式

如果有一连串的逗号表达式赋值，那么最右边的那个表达式的值会赋值给左边，如下：

```c++
int main(){
    int a,b,c;
    int d = (a = 1, b = a+2, c = b+3);
    // 最后一个表达式的值赋值给d
    // 输出结果为6
    cout << d <<endl;
    return 0;
}
```



### 位运算符

主要是异或的运算比较特别

![image](https://s2.ax1x.com/2019/12/21/Qjq3M4.png)



### switch的优化

如果内部实现成多个if else嵌套，那么最多找到正确的分支的时间为O(N)

![image](https://s2.ax1x.com/2019/12/21/QjXFxO.png)

优化成只比较一次：

首先取出switch中的值，然后和最大值比较，如果超过，那么跳转到default，否则直接跳转到对应的情况的起始地址（专门做了一张表，按照顺序存放了各个可能情况的处理代码的起始地址，这样switch中的值就是作为偏移量，*4之后加上这张表的基址，就可以直接找到对应处理代码的起点）

![image](https://s2.ax1x.com/2019/12/21/Qjzlkj.png)



### 表驱动编程

处理错误的时候，可以在一个数组中放struct，struct为错误信息，处理错误的函数指针（因为错误处理函数的接口都一样，因此可以统一定义类型）



## 函数

### 函数调用过程分析

函数传递参数有两种形式：值传递和引用传递

下面先看值传递的情况：

![image](https://s2.ax1x.com/2019/12/21/Qv9P7F.png)

例子中调用者维护堆栈：

调用前，ebp在高地址，esp在低地址，中间是main函数的栈（已经包含了将要调用的函数的参数空间）

参数从右到左放入（使用mov，移动到esp+某个偏移量，这样效率比push高）

返回地址压栈（push，esp向下移动）

跳转到新函数的起始地址开始执行

push ebp，将ebp压栈，保存原来的ebp

然后将ebp移动到此时的esp处（和第一个参数间隔0x8）

esp移动到下面，分配足够这个函数运行的栈空间

执行函数体，通过esp+0x8可以取出第一个参数，+0xc取出第二个参数，返回值放在eax中

将esp置回esp的位置

弹栈，还原main函数的ebp

再弹栈，找到原先压入的返回地址

返回之后，将eax的值（返回值）放到相应位置

![image](https://s2.ax1x.com/2019/12/21/QvCwKx.png)

![image](https://s2.ax1x.com/2019/12/21/QvCRxI.png)

上面这种方式为cdecl call，由调用者清理参数的栈，这可以应对可变参数的情况（因为调用者知道有多少个实际参数，从而可以正确清理堆栈）

另一种方式是stdcall，由被调用者清理堆栈，不能处理可变参数的情况

还有一种方式是fastcall，用寄存器传递参数

cdecl call的栈情况

![image](https://s2.ax1x.com/2019/12/21/QvFKxA.png)



下面看引用传递的情况：

![image](https://s2.ax1x.com/2019/12/21/QvkWtS.png)

和前面的区别是放入栈中的不再是一个数字，而是一个地址

这个地址就是引用变量的地址，之后通过lea就可以操作原来的那个变量的值了



![image](https://s2.ax1x.com/2019/12/21/Qvk6mt.png)

![image](https://s2.ax1x.com/2019/12/21/Qvkr6A.png)



总结：

![image](https://s2.ax1x.com/2019/12/21/QvEJIK.png)



还有两种特别奇葩的方式：c++好像没有实现

![image](https://s2.ax1x.com/2019/12/21/QvV3lQ.png)

![image](https://s2.ax1x.com/2019/12/21/QvVGOs.png)

### 函数声明

使用外部c函数要声明extern "C"，因为c++有重载c无重载，所以符号表不一样，因此一定要声明来自c，否则找不到



### 函数重载

返回值类型不作为区别重载函数的依据

但是const可以区分，例如：

```c++
/*
注意const重载的时候
自身是否是const不会重载（因为没有意义）
只有指向的是const还是非const才会构成重载
类的const成员函数就会构成这样的重载
*/
void f(int *a){
    cout << "Not const" << endl;
}

// 不构成重载
// void f(int *const a){

// }

void f(const int *a){
    cout << "Const" << endl;
}
```



函数重载可能会出现二义性问题

```c++
void f(int a){
    cout << "f(int)" << endl;
};

void f(double a){
    cout << "f(double)" << endl;
};

// 如果是精确匹配不会有问题
// 非精确匹配如果有转化优先级则不会有问题
// 否则就会有问题
int main(){
    // long a = 1;
    short a = 1;
    f(a);
    return 0;
}
```

上面的例子中如果是第一行，因为long转为int和double并没有优先级，会报错，short优先转为int，因此不会报错



### 默认参数

靠右边写，因为函数的参数是从右向左压栈

默认参数会导致二义性：

```c++
void f(int);
void f(int, int=2);
```



### inline函数

推荐而非强制，取决于调用方式

加上inline不一定真的是内联函数，是否真的是inline还要看编译器的决定，如果inline被拒绝，那么每一份单独的文件里面都会出现该函数，仍然是函数调用，只不过被限制了作用域（static）

inline函数不能是递归函数，如果是递归，那么拒绝inline

如果有对inline函数取地址的操作，那么也会拒绝inline

和宏相比：有类型检查

inline函数调用前必须要有函数体，因为编译系统将为inline函数创建一段代码，每次调用时，用相应的代码替换，因此内联函数，包括函数模板中的内联 – 一般都是放在头文件中



inline的缺点：增大目标代码；病态的换页；降低指令块取装置的命中率



## 程序组织

### extern

在头文件中声明，源文件中定义

头文件中声明成extern不会再分配空间，会在符号表留下位置



### const

const默认作用域为本文件，因为编译之后直接拿值替换了

例如：

a.cpp为：

```c++
#include <iostream>
using namespace std;

const int a = 1;

int main(){
    return 0;
}
```

b.cpp为：

```c+
extern const int a;

void f(){
    int b = a;
}
```

link阶段会报错

为了使得可以共享同一常量，应该将常量统一写在头文件中



### static

static修饰函数内变量有全生命周期，但是可访问的范围还是不变

```c++
class A{
public:
    ~A(){cout << "~ A" << endl;}
};

void f(){
    static A a;
    return;
}

int main(){
    f();
    cout << "main finished" << endl;
    return 0;
}
```

上面的例子中，先打印main finished，再打印~ A



static可以记录下函数的访问次数

```c++
int fun(void){
    static int count = 0;
    return count++;
}

// static变量全生命周期
// 且可以用来记录访问次数
// 这一点和类的static成员变量类似
int main(void)
{    
    for(int i = 0; i < 10; i++)
        cout << fun() << endl;    
    return 0;
}
```



不作任何处理的变量和函数都是程序级的（都可以访问）

加上static表示文件级的，两个文件中有同名的static函数（因为限制在文件级中，不会冲突）



### namespace

在约束作用域方面，替代static

解决全局变量/函数的名冲突

两种形式：

using-declaration，例如using L::k

using-directive, 例如using namespace L（不建议在同一作用域两次使用using-directive）



#### 支持别名

```c++
namespace ATT = American_Telephone_and_Telegraph
```



#### 可嵌套

```c++
namespace L1 { 
  inta;
	.......
	namespace L2 { 
    void f() ;
		.......
	} 
}
........

L1::L2::f();
using namespace L1; 
L2::f();
```

内层命名空间声明的名字将隐藏外层命名空间声明的同名成员。在嵌套命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码想要访问它必须在名字前添加限定符



#### 可以是不连续的

![image](https://s2.ax1x.com/2019/12/21/Qv2DoQ.png)



#### 全局命名空间

全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在全局命名空间中。

作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并没有名字：

```c++
::member_name
```



#### 例子

```c++
// 全局变量，默认初始化为0
int a;

namespace X { 
    // 命名空间中的变量，默认初始化为0
    int a;
    void f(){
        int a = 0;
        // 临时变量
        a++;
        // X中的a
        X::a++;
        // 全局的a
        ::a++;
        // 三个都输出1
        cout << ::a << endl;
        cout << X::a << endl;
        cout << a << endl;
    }
};

int main(){
    X::f();
    return 0;
}
```



## 预处理宏

优点：

方便程序修改

提高程序运行效率



缺点：

看不到名字，不利于调试

不能数值拷贝

不能做参数类型检查

可能会降低可读性



### 常量

可以用#define定义常量，已被const取代



### 内联函数

可以用#define定义无数个重载版本，已被inline取代。inline有类型检查



### 泛型函数

可以用#define定义无数个重载版本，实现泛型编程，已被template取代



### 泛型类型

同样被template取代



### 重命名

可以用#define进行重命名，已被namespace取代



### 字符串拼接

无法取代

```c++
#define conn(x,y) x##y
#define ToChar(x) #@x
#define ToString(x) #x
```

https://blog.csdn.net/xdsoft365/article/details/5911596



### 预定义ifndef

无法取代

![image](https://s2.ax1x.com/2019/12/21/QvhjgA.png)





### 控制程序组织

例如#pragma可以定义内存布局



## 数组

相同类型，连续存储

注意字符数组：

![image](https://s2.ax1x.com/2019/12/21/Qv4PUS.png)



### 多维数组

可以这样看：

```c++
T A[c1][c2]
typedef T T1[c2]
T1 A[c1];
```



作为函数参数，需要传递第二维，省略第一维：

```c++
void f(int a[][3], int n);
```



## struct

可以控制对齐的程度



## Union

共享存储空间



例子：

```c++
union B{
    char b;
    int a;
    short c;
};

int main(){
    B b;
    b.a = 0x12345678;
    cout << b.a << endl; 
    // 输出的是16进制78的十进制值
    // 因为是小端存储，因此78放在高地址处
    // 可见char是对齐到高地址处
    cout << (int)b.b << endl; 
    return 0;
}
```



### 例题

定义数组，存储100个图形（直线、矩形，圆）

直线和矩形都要4个int

圆只要3个int

不能统一定义

需要加一个字段表示类型

因此最后的形式为：

![image](https://s2.ax1x.com/2019/12/21/Qv7EnA.png)

![image](https://s2.ax1x.com/2019/12/21/Qv7uh8.png)



## 指针

空指针不一定是0，例如：

```c++
// 如果定义空指针是0
// 那么下面的代码将产生问题
void f(int);
void f(int *);
f(NULL)
```

因此引入专门的值：nullptr



### 指针运算

指针加减整数运算，+1会偏移sizeof(基类型)

![image](https://s2.ax1x.com/2019/12/21/QvHrRS.png)





同类型的指针相减，得到的是整型，偏移量，具体为：

值差/sizeof(基类型)，和上面加减整数的定义保持一致

![image](https://s2.ax1x.com/2019/12/21/QvHRZn.png)



### 指针的输出

char*特殊，直接输出的话是字符串，如果输出\*p，那么因为p其实是第一个元素的地址，所以输出的是第一个字符，如果真的要输出地址，那么需要转型为(int\*)

![image](https://s2.ax1x.com/2019/12/21/QvHWaq.png)



### void*指针

只管理地址信息，定义的是指针类型的公共接口，任何指针都可以转化为void*指针（可以强制转化，也可以直接写void\* a = &x），反之则不行（只能强制类型转换）



用途：

![image](https://s2.ax1x.com/2019/12/21/QvbkdI.png)

![image](https://s2.ax1x.com/2019/12/21/QvqbU1.png)



### 指针常量和常量指针

从最靠近变量名开始向外看

![image](https://s2.ax1x.com/2019/12/21/Qvq9hV.png)



### const_cast

可以将const转为非const

可以用于函数调用中，但是修改const的值仍然是不允许的

```c++
#include <iostream> 
using namespace std; 
  
int fun(int* ptr) 
{ 
    *ptr = *ptr + 10; 
    return (*ptr); 
} 
  
int main(void) 
{ 
    // val本来就是const，改变了const的值
    // 输出是未定义的
    const int val = 10; 
    const int *ptr = &val; 
    int *ptr1 = const_cast <int *>(ptr); 
    fun(ptr1); 
    cout << val << endl; 
    return 0; 
} 
```

如果删除掉val原来的const定义，那么下面的行为是允许的：

```c++
#include <iostream> 
using namespace std; 
  
int fun(int* ptr) 
{ 
    *ptr = *ptr + 10; 
    return (*ptr); 
} 
  
int main(void) 
{ 
    // val本来就是const，改变了const的值
    // 输出是未定义的
    const int val = 10; 
    const int *ptr = &val; 
    int *ptr1 = const_cast <int *>(ptr); 
    fun(ptr1); 
    // 输出10，因为常量的值编译时候就填入了
    cout << val << endl; 
    return 0; 
} 
```



像上面例子一样，看下面这个例子：

因为常量的值编译的时候就会做替换，所以同一个地址看起来有两个值：

![image](https://s2.ax1x.com/2019/12/21/QvLi5t.png)



### 指针常量

<类型>* const<指针变量>

必须在定义的时候就初始化（所有常量都是如此）



### 指针与函数

作为形式参数：

![image](https://s2.ax1x.com/2019/12/21/QvLeKg.png)



作为函数指针：

注意两种等价形式

![image](https://s2.ax1x.com/2019/12/21/QvL82T.png)



应用，计算器程序：

![image](https://s2.ax1x.com/2019/12/21/QvLxJ0.png)

进一步优化：

![image](https://s2.ax1x.com/2019/12/21/QvOVF1.png)



泛型冒泡排序：

![image](https://s2.ax1x.com/2019/12/21/QvONSf.png)

 

计算积分的接口：

![image](https://s2.ax1x.com/2019/12/21/QvjCVJ.png)



### 指针与数组

数组的名字可以直接使用，为指向第一个元素的指针，因此用指针访问数组元素和使用下标具有同等的能力

但是数组名不能修改，即不能a++，（这并不代表它是一个常量，事实上，指针名可以作为参数传入非const的一维指针形参）如下：

```c++
#include <iostream>
using namespace std;

int main(){
    int a[10] = {0};
    int *p = a;
    for(int i = 0; i < 10; i++){
        cout << *(a+i) << endl;
        // 错误 a是指向第一个元素，但是是int *const
        // cout << *(a++) << endl;

        // 正确，相当于把 int *const赋值给int *
        cout << *(p++) << endl;
    }
    return 0;
}
```



对于二维数组来说，可以按照一维数组来访问，当然也可以按照二维数组来访问

```c++
&a[0][0] == a[0]
&b[0] == b // 对于二维数组也同样适用
```



下面的q就是一个指向大小为3的数组的指针，其类型和a的第一个维度相同，因此可以直接赋值

**使用指针++的形式效率更高（inc指令，只要一条指令即可）**

```c++
#include <iostream>
using namespace std;

int main(){
    int a[2][3] = {1,2,3,4,5,6};
    // 或者 &a[0][0]
    int *p = a[0];
    for(int i = 0; i < 6; i++){
        // 输出 1 2 3 4 5 6
        // 可以越界访问，但是输出是随机值
        cout << *(p++) << endl;
    }
    int (*q)[3] = a;
    for(int i = 0; i < 2; i++){
        for(int j = 0; j < 3; j++){
            cout << q[i][j] << endl;
        }
    }
    return 0;
}
```



计算偏移量访问：

```c++
#include <iostream>
using namespace std;

int main(){
    int a[2][3] = {1,2,3,4,5,6};
    // 或者 &a[0][0]
    int *p = a[0];

    for(int i = 0; i < 2; i++){
        for(int j = 0; j < 3; j++){
            // 一维指针计算偏移量
            cout << *(p + 3*i + j) << endl;
        }
    }

    int (*q)[3] = a;
    for(int i = 0; i < 2; i++){
        for(int j = 0; j < 3; j++){
            // 二维指针计算偏移量
            cout << *(*(q + i) + j) << endl;
        }
    }
    return 0;
}
```



对数组名使用sizeof得到的是整个数组的大小

如果将指针名赋值给一个int，sizeof得到的是指针大小而不是数组大小

```c++
#include <iostream>
using namespace std;

int main(){
    int *p = nullptr;
    // 输出8
    // 运行时该编译器默认指针长度为8
    cout << sizeof(p) << endl;

    int a0[10] = {0};
    // 输出40
    // 40 = 4 * 10
    cout << sizeof(a0) << endl;
    // 输出8
    // a0+1为指向第二个元素的指针，长度为8
    cout << sizeof(a0+1) << endl;

    int a[2][3] = {1,2,3,4,5,6};
    // 输出24
    // 24 = 2 * 3 * 4
    cout << sizeof(a) << endl;
    // 输出8
    // a+1指向的类型为int (*)[3]
    // 是一个指针，因此长度为 8（int *的长度为8）
    cout << sizeof(a+1) << endl;

    // 输出8
    // 尽管指向的位置和a0相同
    // 但是sizeof得到的是q（指针）的大小
    int *q = a0;
    cout << sizeof(q) << endl;
    return 0;
}
```



#### 降维

通过取地址就可以完成

可以让二维数组使用一维数组的接口：

![image](https://s2.ax1x.com/2019/12/22/QzqijS.png)



#### 升维

需要借助typedef或者用强制类型转换

```c++
#include <iostream>
using namespace std;

void show(int a[], int n){
    for(int i=0;i<n;i++)
        cout << a[i] << " " << endl;
    cout << endl;
};

void show(int a[][2], int n){
    for (int i=0;i<n;i++)
        for (int j=0;j<2;j++) {
                cout << *(a+i)+j << ":"
                     << a[i][j] << " ";
                // 每输出4个值就换行     
                if ((i*2+j+1)%4 == 0) cout << endl;
        }
        cout << endl;
};

void show(int a[][2][3], int n){
    for (int i=0;i<n;i++)
        for (int j=0;j<2;j++) 
            for (int k=0;k<3;k++){
                cout << *(*(a+i)+j)+k << ":"
                     << a[i][j][k] << " ";
            if ((i*6+j*3+k+1)%4 == 0) cout << endl;
            }
            cout << endl;
};


int main(){
    int b[12];
    for (int i=0;i<12;i++) b[i] = i+1;
    show(b,12);
    typedef int T[2]; 
    show( ( T *) b,6);
    // 等价形式，注意括号
    show( ( int (*)[2]) b,6);
    typedef int A[3]; 
    typedef A B[2]; 
    show((B *) b,2);
    // 等价形式，注意括号
    show( ( int (*)[2][3]) b,2);
    cout << endl;
    return 0;
}
```



### 多级指针

如果是一个指针类型例如char *，那么取地址之后就是char **

如果是一个数组名，例如 char p[5]，那么取地址之后就是char (*)[5]，而不是char **

```c++
#include <iostream>
using namespace std;

void swap(char **p1, char **p2) { 
    char *tmp = *p1;
    *p1 = *p2;
    *p2 = tmp; 
};

int main(){
    // 报错，&p1的类型是char (*)[5]
    // char p1[] = "abcd"; 
    // char p2[] = "1234";
    char *p1 = "abcd";
    char *p2 = "1234";
    // 可以正确交换
    cout << p1 << " " << p2<<endl; 
    swap( &p1,&p2 ); 
    cout << p1 << " " << p2<<endl; 
    return 0;
}
```



正确的版本：

```c++
#include <iostream>
using namespace std;

void swap(char *&p1, char *&p2) { 
    char *tmp = p1;
    p1 = p2;
    p2 = tmp; 
};

void f(char *c){}

int main(){
    // 可以正确交换
    char p1[] = "abcd"; 
    char p2[] = "1234";
    cout << p1 << " " << p2<<endl; 
    swap( p1,p2 ); 
    cout << p1 << " " << p2<<endl; 
    return 0;
}
```

注意指针名并不是const，它是可以交换的！！！



## 可变参数

![image](https://s2.ax1x.com/2019/12/23/lSML7D.png)

第一个的参数的地址是必须提供的，也就是可变参数必须至少包含一个参数，这个参数用来寻址，实现对所有参数的访问



### printf

主要是理解三个宏：

![image](https://s2.ax1x.com/2019/12/23/lSMXAe.png)



因为是以32位对齐，所以可变参数部分需要实现以int的长度为单位的向上取整，即_INTSIZEOF(x)

使用：

![image](https://s2.ax1x.com/2019/12/23/lSQENQ.png)

marker的类型是char*，每次+都只增加一个内存单元



## 动态变量

malloc返回void *，需要类型转化

如果返回null则说明申请失败



和new的区别就是

1. new调用构造函数
2. new返回的是有类型的指针
3. new可以重载，让内存分配更加合理
4. new如果失败会抛出bad_alloc异常



返回的指针仍然是在栈中



new一个数组：

多维数组可以升维得到

```c++
#include <iostream>
using namespace std;

int main(){
    // 申请一维数组
    int *p = new int[10];
    // 然后类型转换
    int (*p2)[5] = (int (*)[5])p;
    for (int i=0;i<10;i++) p[i] = i+1;
    for (int j=0;j<2;j++){ 
        for (int k=0;k<5;k++)
            cout << p2[j][k] << " "; 
        cout << endl;
    }
    return 0;
}
```
直接得到多维数组：
```c++
#include <iostream>
using namespace std;

int main(){
    // 先定义一个中间类型
    typedef int i5Array[5];
    // 然后直接申请得到二维数组
    i5Array* p = new i5Array[2];
    for (int j=0;j<2;j++)
        for (int k=0;k<5;k++)
            p[j][k] = (j*5)+(k+1);
    return 0;
}
```



### 归还

new 对应 delete

如果是数组，那么要用delete []

实现的机制是

在返回地址的上面一个地址记录申请到的size，所以返回的指针不能动，不然不能正确free

```
A *p = new A[10]
如果是delete p
只会调用一个析构函数
但是如果是delete[] p
会调用所有的析构函数

如果是int的话就没区别，上面的区别是针对类的
```



malloc 对应 free



## 链表

### 结点定义

![image](https://s2.ax1x.com/2019/12/23/l9CaBn.png)

### 插入操作

表头插入需要判断表头是否为空，分为两种情况讨论

![image](https://s2.ax1x.com/2019/12/23/l9Co9O.png)

表为插入要求head非空

找到next为null的节点，将next赋值

![image](https://s2.ax1x.com/2019/12/23/l9CjEt.png)

某个值的节点后面插入

从head开始搜索，只要不是null，就判断值是否是a（短路表达式），一直循环下去

循环外要判断是否为null

![image](https://s2.ax1x.com/2019/12/23/l9Psat.png)

某个值前面插入

因为是单向链表，需要记录前一个节点（guard node）

![](https://s2.ax1x.com/2019/12/23/l9iKFP.png)

### 删除操作

如果使用next来判断的话比较简单，不用保存前一个节点用于连接（见有序链表）

否则要保存前一个节点用来连接

![](https://s2.ax1x.com/2019/12/23/l9iaF0.png)



### 有序链表

基本结构：

![](https://s2.ax1x.com/2019/12/23/l9iBSU.png)

插入：

类似于在节点后插入（简单一点，不用guard node）

![](https://s2.ax1x.com/2019/12/23/l9FVpT.png)

删除操作：

使用next判断比较简单

![](https://s2.ax1x.com/2019/12/23/l9kp8K.png)



要特别注意指针操作：

![](https://s2.ax1x.com/2019/12/23/l9FUnH.png)

## 引用

引用变量时必须要有初始化



引用要保持类型相同，例如指针的引用仍然要是指针

```c++
#include <iostream>
using namespace std;

int main(){
    int *p = new int;
    int *&x = p;
    cout << *x << endl;
    return 0;
}
```



![image](https://s2.ax1x.com/2019/12/23/l9eaDS.png)



非const引用不能引用一个非左值

```c++
int main(){
    // 错误
    // int &p = 1;
    // 正确
    const int &p = 1;
    return 0;
}
```



如果函数返回值的类型是引用或指针类型，则不应把局部变量或局部变量的地址作为返回值返回。因为函数退出的时候会将栈破坏掉，局部变量都不会保留下来

注意如果传入数组，返回数组中元素的引用，那是可以的

```c++
#include <iostream>
using namespace std;

int &max3(int x[], int num) { 
    int i, j;
    j = 0;
    for (i=1; i<num; i++)
        if (x[i] > x[j]) j = i; 
    return x[j];
}

int main(){
    int a[] = {1,2};
    cout << max3(a, 2) << endl;
    return 0;
}
```

由于返回的是引用，甚至可以 max3(xxx, 2) = 100;



对于指针来说也一样：

```c++
#include <iostream>
using namespace std;

int * max2(int x[], int num) { 
    int *p,*q;
    p = x; q = x+1; 
    while (num > 1){ 
        if (*q > *p) p = q;
        q++; num--; 
    }
    return p; 
}

int main(){
    int a[] = {1,2};
    cout << *max2(a, 2) << endl;
    return 0;
}
```



释放堆中变量的引用

```c++
#include <iostream>
using namespace std;

int main(){
    int *p = new int(100);
    int &x = *p;
    cout << x << endl;
    // 这里要取地址
    delete &x;
    return 0;
}
```

