---
title: c++容器库（一）
date: 2019-10-06 10:50:03
categories: [c++]
tags: [c++, 容器, stl]
cover_img:
feature_img:
description:
keywords:
---

# 容器库操作层次

- 所有容器类型都提供的
- 仅针对三大容器类型中的一种：顺序容器、关联容器、无需容器
- 仅适用于一小部分容器



# 所有容器类型通用操作

## 头文件

容器一般在和容器同名的头文件中声明。



## 类型

所有的容器类型都是模版类，因此可以限定类型



## 通用操作

![image](https://s2.ax1x.com/2019/10/06/u62jyj.png)



## 迭代器

### 迭代器的范围

[begin, end)



### 迭代器大小

只有能够随机访问的容器的迭代器才可以比较大小，例如vector；list因为不是随机的，因此只能比较是否相等：

http://www.cplusplus.com/reference/iterator/

![image](https://s2.ax1x.com/2019/10/06/u6RMtK.png)

即这个写法是错的：

![image](https://s2.ax1x.com/2019/10/06/u6RLAx.png)



### 正向反向迭代器

iterator和reverse_iterator。

反向迭代器的所有操作都会相反。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main(){
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    vector<int>::reverse_iterator rit;
    for(auto rit = v.rbegin(); rit != v.rend(); rit++) {  // rbegin和reverse_iterator是配套的
        cout << *rit << endl;  // 注意这里要解引用
    }

    return 0;
}
```



### const迭代器

当使用begin的时候，会根据容器的内容来决定是否是一个const_iterator。

![image](https://s2.ax1x.com/2019/10/06/u6fXlD.png)

如果使用begin而且是一个const_iterator，那么就会报错：（报错）

```c++
const vector<int> cv;
vector<int>::iterator cvi = cv.begin();
```



## 其他容器类型

容器定义了很多类型，这些类型和具体的容器类型以及他的模版类型都有关系，例如迭代器类型和size_type。

元素类型：value_type

元素类型的一个引用：reference或const_reference

迭代器距离：difference_type



## 容器初始化

![image](https://s2.ax1x.com/2019/10/06/u64oPx.png)

array并不适用于 C c(b,e) 这种初始化，这一点和数组比较像。

如果提供的值小于容量，那么其余的都是0，例如：

```c++
array<int, 10> a = {42};  // 第一个元素为42，其余为0
```

不提供值，那么里面的值是不确定的。

注意：

```c++
array<int, 10> a{};
```

这样会初始化为全0。



### PS：数组初始化

数组中如果：

```c++
int a[100] = {0};
```

是全0，如果改成非0的数就只有第一个数赋值了，剩余的都是0

如果:

```c++
int a[100];
```

那么如果是全局或者静态变量，是0，否则是随机值。

注意：

```c++
int a[100]{};
```

也会初始化为全0





注意虽然array没有迭代器，但是仍然可以用指针来初始化，例如：

```c++
int arr[3];
arr[0] = 1;
arr[1] = 2;
arr[2] = 3;
vector<int> v(arr, arr+3);
```



### 初始化和拷贝

创建一个容器为另一个容器拷贝时，类型必须严格匹配；

用迭代器参数来指定拷贝范围时，不需要严格匹配。

例如：

![image](https://s2.ax1x.com/2019/10/06/u65zm4.png)

注：容器的拷贝不管是容器本身还是里面的元素，都是深度拷贝，不会影响原来的值。



### array的初始化

array不是数组，但是很像数组。也有固定大小，初始化必须指定array大小。

数组可以直接赋值给array。



## 交换和赋值

![image](https://s2.ax1x.com/2019/10/06/uc3or9.png)

assign的两种形式：

```c++
names.assign(oldstyle.cbegin(), oldstyle.cend())
```

```c++
slist1.assign(10, "Hiya!");
```

注意assign的参数类型不必严格匹配，但是用=赋值必须保证参数类型严格匹配。

assign之后指向原来容器的所有指针都会失效，例如迭代器等。



swap可以高效交换两个相同类型的容器，除了array外，只是交换和数据结构，而不是真实的内存，所有指针不会失效，但是仍然指向原来的元素。

array特殊，真正交换了元素，交换时间与个数成正比，而且指针指向的内容也发生了变化。



## 容器大小操作

empty方法判断容器是否为空

size返回个数

max_size返回该容器所能容纳的最大元素个数

forward_list不支持size方法



## 容器比较大小

容器要完全相同才能比较大小。

比较的是容器里面的元素。

具体规则如下：

![image](https://s2.ax1x.com/2019/10/06/ucddPA.png)

因为比较的是容器内的元素，所以要容器中的元素定义了比较，容器才可以比较。



# 参考资料：

1. 《Primer c++ 第五版》
2. http://www.cplusplus.com/reference/iterator/