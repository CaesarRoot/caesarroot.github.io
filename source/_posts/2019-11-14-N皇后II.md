---
title: N皇后II
date: 2019-11-14 21:56:19
categories: [算法]
tags: [刷题,暴搜]
cover_img:
feature_img:
description:
keywords:
---

# 题目

n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给定一个整数 n，返回 n 皇后不同的解决方案的数量。

示例:

输入: 4

输出: 2

解释: 4 皇后问题存在如下两个不同的解法。

[

 [".Q..",  // 解法 1

  "...Q",

  "Q...",

  "..Q."],

 ["..Q.",  // 解法 2

  "Q...",

  "...Q",

  ".Q.."]

]



来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/n-queens-ii



## 思路

暴力搜索+回溯

不需要用二维数组来记录，因为每个皇后必不在一行，因此只要一个一维数组，然后可以再对应的列记录下每一层皇后的信息（例如行号或者转换成一维数组后的position）

搜索的时候，重点在于检验交叉是否有皇后，向上层搜索，限制住深度和宽度就行



# 题解

```c++
#include <iostream>
#include <vector>
using namespace std;

class Solution {
private:
    int res;
public:
    int totalNQueens(int n) {
        res = 0;
        vector<int> column;
        for(int i = 0; i < n; i++){
            column.push_back(-1);
        }
        dfs(column, 1, n);
        return res;
    }

    void dfs(vector<int>&column, int now, int n){
        if(now <= n){
            for(int i = 0; i < column.size(); i++){
                if(column[i] == -1){
                    // 尝试放一下
                    int position = (now - 1) * n + i;
                    if(check(position, column, n)){
                        // 确实可以放
                        column[i] = position;
                        // 递归
                        dfs(column, now+1, n);
                    }
                    // 回溯
                    column[i] = -1;
                }
            }
        } else {
            res++;
        }
    }

    bool check(int position, const vector<int>& column, int n){
        // 约束住宽度
        int column_num = position % n;
        int bias = 1;
        // 约束住深度
        int times = position / n;

        while((column_num-bias>=0 || column_num+bias<n) && bias <= times){
            for(int i = 0; i < column.size(); i++){
                // 两边搜索
                if(column_num-bias>=0){
                    if(column[i] == position - (n+1)*bias) return false;
                }
                if(column_num+bias<n){
                    if(column[i] == position - (n-1)*bias) return false;
                }
            }
            bias++;
        }
        return true;
    }
};

int main(){
    Solution s;
    cout << s.totalNQueens(8) << endl;
    return 0;
}
```

