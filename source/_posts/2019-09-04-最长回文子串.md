---
title: 最长回文子串
date: 2019-09-04 23:37:35
categories: 算法
tags: [动态规划, 刷题]
cover_img: https://s2.ax1x.com/2019/09/04/nekdZ8.png
feature_img: https://s2.ax1x.com/2019/09/04/nekdZ8.png
description:
keywords:
---

# 题目

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-palindromic-substring

# 思路

首先能想到的一个思路是获得所有子串，判断是否是回文，再取最长的

稍微优化一下就是，遍历每一个字符，作为中心点，向两边扩展，这样可以直接判断是否是回文，然后长度也可以直接求出

注意这里中心点可以是一个，例如aba；也可以是两个，例如abba



# 解法

这里因为两种情况的扩展是相似的，所以可以抽象成一个函数，不同的是传入的参数来控制中心点是一个还是两个

作者：LeetCode
链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/
来源：力扣（LeetCode）

``` java
public String longestPalindrome(String s) {
    if (s == null || s.length() < 1) return "";
    int start = 0, end = 0;
    for (int i = 0; i < s.length(); i++) {
        int len1 = expandAroundCenter(s, i, i);
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = Math.max(len1, len2);
        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    int L = left, R = right;
    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
        L--;
        R++;
    }
    return R - L - 1;
}
```



评论下面还有两个方法可以优化

1. 字符中间插入特殊字符，来同一个两种中心点

2. 马拉车算法

   https://segmentfault.com/a/1190000008484167