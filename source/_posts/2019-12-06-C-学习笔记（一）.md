---
title: C++学习笔记（一）
date: 2019-12-06 17:32:45
categories: c++
tags: c++
cover_img:
feature_img:
description:
keywords:
---

# 运算符重载

## 条件

不能重载内置类型的操作符，因此至少有一个运算分量是自定义类型



## 分类

从重载的形式来看：

1. 作为成员函数重载
2. 作为全局函数重载

其中，如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的thi指针上



从运算分量的数目来看：

1. 单目
2. 双目

其中对于二元运算来说，左侧运算对象传递给第一个参数，而右侧对象传递给第二个参数



## 不能被重载的操作符

![image](https://s2.ax1x.com/2019/12/06/QYkIht.png)

四个操作符不能被重载



## 不推荐被重载的操作符

逗号、取地址、逻辑与和逻辑或运算符

因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。

除此之外，&&和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值

还有一个原因使得我们一般不重载逗号运算符和取地址运算符：C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应



## 基本原则

遵循原有的语法：单目/双目、优先级、结合性



## 选择成员还是非成员重载

![image](https://s2.ax1x.com/2019/12/06/QYAWvT.png)

对于第一条：

原因是：编译器如果遇到内置类型作为运算分量的操作符，那么无法识别，会先去类内找有无重载版本，然后再在全局找有无重载版本，这四个函数有内部合成的函数，例如=对应的是赋值操作，类内已有合成的默认行为，因此如果是全局重载，编译器根本不会找到，优先找类内部的重载版本



一个错误的示例：

![image](https://s2.ax1x.com/2019/12/06/QYEFRP.png)

这里产生错误的原因是有一对矛盾冲突：即类内操作符重载要求第一个参数必须是本类本对象的this指针，而双目运算要求第一个参数是必须是双目操作符左边的运算分量

同样的一个例子是<<操作符的重载版本只能是全局重载



## 双目操作符重载

### 重载形式

两种形式：

![image](https://s2.ax1x.com/2019/12/06/QYEuIs.png)

![image](https://s2.ax1x.com/2019/12/06/QYENdJ.png)

全局函数重载，写成友元函数friend

双目运算符为了支持对称调用，一般做如下处理

![image](https://s2.ax1x.com/2019/12/06/QYEbwQ.png)



### 返回值

一般来说双目运算返回的是一个临时变量（右值）

而单目运算符如果需要改变自身状态的话，返回引用（左值）



### 返回值的编译优化

一个例子：

![image](https://s2.ax1x.com/2019/12/06/QYViTJ.png)



## 单目操作符重载

### 重载形式

![image](/Users/cengshaoxun/Library/Application Support/typora-user-images/image-20191209213530405.png)

## 例子和特殊例子

### 输出运算符<<

```c++
class A{
private:
    int a;
public:
    A(int a):a(a){}
    friend ostream& operator<<(ostream &os, const A& a);
};

ostream& operator<<(ostream &os, const A& a){
    os << a.a;
    return os;
}
```

第一个形参四一个非常量ostream对象的引用，因为要修改它的值

第二个形参为常量引用

返回的是ostream的引用，这样可以链式调用

必须是非成员函数

一般声明成friend友元



### 输入运算符>>

```c++
class A{
public:
    int a;
    friend istream& operator>>(istream &is, A& a);
};

istream& operator>>(istream &is, A& a){
    is >> a.a;
    return is;
}
```

和<<运算符不同的是第二个形参是非const的，因为要改变它的值



### 算数和关系运算符

一般定义成非成员函数，这样可以对类型进行转化

形参一般都是const，因为不需要改变值

结果常常位于一个局部变量之内，返回该局部变量的副本作为结果



#### ==运算符

返回的是bool值

```c++
class A{   
public:
    int a;
    friend bool operator==(const A& a1, const A& a2);
};

bool operator==(const A& a1, const A& a2){
    return a1.a==a2.a;
}
```



#### <运算符

形式和和==基本上一样

```c++
class A{   
public:
    int a;
    friend bool operator<(const A& a1, const A& a2);
};

bool operator<(const A& a1, const A& a2){
    return a1.a<a2.a;
}
```



#### +运算符

这里不采用全局重载的形式，而是类内重载

```c++
class A{
public:
    int a;
    const A operator+(const A& a) const;
};

const A A::operator+(const A& a) const{
    A ta;
    ta.a = this->a;
    ta.a += a.a;
    return ta;
}
```

形参味const &，返回类型为const，不需要引用

末尾加上const，这样即使是const对象也可以调用



如果要和内置类型做加法，那么可以这样写

```c++
class A{
public:
    int a;
    A(){}
    // 可以定义包含一个参数的构造函数
    // 这样int可以自动转化成A对象
    // 然后+函数为全局重载
    // 这样无论int在前还是在后
    // 都可以自动转化成A，然后调用该运算符
    A(int a):a(a){}
    friend A const operator+(const A& a1, const A& a2);
};

A const operator+(const A& a1, const A& a2){
    A ta;
    ta.a = a1.a;
    ta.a += a2.a;
    return ta;
}
```

构造函数只有一个int参数，这样int就会自动转化成A类型，无论是在+前还是后，都可以正确计算

也可以使用()类型转化运算符进行转化，如果()和只有一个参数的构造函数共存的时候，有可能会产生冲突，见下面的()运算符



### =运算符

赋值运算符

形式：

```c++
class MString{
public:
    string *p;
    // 可以自我赋值的一种写法
    MString& operator=(const MString& s){
        // 临时拷贝底层的指针
        string *ts = new string(*(s.p));
        // 释放内存
        delete p;
        // 拷贝到自己
        this->p = ts;
        // 返回自己
        return *this;
    }
};
```

接受的参数为const &，返回的是&

注意四个步骤的顺序不能打乱，否则自我赋值会有问题



### +=运算符

不是一定要类内重载，也可以全局重载

```c++
class A{
public:
    int a;
    A& operator+=(const A& a);
};

A& A::operator+=(const A& a){
    this->a += a.a;
    return *this;
}
```





### 前缀++和后缀++

主要区别在返回值和参数上

![image](https://s2.ax1x.com/2019/12/09/Q08Wfs.png)

### 赋值操作符

默认是浅拷贝

例如如果对象在heap上有分配空间，拷贝的时候会指向同一块内存空间，那么就会导致一个对象析构的时候另一个对象的指针飞了

但是就算重载了赋值操作，例如下面这段代码，如果是自我赋值的话，仍然会出现问题，因此还要避免自我赋值

![image](https://s2.ax1x.com/2019/12/09/Q0JQr6.png)

### 下标运算符

[]运算符只能在类内重载，不能作为全局函数重载

一般都要重载两个版本（const的和非const的）

非const版本返回引用，可以作为左值被修改

const版本的返回值可以不是引用

![image](https://s2.ax1x.com/2019/12/09/Q0YWfH.png)

多维数组的情况：

如果是二维的数组，那么其实只要返回指针，第二次的[]操作其实用的是指针的[]

如果是多维的数组，那么可以嵌套一个内部类

如下：

![image](https://s2.ax1x.com/2019/12/09/Q0UUk8.png)

这样就可以实现多个维度的嵌套



### ( )运算符

只能是成员函数

既是函数调用，也是类型转化（也可以通过带有一个参数的构造函数重载，然后直接赋值，同样也可以达到隐式转化的目的；两个转化的方向不同，一个是将本类转为其他——（）运算符，一个是将其他转为本类—— 构造函数）

#### 作为类型转化操作符

可以减少混合计算中需要定义的操作符重载函数的数量（也可以通过写成构造函数的形式，将传入的参数转为本类型）

如下：

```c++
#include <iostream>
using namespace std;

class Rational { 
public:
    Rational(int n1, int n2) { n = n1; d = n2; } 
    // 重载构造函数也可以达到隐式类型转化的目的
    Rational(double d){cout << "constructor" << endl;}
    operator double() { cout << "operator ()" << endl; return  (double)n/d; }
    // 可以和()共存，最佳匹配，直接匹配到这个函数
    double operator+(double d){cout << "operator +" << endl; return d + n/d;}
    // 当调用的时候有Rational+double的时候不能和()共存
    // 因为都要进行类型转化，无法确定是调用这个函数，将double转为Rational，还是调用()，将Rational转为都变了
    // 两个都可以转化，产生歧义
    // 但是如果调用的情况是double+Rational，那么则可以，因为只能是Rational通过()运算符转化为double
    // double operator+(Rational d){cout << "operator +" << endl; return 0;} 
private:
    int  n, d;
};

int main(){
    Rational  rr = 1.1;
    Rational  r(1,2);  
    // 调用()进行类型转化
    double x = r;  
    // 如果参数和operator +匹配的话那么优先调用operater +
    // 否则调用()
    x = r + x; 
    cout << x << endl;
    return 0;
}
```

#### 其他类型转化二义性冲突汇总

可以看到上面这个例子中有潜在的冲突（见注释）

还有一种冲突如下：

```c++
struct B;
struct A{
  A() = default;
  A(const B&);  // B转化成A
};
struct B{
  operator A() const;  // B转化成A
};
A f(const A&e);
B b;
A a = f(b);  // 冲突，有两种转化方式！！！
```

上面代码中有两种B转化成A的方式，因此就存在二义性，会冲突



还有一种冲突如下：

```c++
struct A{
  A(int = 0);
  A(double);
  operator int() const;
  operator double() const;
}

void f2(long double);
A a;
f2(a);

long lg;
A a2(lg);
```

当参数无法精确匹配的时候，且int转化为long double和double转化为long double转化的优先级一致，因此产生了冲突

同样，初始化a2的时候，long转化为double和long转化为int也是没有优先级的，因此产生了错误

如果有优先级，那么其实是可以的：

```c++
short s = 42;
A a3(s);
```

因为short优先转化成int，所以没问题



还有一种冲突如下：

```c++
struct C{
  C(int);
};
struct D{
  D(int);
}

void manip(const C&e);
void manip(const D&e);
manip(10);
```

两个函数都可以匹配



#### 作为函数调用重载

可以实现函数对象，在标准库中广泛使用

![image](https://s2.ax1x.com/2019/12/09/Q00B5V.png)

![image](https://s2.ax1x.com/2019/12/09/Q00fV1.png)

![image](https://s2.ax1x.com/2019/12/09/Q00456.png)

![image](https://s2.ax1x.com/2019/12/09/Q00bKH.png)

函数对象也有局限性，即如果定义的接口是指针，那么不能传入函数对象，因为类型不同

![image](https://s2.ax1x.com/2019/12/09/Q00XVI.png)

于是可以使用function类型，这个类型的接口可以传入所有可调用类型

![image](https://s2.ax1x.com/2019/12/09/Q0BpRS.png)

但是有个缺点就是重载函数不行，还得用函数指针或是lambda对象

![image](https://s2.ax1x.com/2019/12/09/Q0BPMQ.png)

### -> 操作符

![image](https://s2.ax1x.com/2019/12/16/Q5CwB6.png)

智能指针

![image](https://s2.ax1x.com/2019/12/16/Q5C7CQ.png)

![image](https://s2.ax1x.com/2019/12/16/Q5Cqvn.png)

New有两个作用：不确定数目的情况下，用new动态新建对象；跨越作用域，全生命周期

问题就是**new**出来的对象会跨越作用域，但是如果是如果包装成一个对象，那么就会失去长生命周期