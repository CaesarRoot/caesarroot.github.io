---
title: C++学习笔记（一）
date: 2019-12-06 17:32:45
categories: c++
tags: c++
cover_img:
feature_img:
description:
keywords:
---

# 运算符重载

## 条件

不能重载内置类型的操作符，因此至少有一个运算分量是自定义类型



## 分类

从重载的形式来看：

1. 作为成员函数重载
2. 作为全局函数重载

其中，如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的thi指针上



从运算分量的数目来看：

1. 单目
2. 双目

其中对于二元运算来说，左侧运算对象传递给第一个参数，而右侧对象传递给第二个参数



## 不能被重载的操作符

![image](https://s2.ax1x.com/2019/12/06/QYkIht.png)

四个操作符不能被重载



## 不推荐被重载的操作符

逗号、取地址、逻辑与和逻辑或运算符

因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。

除此之外，&&和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值

还有一个原因使得我们一般不重载逗号运算符和取地址运算符：C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应



## 基本原则

遵循原有的语法：单目/双目、优先级、结合性



## 选择成员还是非成员重载

![image](https://s2.ax1x.com/2019/12/06/QYAWvT.png)

对于第一条：

原因是：编译器如果遇到内置类型作为运算分量的操作符，那么无法识别，会先去类内找有无重载版本，然后再在全局找有无重载版本，这四个函数有内部合成的函数，例如=对应的是赋值操作，类内已有合成的默认行为，因此如果是全局重载，编译器根本不会找到，优先找类内部的重载版本



一个错误的示例：

![image](https://s2.ax1x.com/2019/12/06/QYEFRP.png)

这里产生错误的原因是有一对矛盾冲突：即类内操作符重载要求第一个参数必须是本类本对象的this指针，而双目运算要求第一个参数是必须是双目操作符左边的运算分量

同样的一个例子是<<操作符的重载版本只能是全局重载



## 双目操作符重载

### 重载形式

两种形式：

![image](https://s2.ax1x.com/2019/12/06/QYEuIs.png)

![image](https://s2.ax1x.com/2019/12/06/QYENdJ.png)

全局函数重载，写成友元函数friend

双目运算符为了支持对称调用，一般做如下处理

![image](https://s2.ax1x.com/2019/12/06/QYEbwQ.png)



### 返回值

一般来说双目运算返回的是一个临时变量（右值）

而单目运算符如果需要改变自身状态的话，返回引用（左值）



### 返回值的编译优化

一个例子：

![image](https://s2.ax1x.com/2019/12/06/QYViTJ.png)



## 单目操作符重载

### 重载形式

![image](/Users/cengshaoxun/Library/Application Support/typora-user-images/image-20191209213530405.png)

## 特殊例子

### 前缀++和后缀++

主要区别在返回值和参数上

![image](https://s2.ax1x.com/2019/12/09/Q08Wfs.png)

### 赋值操作符

默认是浅拷贝

例如如果对象在heap上有分配空间，拷贝的时候会指向同一块内存空间，那么就会导致一个对象析构的时候另一个对象的指针飞了

但是就算重载了赋值操作，例如下面这段代码，如果是自我赋值的话，仍然会出现问题，因此还要避免自我赋值

![image](https://s2.ax1x.com/2019/12/09/Q0JQr6.png)

### 下标运算符

[]运算符只能在类内重载，不能作为全局函数重载

一般都要重载两个版本（const的和非const的）

非const版本返回引用，可以作为左值被修改

const版本的返回值可以不是引用

![image](https://s2.ax1x.com/2019/12/09/Q0YWfH.png)

多维数组的情况：

如果是二维的数组，那么其实只要返回指针，第二次的[]操作其实用的是指针的[]

如果是多维的数组，那么可以嵌套一个内部类

如下：

![image](https://s2.ax1x.com/2019/12/09/Q0UUk8.png)

这样就可以实现多个维度的嵌套



### ( )运算符

只能是成员函数

既是函数调用，也是类型转化（也可以通过带有一个参数的构造函数重载，然后直接赋值，同样也可以达到隐式转化的目的；两个转化的方向不同，一个是将本类转为其他——（）运算符，一个是将其他转为本类—— 构造函数）

作为类型转化操作符：

可以减少混合计算中需要定义的操作符重载函数的数量（也可以通过写成构造函数的形式，将传入的参数转为本类型）

如下：

```c++
#include <iostream>
using namespace std;

class Rational { 
public:
    Rational(int n1, int n2) { n = n1; d = n2; } 
    // 重载构造函数也可以达到隐式类型转化的目的
    Rational(double d){cout << "constructor" << endl;}
    operator double() { cout << "operator ()" << endl; return  (double)n/d; }
    // 可以和()共存，最佳匹配，直接匹配到这个函数
    double operator+(double d){cout << "operator +" << endl; return d + n/d;}
    // 不能和()共存
    // 因为都要进行类型转化，无法确定是调用这个函数，将double转为Rational，还是调用()，将Rational转为都变了
    // 两个都可以转化，产生歧义
    // double operator+(Rational d){cout << "operator +" << endl; return 0;} 
private:
    int  n, d;
};

int main(){
    Rational  rr = 1.1;
    Rational  r(1,2);  
    // 调用()进行类型转化
    double x = r;  
    // 如果参数和operator +匹配的话那么优先调用operater +
    // 否则调用()
    x = r + x; 
    cout << x << endl;
    return 0;
}
```



作为函数调用重载：

可以实现函数对象，在标准库中广泛使用

![image](https://s2.ax1x.com/2019/12/09/Q00B5V.png)

![image](https://s2.ax1x.com/2019/12/09/Q00fV1.png)

![image](https://s2.ax1x.com/2019/12/09/Q00456.png)

![image](https://s2.ax1x.com/2019/12/09/Q00bKH.png)

函数对象也有局限性，即如果定义的接口是指针，那么不能传入函数对象，因为类型不同

![image](https://s2.ax1x.com/2019/12/09/Q00XVI.png)

于是可以使用function类型，这个类型的接口可以传入所有可调用类型

![image](https://s2.ax1x.com/2019/12/09/Q0BpRS.png)

但是有个缺点就是重载函数不行，还得用函数指针或是lambda对象

![image](https://s2.ax1x.com/2019/12/09/Q0BPMQ.png)

