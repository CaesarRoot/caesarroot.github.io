---
title: 软件设计—行为型模式
date: 2019-12-22 14:49:28
categories: 软件设计
tags: 软件设计
cover_img:
feature_img:
description:
keywords:
---

# 策略模式

## 一个例子

我们要设计一个鸭子类型，自然的就想到继承。设计一个父类为鸭子，然后具体的鸭子子类去继承这个父类

![image](https://s2.ax1x.com/2019/12/22/QxvKKK.png)

如果我们需要添加接口，就在父类上添加接口，然后具体的子类实现

但是这会产生一个问题，即添加的行为不是所有子类都有，例如有的橡皮鸭子不会飞

而且每次产生新的类型的鸭子的时候，可能都需要覆盖掉这些不需要的方法

因此我们考虑接口，如下：

![image](https://s2.ax1x.com/2019/12/22/QxvY8I.png)



但是接口同样不好，因为我们不能复用代码，例如有的行为是一样的，原先继承父类的方法就行了，现在接口就无法复用代码了

因此我们要重新设计一样



## 封装变化

这一思想是几乎所有设计模式的宗旨

唯一不变的就是变化，变化可以来自外在，也可能来自内驱

设计的原则就是封装变化的部分

**首先要将变化的和不变的分离出来**，对象是封装的基本单位，要把变化的部分变成新的类

在上述例子中，我们需要把那些行为从鸭子类中分离出来



**然后再封装**

如何封装？

根据需求来封装

想想设计原则中的面向抽象编程，之前的设计都是根据具体编程（子类中有具体的行为实现，子类中有具体的接口的实现），因此我们要改变，面对抽象编程

我们将行为抽象成为接口，然后让具体的行为去实现这个接口。这样我们可以复用这些行为的实现，还可以动态的添加这些行为，并且可以通过委托代理的方式让具体的鸭子有这些行为，委托 — 调用非本类的方法，调用其他类的方法

![image](https://s2.ax1x.com/2019/12/22/QxxseO.png)

这就是策略模式



## 类图

![image](https://s2.ax1x.com/2019/12/22/Qxx7Tg.png)



## 分析

策略 strategy，有时又被称为 Policy

定义了一组算法，将它们封装起来，让算法和客户代码独立开



## 应用场景

我们有一组算法，如果采用硬编码的形式将会产生大量的判断，像这种有一大堆if else来判断行为的，我们可以将它们分离出去，形成单独的策略类

![image](https://s2.ax1x.com/2019/12/22/QxzQtH.md.png)

一些类仅仅是行为上有一些区别（例如鸭子的例子），采用继承+覆盖的形式不灵活，无法动态配置，修改起来也麻烦。因此可以考虑采用策略模式，动态的去配置这种行为

对于一个算法来说，我们有一组实现（空间或时间上的权衡），我们可以动态的选择用哪种算法。当我们让算法形成单独的类之后，我们就可以将这些变化封装起来

我们还可以隐藏复杂的数据结构，将数据封装起来，和客户端分离开



## 限制

客户端需要知道所有的策略，需要做出选择

strategy需要设置

使用者就要知道更多细节

这些细节本来只要开发者知道

同时也增加了类的数量



# 状态模式

## 定义

状态模式(State Pattern) :允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。 



## 分析

1. 状态模式描述了对象状态的变化
2. 对象如何在每一种状态下表现出不同的行为

关键是引入了一个抽象类来专门表示对象的状态，这个类我们叫做抽象状态类，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了不同状态的行为，**包括各种状态之间的转换**

即：

**策略模式中策略的转化不需要由具体的策略完成**

**而状态模式中状态的转化要具体的状态来负责**



用抽象类来表示对象的状态而不是用接口：

抽象类 — 可以有默认实现，例如全都实现为抛出异常，然后需要实现的方法就覆盖掉这些默认实现



实现状态转化的两种方法：

1. 由具体的状态负责
2. 由上下文负责

在实现状态切换时，在具体状态类内部需要调用环境类Context的setState()方法进行状态的转换操作

在具体状态类中可以调用到环境类的方法，因此状态类与环境类之间通常还存在关联关系或者依赖关系。通过在状态类中引用环境类的对象来回调环境类的setState()方法实现状态的切换



酒店的例子中，执行一个动作之后的状态是不确定的（下图中，入住之后转化到的状态要根据当前状态来确定），因此只能在具体的状态中执行状态的转化

![image](https://s2.ax1x.com/2019/12/23/lSzKNF.png)



环境类和状态类：

![image](https://s2.ax1x.com/2019/12/23/lpVap6.png)



## 类图

![image](https://s2.ax1x.com/2019/12/23/lSjxgI.png)



## 实例

![image](https://s2.ax1x.com/2019/12/23/lpSKqP.png)

重构之后的代码为：

![image](https://s2.ax1x.com/2019/12/23/lpSQVf.png)

上面代码存在一点问题：

没必要if else，可以写成很多个单独方法

没必要每次都new，可以保存一下，下次再取出来

进一步因为没有成员对象，就可以写成静态方法



![image](https://s2.ax1x.com/2019/12/23/lpVw6O.png)

这个例子中，两个地方需要注意

1. 可以和代理模式联用（论坛三个等级，不同行为，就可以让三个等级的具体行为再委托其他类来执行类似的方法，这样就可以复用）
2. 状态的转化可以在环境类中进行，因为转化规则相对固定；而不像酒店的例子中那样，转化是动态的，只能放在具体的状态中进行

![image](https://s2.ax1x.com/2019/12/23/lpV5ng.png)



![image](https://s2.ax1x.com/2019/12/23/lpeKLF.png)

![image](https://s2.ax1x.com/2019/12/23/lpeJRx.png)



## 优点

封装了转换规则。 

枚举可能的状态，在枚举状态之前需要确定状态种类。 

将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 

允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 

可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 



## 缺点

状态模式的使用必然会增加系统类和对象的个数。

状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。

状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码（可能是其他某些状态类，也可能是环境类），否则无法切换到新增状态;而且修改某个状态类的行为也需修改对应类的源代码。 （新增加状态的源状态是要改变的（转向这个新状态），目标状态不用（新增的状态可以写转向什么状态，和开闭原则是没有关系的））

上面说的开闭原则指的是可切换状态的状态模式，有一种简单状态模式是不破坏开闭原则的：

这种简单状态模式类似于命令模式，封装了某个状态下对应的一系列操作

![image](https://s2.ax1x.com/2019/12/23/lpuJWn.png)

破坏开闭原则的解决思路：将抽象放进代码，细节放进源数据。可以将转化后的状态放到配置文件中，读取配置文件（当然这是一种改进，不属于模式本身，模式本身是带有这个缺点的）



## 应用场景

1. 对象的行为依赖于它的状态(属性)并且可以根 据它的状态改变而改变它的相关行为。 
2. 代码中包含大量与对象状态有关的条件语句。



## 模式扩展

共享状态 

在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象。 



# 状态模式和策略模式对比

比策略模式更进一步，状态模式还封装了对应的行为，不再需要判断具体的命令，而是由状态来负责变化到的下一个状态

即：策略模式中策略的转化不需要由具体的策略完成；而状态模式中状态的转化要具体的状态来负责



# 命令模式

请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。

命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。



## 定义

命令模式(Command Pattern):将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化;对请求排队或者记录请求日志，以及支持可撤销的操作。

参数化：将行为转成数据，实现空间和时间上的跨越

三个应用场景：

1. 封装请求
2. 队列、行为日志
3. 撤销操作

命令模式是一种对象行为型模式

**别名为动作(Action)模式或事务(Transaction)模式**



## 类图

![image](https://s2.ax1x.com/2019/12/23/lpI8AI.png)



## 分析

对命令进行封装，将发出命令的责任和执行命令的责任分割开

请求的一方发出请求，要求执行一个操作;接收的一方收到请求，并执行操作

命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。

**关键在于引入了抽象命令接口**，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联



## 实例

![image](https://s2.ax1x.com/2019/12/23/lpo7Zj.png)

电视机是receiver，它执行真正的操作

遥控器是invoker，它持有许多命令对象

抽象命令类定义一个接口

有三个具体命令类实现了抽象命令接口，内部关联了receiver，并在命令的执行方法中调用了receiver来真正执行动作

客户端只是负责装配

![image](https://s2.ax1x.com/2019/12/23/lpT1Yt.png)



和遥控器那个例子不同，遥控器上的功能都是写死的，这里要求可以动态配置。所以就让invoker有一个set方法，可以动态set进来

![image](https://s2.ax1x.com/2019/12/23/lp7CjS.png)

![image](https://s2.ax1x.com/2019/12/23/lp7J41.png)



![image](https://s2.ax1x.com/2019/12/23/lpHFxK.png)



## 优点

降低系统的耦合度

新的命令可以很容易地加入到系统中

可以比较容易地设计一个命令队列和宏命令(组合命令)

可以方便地实现对请求的Undo和Redo



## 缺点

使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。



## 应用场景

系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 

系统需要在不同的时间指定请求、将请求排队和执行请求。 

系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。

系统需要将一组操作组合在一起，即支持宏命令。 



## 模式扩展

### 撤销

只要在抽象命令加一个undo接口即可

具体的命令类要实现这个接口

invoker调用undo方法即可

![image](https://s2.ax1x.com/2019/12/23/lpHmad.png)



### 宏命令

宏命令又称为组合命令，它是命令模式和组合模式联用的产物

在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法 

实现的方式也很简单，将接口（这时候需要是一个抽象类）加上add方法、remove方法和getCommand方法，然后有具体的宏命令实现，可以将多个命令add进一个command的arraylist，执行的时候依此调用arraylist中的execute

![image](https://s2.ax1x.com/2019/12/23/lpHgo9.png)



# 观察者模式

建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应



## 定义

观察者模式(Observer Pattern):定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。

观察者模式又叫做发布-订阅(Publish/Subscribe)模式、模型-视图
(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。

观察者模式是一种对象行为型模式。



## 类图

![image](https://s2.ax1x.com/2019/12/23/lpbspt.png)

为什么观察者是接口而不是抽象类

声明成接口的都是和应用功能正交的功能，而且观察者中的update都是需要各个观察者自己实现的，基本上没有什么公共部分



## 分析

被观察者对观察者通知之后，观察者有两种方法可以得到被观察者的信息：

1. 一种是上图中的，观察者留有一个被观察者的引用，通过其getState方法可以得到状态信息。这种适用于状态信息比较大的情况
2. 另外一种是在update的时候就直接传参。这一种适合数据量比较小的情况



## 实例

![image](https://s2.ax1x.com/2019/12/23/lpqq2t.png)

![image](https://s2.ax1x.com/2019/12/23/lpLAMV.png)



![image](https://s2.ax1x.com/2019/12/23/lpOBtJ.png)

![image](https://s2.ax1x.com/2019/12/23/lpOR0O.png)



## 优点

观察者模式可以实现表示层和数据逻辑层的分离 

观察者模式在观察目标和观察者之间建立一个抽象的耦合 

观察者模式支持广播通信

观察者模式符合“开闭原则”的要求 



## 缺点

如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 

如果在观察者和观察目标之间有循环依赖的话，观察目标会触 发它们之间进行循环调用，可能导致系统崩溃。 （尽量不要实现间接观察，因为有可能会造成循环通信）

观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 



## 应用场景

一个抽象模型有两个方面，其中一个方面依赖于另一个方面。 将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。

一个对象的改变将导致其他一个或多个对象也发生改变，而不 知道具体有多少对象将发生改变

一个对象必须通知其他对象，而并不知道这些对象是谁。 

需要在系统中创建一个触发链，A对象的行为将影响B对象，B 对象的行为将影响C对象......，可以使用观察者模式创建一种链式触发机制



## Java中的观察者模式

![image](https://s2.ax1x.com/2019/12/23/lpO4tH.png)

图上标注的意思是，update的第一个参数是Observable，用来让观察者识别当前到底是哪个被观察者发来的更新信息，以便进行下一步处理

![image](https://s2.ax1x.com/2019/12/23/lpOxhj.png)

notify有两个版本，有参数的是push模式，将所有信息都push过去，无参数的是pull模式，传递给update的第二个参数是null，观察者保留被观察者的引用，然后主动去pull信息。对应的是两种得到被观察者信息的方式

被观察者很难控制更新粒度：这就是setChanged方法的作用。对于不需要发生通知的变化，我们就不要setChanged，那么就不会更新（notify之前会检查是否setChanged）。一系列的变化之后，可以用 `clearChanged()`撤消更新



## 模式扩展

观察者列表，加一个参数，分辨到底是哪一类事件，只通知那一类事件的观察者



![image](https://s2.ax1x.com/2019/12/23/lpj6eK.png)



外部观察者模式：委托外部对象来管理观察者和被观察者，可以解决java类库是父类的问题，还可以统一管理复杂的观察关系（java内置的不行，因为这样需要二维数组，来维护每一个被观察者的观察者列表）（例如我们就可以检测是否有环），缺点就是有了中心的节点，性能可能会成为瓶颈



# 中介者模式

用于解决通信问题



## 定义

中介者模式(Mediator Pattern)定义:用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

中介者模式又称为调停者模式，它是一种对象行为型模式。



## 类图

![](https://s2.ax1x.com/2019/12/24/lPBDiQ.png)



## 分析

体现了迪米特法则，没有了复杂的依赖关系，都直接和中介者交流

外部观察者其实也体现了中介者模式，维护一个表，由外部观察者来通知信息

减少子类生成：不用像分身一样存在于很多个不同的关系网络中

思想：转移复杂度

在结构和行为两方面承担职责



## 实例

![](https://s2.ax1x.com/2019/12/24/lCWbi6.png)

![image](https://s2.ax1x.com/2019/12/24/lCW5L9.png)



![](https://s2.ax1x.com/2019/12/24/lCfuoq.png)



## 优点

简化了对象之间的交互。

将各同事解耦。

减少子类生成。

可以简化各同事类的设计和实现。



## 缺点

在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。



## 应用场景

系统中对象之间存在复杂的引用关系

一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象

想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的中介者类



# 中介者模式与迪米特法则

在中介者模式中，通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，中介者模式就是迪米特法则的一个典型应用。



# 模板方法模式

模板方法模式是基于继承的代码复用基本技术



## 定义

模板方法模式(Template Method Pattern):定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法是一种类行为型模式。

c++中的非虚接口就是模版方法（父类中的非虚函数是复用部分，子类中覆盖的虚函数是自定义的）

模板方法模式导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合“开闭原则”



## 类图

![](https://s2.ax1x.com/2019/12/24/lC4PxS.png)



## 分析

实现这些具体逻辑步骤的方法称为基本方法(Primitive Method)，而将这些基本法方法汇总起来的方法称为模板方法(Template Method)，模板方法模式的名字从此而来。

模板方法:一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。

基本方法:基本方法是实现算法各个步骤的方法，是模板方法的组成部分。

基本方法有三种：

1.  抽象方法
2. 具体方法
3. 钩子方法

![](https://s2.ax1x.com/2019/12/24/lC4JaR.png)

钩子方法有两种：

1. 一种是空方法，嵌入在算法的步骤中（例如开头或者结尾，用户可以添加实现，也可以不添加）
2. 一种是返回bool值的方法，可以控制是否执行某个步骤

![](https://s2.ax1x.com/2019/12/24/lCoqJI.png)

![](https://s2.ax1x.com/2019/12/24/lC4RRf.png)



## 实例

![](https://s2.ax1x.com/2019/12/24/lC47on.png)

![](https://s2.ax1x.com/2019/12/24/lC4jQU.png)



![](https://s2.ax1x.com/2019/12/24/lC5EQO.png)

![](https://s2.ax1x.com/2019/12/24/lC5VyD.png)





![](https://s2.ax1x.com/2019/12/24/lCIPBQ.png)



![](https://s2.ax1x.com/2019/12/24/lCIEhq.png)



## 优点缺点

每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，但是更加符合“单一职责原则”，使得类的内聚性得以提高。



## 应用场景

各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复

对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现

控制子类的扩展，确保父类控制处理流程的逻辑顺序





# 鼓励继承的模板方法&&好莱坞原则

模板方法模式鼓励我们恰当使用继承，此模式可以用来改写一些拥有相同功能的相关类，将可复用的一般性的行为代码移到父类里面，而将特殊化的行为代码移到子类里面。这也进一步说明，虽然继承复用存在一些问题，但是在某些情况下还是可以给开发人员带来方便，模板方法模式就是体现继承优势的模式之一。



![](https://s2.ax1x.com/2019/12/24/lCoFKO.png)



# 策略模式vs命令模式vs模板模式

参考

https://jayfeng.com/2016/04/10/理解设计模式之命令模式、策略模式、模板方法模式/



## 关联

策略模式是命令模式的一个特例，而策略模式又和模板方法模式都是算法替换的实现，只不过替换的方式不同



## 区别

命令模式强调的是对已有行为的一个封装，而策略模式强调的是一系列未知算法的替换，这些算法需要独立的实现

模板方法的重点是定义这些算法的结构，让子类去替换某些步骤；而策略模式是替换掉一整个算法实现（一般来说就是一个方法，更换策略相当于将整个算法实现替换掉）

