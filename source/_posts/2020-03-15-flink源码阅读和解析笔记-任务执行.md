---
title: flink源码阅读和解析笔记--任务执行
date: 2020-03-15 13:42:38
categories: [并行计算]
tags: [flink]
cover_img: https://s1.ax1x.com/2020/08/25/dcRZnA.jpg
feature_img: https://s1.ax1x.com/2020/08/25/dcRZnA.jpg
description:
keywords:
---

# Flink任务运行流程

## StreamTask

该类是所有流计算任务的基类，一个任务是部署在`TaskManager`上并且由它运行的一个本地处理单元。另外，有关checkpoint的实现也在这里。
每一个任务运行着一个或多个`StreamOperator`，如下图所示

![image](https://s1.ax1x.com/2020/03/15/83kiDK.png)

这些`StreamOperator`会形成operator chain，形成条件包括上下游算子的并行度等。
代码中将单个`StreamOperator`和它们所形成的chain统一表示，即统一采用`StreamTask`。对于chain来说，`StreamTask`包含了chain的"head"，此时`StreamTask`的类型就是这个"head" operator的类型。

```java
public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>
		extends AbstractInvokable
		implements AsyncExceptionHandler {
    ...
	/** the head operator that consumes the input streams of this task. */
	protected OP headOperator;
    ...
}
```

一个chain里面的所有算子在同一个线程中同步执行，因此它们在同一个stream partition上。
一个任务处理一个流的建立（由head operator读入），和流的产生（chain中最后一个operator的输出），注意一个chain可能有多个流出（end）。

## 生命周期

一个task的生命周期如下：

```shell script
 *  -- setInitialState -> provides state of all operators in the chain
 *
 *  -- invoke()
 *        |
 *        +----> Create basic utils (config, etc) and load the chain of operators
 *        +----> operators.setup()
 *        +----> task specific init()
 *        +----> initialize-operator-states()
 *        +----> open-operators()
 *        +----> run()
 *        +----> close-operators()
 *        +----> dispose-operators()
 *        +----> common cleanup
 *        +----> task specific cleanup()
```

注意：在一个chain里面，`StreamOperator`的方法是不能并发调用的，内部实现是通过一个锁。

```java
public final void invoke() throws Exception {
    try {
        beforeInvoke();

        // final check to exit early before starting to run
        if (canceled) {
            throw new CancelTaskException();
        }

        // let the task do its work
        runMailboxLoop();

        // if this left the run() method cleanly despite the fact that this was canceled,
        // make sure the "clean shutdown" is not attempted
        if (canceled) {
            throw new CancelTaskException();
        }

        afterInvoke();
    }
    finally {
        cleanUpInvoke();
    }
}
```

在`beforeInvoke`中会做一些初始化工作，包括提取出所有的operator等。
在`runMailboxLoop`中调用task运行
在`afterInvoke`中结束

任务的运行使用了`mailbox-based execution model`，这个模型做了很多封装。
在invoke中会启动这个模型的处理循环吗，之后各个行为都被封装在Action中被调用执行。invoke的调用链：

```shell script
invoke() -> runMailboxLoop() -> mailboxProcessor.runMailboxLoop()
```

最后交由`MailboxProcessor`来循环处理各个action，因此只要关注任务的action即可把握任务的运行情况。

## 执行任务

这个是任务运行的核心，即这里会产生action交由`MailboxProcessor`执行。
`processInput`方法处理输入，是task的默认action，在输入上处理一个事件（event）。该方法又会调用`StreamInputProcessor`来处理输入，返回一个处理后的状态。
判断当前状态来决定是否要继续这个action：如果当前有更多输入，且输出（`recordWriter`）就绪，那么直接返回（因为还有更多的输入，因此不结束action）；如果输入已经结束，标记一下action为结束状态，直接返回；否则将当前的action暂停，直到有输入且输出（`recordWriter`）就绪的时候恢复执行（异步等待）

```java
protected void processInput(MailboxDefaultAction.Controller controller) throws Exception {
    InputStatus status = inputProcessor.processInput();
    if (status == InputStatus.MORE_AVAILABLE && recordWriter.isAvailable()) {
        return;
    }
    if (status == InputStatus.END_OF_INPUT) {
        controller.allActionsCompleted();
        return;
    }
    CompletableFuture<?> jointFuture = getInputOutputJointFuture(status);
    MailboxDefaultAction.Suspension suspendedDefaultAction = controller.suspendDefaultAction();
    jointFuture.thenRun(suspendedDefaultAction::resume);
}
```

### StreamInputProcessor

这个是真正执行读取上游输入并且处理任务的接口，该接口只有一个方法：

```java
public interface StreamInputProcessor extends AvailabilityProvider, Closeable {
	/**
	 * @return input status to estimate whether more records can be processed immediately or not.
	 * If there are no more records available at the moment and the caller should check finished
	 * state and/or {@link #getAvailableFuture()}.
	 */
	InputStatus processInput() throws Exception;
}
```

该方法处理完输入之后，会返回状态，是一个枚举类型：

```java
public enum InputStatus {

	/**
	 * Indicator that more data is available and the input can be called immediately again
	 * to emit more data.
	 */
	MORE_AVAILABLE,

	/**
	 * Indicator that no data is currently available, but more data will be available in the
	 * future again.
	 */
	NOTHING_AVAILABLE,

	/**
	 * Indicator that the input has reached the end of data.
	 */
	END_OF_INPUT
}
```

`StreamInputProcessor`有三个实现类，分别是：

```java
StreamOneInputProcessor
StreamTwoInputProcessor
StreamMultipleInputProcessor
```

这三个实现类都有一个成员变量：

```java
private final OperatorChain<?, ?> operatorChain;
```

配套这个成员变量的还有两组成员变量，配套的意思是如果是`StreamTwoInputProcessor`，那么下面就有两组：

```java
private final StreamTaskInput<IN> input;
private final DataOutput<IN> output;
```

这里的input负责读，读到ouput中，调用ouput的方法，例如`emitRecord`，这个方法的实现类一般是某个`StreamTask`子类的实现类，在这里会开始处理这个输入数据，例如`OneInputStreamTask`的内部类中的一个实现：

```java
@Override
public void emitRecord(StreamRecord<IN> record) throws Exception {
    numRecordsIn.inc();
    operator.setKeyContextElement1(record);
    operator.processElement(record);
}
```

下面具体看一下整个调用链

#### StreamOneInputProcessor

核心的方法为：

```java
public InputStatus processInput() throws Exception {
    InputStatus status = input.emitNext(output);

    if (status == InputStatus.END_OF_INPUT) {
        operatorChain.endHeadOperatorInput(1);
    }

    return status;
}
```

`StreamInputProcessor`的三个实现类都有类似的语句，可以看到`StreamTaskInput`类型的`emitNext`方法返回的`InputStatus`即为`processInput`判断的状态，即只包含三种输入流的状态。
在这个方法中，最核心的就是下面这条语句：

```java
InputStatus status = input.emitNext(output);
```

这里的input和output分别是：

```java
private final StreamTaskInput<IN> input;
private final DataOutput<IN> output;
```

`StreamTaskInput`有`emitNext`接口方法，两个实现，其中一个还是TODO状态，`StreamTaskNetworkInput`已有实现。
首先，从deserializer中获得一个反序列化之后的结果

```java
@Override
public InputStatus emitNext(DataOutput<T> output) throws Exception {

    while (true) {
        // get the stream element from the deserializer
        if (currentRecordDeserializer != null) {
            DeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate);
            if (result.isBufferConsumed()) {
                currentRecordDeserializer.getCurrentBuffer().recycleBuffer();
                currentRecordDeserializer = null;
            }

            if (result.isFullRecord()) {
                processElement(deserializationDelegate.getInstance(), output);
                return InputStatus.MORE_AVAILABLE;
            }
        }

        Optional<BufferOrEvent> bufferOrEvent = checkpointedInputGate.pollNext();
        if (bufferOrEvent.isPresent()) {
            processBufferOrEvent(bufferOrEvent.get());
        } else {
            if (checkpointedInputGate.isFinished()) {
                checkState(checkpointedInputGate.getAvailableFuture().isDone(), "Finished BarrierHandler should be available");
                if (!checkpointedInputGate.isEmpty()) {
                    throw new IllegalStateException("Trailing data in checkpoint barrier handler.");
                }
                return InputStatus.END_OF_INPUT;
            }
            return InputStatus.NOTHING_AVAILABLE;
        }
    }
}
```

再将这个结果放到`DataOutput`中，根据流中元素的类型，调用不同的方法，例如，如果是一条记录，那么调用其`emitRecord`方法：

```java
private void processElement(StreamElement recordOrMark, DataOutput<T> output) throws Exception {
    if (recordOrMark.isRecord()){
        output.emitRecord(recordOrMark.asRecord());
    } else if (recordOrMark.isWatermark()) {
        statusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), lastChannel);
    } else if (recordOrMark.isLatencyMarker()) {
        output.emitLatencyMarker(recordOrMark.asLatencyMarker());
    } else if (recordOrMark.isStreamStatus()) {
        statusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), lastChannel);
    } else {
        throw new UnsupportedOperationException("Unknown type of StreamElement");
    }
}
```

在这里，output的实现类就会将这一条输入记录进行处理，例如调用各种operator等。

```java
@Override
public void emitRecord(StreamRecord<IN> record) throws Exception {
    numRecordsIn.inc();
    operator.setKeyContextElement1(record);
    operator.processElement(record);
}
```

#### OperatorChain

另外说一下chain operator是怎么处理元素的，上面说到只要实现`DataOutput`接口就可以处理输入，但是我们可以看到实现`DataOutput`接口的类其实很少，比如`OperatorChain`就没有实现这个接口，那么是如何实现处理的呢？
看到它的内部有一个实现类：

```java
static class ChainingOutput<T> implements WatermarkGaugeExposingOutput<StreamRecord<T>> {
    ...
    @Override
    public void collect(StreamRecord<T> record) {
        if (this.outputTag != null) {
            // we are not responsible for emitting to the main output.
            return;
        }
        pushToOperator(record);
    }

    protected <X> void pushToOperator(StreamRecord<X> record) {
        try {
            // we know that the given outputTag matches our OutputTag so the record
            // must be of the type that our operator expects.
            @SuppressWarnings("unchecked")
            StreamRecord<T> castRecord = (StreamRecord<T>) record;

            numRecordsIn.inc();
            operator.setKeyContextElement1(castRecord);
            operator.processElement(castRecord);
        }
        catch (Exception e) {
            throw new ExceptionInChainedOperatorException(e);
        }
    }

    @Override
    public void emitWatermark(Watermark mark) { ...}

    @Override
    public void emitLatencyMarker(LatencyMarker latencyMarker) { ... }
    ...
}
```

在这里实现了operator对数据的处理，而在这个内部类外面，有个方法可以返回一组Output：

```java
private <IN, OUT> WatermarkGaugeExposingOutput<StreamRecord<IN>> createChainedOperator(...){...}
```

这个`WatermarkGaugeExposingOutput`继承于`Output`接口（注意不是`DataOutput`接口）,该接口定义了几个方法

```java
public interface Output<T> extends Collector<T> {
	void emitWatermark(Watermark mark);

	<X> void collect(OutputTag<X> outputTag, StreamRecord<X> record);

	void emitLatencyMarker(LatencyMarker latencyMarker);
}
```

在`Operator`接口的各个实现中，很多都有`Output`类型的的成员变量或是其内部实现类，这些类通过层层调用，达到处理元素或者其他消息的目的。即`Output`一般是作为实现了`DataOutput`接口的成员变量而存在的，通过调用`DataOutput`，用`Output`来处理，推测可能是因为版本的原因，`Output`很早的版本就已经存在了（我看了1.4版本就已经有了），但是`DataOutput`是之后的版本才加入的，引入的目的就是重构读取输入并且处理的这个框架。它们之间的调用情况可以看一个具体的类实现：

```java
public class SourceReaderStreamTask<T> extends StreamTask<T, SourceReaderOperator<T>> {
  /**
	 * Implementation of {@link DataOutput} that wraps a specific {@link Output} to emit
	 * stream elements for {@link SourceReaderOperator}.
	 */
	private static class StreamTaskSourceOutput<T> extends AbstractDataOutput<T> {

		private final Output<StreamRecord<T>> output;

		StreamTaskSourceOutput(
				Output<StreamRecord<T>> output,
				StreamStatusMaintainer streamStatusMaintainer) {
			super(streamStatusMaintainer);

			this.output = checkNotNull(output);
		}

		@Override
		public void emitRecord(StreamRecord<T> streamRecord) {
			output.collect(streamRecord);
		}

		@Override
		public void emitLatencyMarker(LatencyMarker latencyMarker) {
			output.emitLatencyMarker(latencyMarker);
		}

		@Override
		public void emitWatermark(Watermark watermark) {
			output.emitWatermark(watermark);
		}
	}
}
```

这里output的collect会进一步调用到operator的`processElement`（可以看到`OperatorChain`的实现就是这样）

可以理解成整个读取输入并处理的过程就是从input读取，给output处理，中间通过几个接口的委托，最后会委托到具体算子来处理



### 输出结果

在`StreamTask`中有一个成员变量：

```java
private final RecordWriterDelegate<SerializationDelegate<StreamRecord<OUT>>> recordWriter;
```

改成员变量负责写入结果，其内部又代理给了`RecordWriter`，这个类里面定义了各种类型的`emit`方法，在这里面写记录



#### numRecordsIn

这个`Counter`类型的变量封装了处理的记录数，基本上，每次operator处理一条记录，都会累加以`numRecordsIn`为变量名的`Counter`类型的变量，例如在各种的Output里面等。

