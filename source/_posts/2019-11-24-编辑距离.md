---
title: 编辑距离
date: 2019-11-24 10:09:57
categories: [算法]
tags: [刷题,动态规划]
cover_img:
feature_img:
description:
keywords:
---

# 题目

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/edit-distance



# 思路

暴力搜索很难表示三种情况

考虑利用动态规划

长的字符串的编辑距离依赖于短的字符串的编辑距离

利用一个二维数组DP\[i][j]，表示word1从0开始长度为i的子串和word2从0开始长度为j的子串的编辑距离

如何求当前位置DP\[i][j]？对于这一题，只要考虑一个字符的改变（三个操作都是改变一个字符）即可，因此要根据DP\[i-1][j-1]以及DP\[i][j-1]和DP\[i-1][j]来求

根据两个字符串最后一个字符相同与否，可以分为两种情况

![image](https://s2.ax1x.com/2019/11/24/MLsec8.png)

容易知道初始情况是两个维度中有一个是0的情况，其他情况都可以递归到这里

迭代计算的方向是两个维度都从1开始，往上慢慢加



# 题解

```c++
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    int minDistance(string word1, string word2) {
        int dp[1000][1000];
        for(int i = 0; i <= word2.length(); i++){
            dp[0][i] = i;
        }
        for(int i = 0; i <= word1.length(); i++){
            dp[i][0] = i;
        }
        for(int i = 1; i <= word1.length(); i++){
            for(int j = 1; j <= word2.length(); j++){
                if(word1[i-1] == word2[j-1]){
                    dp[i][j] = min(min(dp[i-1][j-1], dp[i][j-1]+1), dp[i-1][j]+1);
                } else {
                    dp[i][j] = min(min(dp[i-1][j-1]+1, dp[i][j-1]+1), dp[i-1][j]+1);
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
};
```

