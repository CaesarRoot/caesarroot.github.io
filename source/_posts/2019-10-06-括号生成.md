---
title: 括号生成
date: 2019-10-06 16:44:32
categories: [算法]
tags: [刷题, 暴搜]
cover_img:
feature_img:
description:
keywords:
---

# 题目

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

例如，给出 n = 3，生成结果为：

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/generate-parentheses



# 思路

DFS，每次考虑一个位置放左括号还是右括号。为了防止垃圾情况过多，预先剪枝，即只有合理的时候才会继续，那么只要是能到最后（所有括号都被用完），就可以得到一个解。



具体来说就是：

用一个栈（一个整数就够了）来维护当前栈中的左括号数量，来实时判断是否可以放右括号；还需要左右括号的数量；还需要当前的字符串



对于每一个位置，左括号可以随便放，右括号要考虑一下，如果栈中有左括号，那么可以放，否则不行。这样预先剪枝，到最后如果左右括号都用完，自然就形成一个解，而不用最后判断。



# 题解

```c++
#include <iostream>
using namespace std;

class Solution {
private:
    vector<string> ans;    
public:
    vector<string> generateParenthesis(int n) {
      int left = n, right = n;
      int stack = 0;
      string s = "";
      DFS(stack, left, right, s);
      return ans;
    }

    /*
    stack表示栈中左括号的数量
    left表示剩余的左括号数量
    right表示剩余的右括号数量
    s表示当前的字符串情况
     */    
    void DFS(int stack, int left, int right, string s){
      if(left == right && left == 0){  // 括号全都用上了表示得到一个结果
        ans.push_back(s);
        return;
      }
      if(left != 0){  // 左括号随便放
        DFS(stack+1, left-1, right, s+"(");
      }
      if(stack != 0 && right != 0){  // 右括号有条件地放
        DFS(stack-1, left, right-1, s+")");
      }
      return ;
    }
};
```

