---
title: 设计模式-结构型模式
date: 2019-12-24 16:59:55
categories: 软件设计
tags: 软件设计
cover_img:
feature_img:
description:
keywords:
---

# 适配器模式

当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作



## 定义

适配器模式(Adapter Pattern) :将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。

适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。



## 类图

分为两种

![](https://s2.ax1x.com/2019/12/24/lPiuJx.png)

![](https://s2.ax1x.com/2019/12/24/lPiQSK.png)

类适配器中Target是接口，因为Adapter继承Adaptee，单继承

![](https://s2.ax1x.com/2019/12/24/lPFmng.png)

类适配器是通过继承的方式调用被适配的接口

![](https://s2.ax1x.com/2019/12/24/lPFMAs.png)

而对象适配器则是通过关联一个被适配者的对象来实现的

![](https://s2.ax1x.com/2019/12/24/lPkCKU.png)



## 实例

![](https://s2.ax1x.com/2019/12/24/lPkPrF.png)

第三方模块是被适配者，原来的模块是目标类target，采用对象适配器模式类图如下

![](https://s2.ax1x.com/2019/12/24/lPkXLD.png)



![](https://s2.ax1x.com/2019/12/24/lPVdsK.png)

![](https://s2.ax1x.com/2019/12/24/lPVcRI.png)



## 优点

将目标类和适配者类解耦

增加了类的透明性和复用性

灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 





## 类适配器vs对象适配器

由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 

对于类适配器来说，Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类（因为有的方法没有实现，因此不能让它实例化）， 不能为具体类，其使用有一定的局限性，不能将一个适 配者类和它的子类都适配到目标接口。 

一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。

与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。



具体选择哪一种，可以稍微写一下代码实现，从实现角度来考虑。

类适配器用的多：猜测是因为有的时候适配需要修改一些父类的实现才能实现适配。

类适配器一般是一对一的情况下使用。



## 应用场景

![](https://s2.ax1x.com/2019/12/24/lPEtu8.png)

总的来说有两条

1. 修改接口。定义一个抽象，这个抽象是客户想要的接口，然后有一个实现，实现中调用另外的符合需求的接口
2. 将两个类扭在一起



## 模式扩展

### 默认适配器

当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式

https://blog.csdn.net/IO_Field/article/details/52791975

**本质就是绕过接口必须实现**这一规则



### 双向适配器

在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器。

分析：只能用对象适配器模式，且两边都是，因此是一个对称的结构。且要有专门的方法set进适配者。在两个不同的方法中封装对于实现方法的调用

![](https://s2.ax1x.com/2019/12/24/lPZLhd.png)



# 组合模式

树形结构，递归调用，一致处理叶子节点和非叶子节点



## 组合模式

组合模式(Composite Pattern):组合多个对象形成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象(即叶子对象)和组合对象(即容器对象)的使用具有一致性。

组合模式又可以称为“整体-部分”(Part-Whole)模式，属于对象的结构模式，它将对象组织到树结构中，可以用来描述整体与部分的关系。



## 类图

![](https://s2.ax1x.com/2019/12/24/lPutuq.png)

由于要叶子和非叶子要相同对待，那么就要继承自统一的接口。其中如果是非叶子节点，那么还要聚合这个接口

对于叶子节点来说，有三个方法都是不能有实现的，因此：

![](https://s2.ax1x.com/2019/12/24/lPKBeP.png)

**透明性往往是要牺牲安全性**

**这里的叶子节点的三个方法都是要抛出异常的，不是可以调用的方法**



同时注意非叶子节点中的operation代码，需要遍历列表调用：

![](https://s2.ax1x.com/2019/12/24/lPKgzj.png)

**因为组合是递归的，是一次性调用下去的，是内部遍历**

**如果需要迭代器，那么是一个外部遍历，要额外维护一个栈或者队列来记录当前访问到哪一个元素**



## 实例

![](https://s2.ax1x.com/2019/12/24/lPK4e0.png)

![](https://s2.ax1x.com/2019/12/24/lPMY7V.png)

![](https://s2.ax1x.com/2019/12/24/lPMY7V.png)



![](https://s2.ax1x.com/2019/12/24/lPM5jA.png)

![](https://s2.ax1x.com/2019/12/24/lPQ9H0.png)



![](https://s2.ax1x.com/2019/12/24/lPQtKA.png)



## 优点

可以清楚地定义分层次的复杂对象 

客户端可以一致的使用组合结构或其中单个对象 

定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可 以形成复杂的树形结构

更容易在组合体内加入对象构件（例如上面的例子中新增一个新的文件类型）



## 缺点

使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联

增加新构件时可能会产生一些问题，很难对容器中的构件类型进行限制。 



## 应用场景

需要表示一个对象整体或部分层次

一致对待整体和部分

客户端可以针对抽象构件编程，无须关心对象层次结构的细节

对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们



## 模式扩展

### 透明组合模式和安全组合模式

所谓的透明，是对于客户端来说透明，及叶子节点和非叶子节点没有任何区别，这样接口固定，但是必然导致叶子节点有多余的方法，这样就不安全

所谓安全，及叶子节点只有operation方法，而非叶子节点有增加删除的方法，接口只有operation，这样会保证不会进行非法操作，但是要判断是叶子节点还是非叶子节点，这样就不透明了

![](https://s2.ax1x.com/2019/12/24/lPQbrR.png)

![](https://s2.ax1x.com/2019/12/24/lPlnzQ.png)

即：

透明模式：对待叶子节点和非叶子节点一样，所有的接口方法都可以调用

安全模式：调用前要先判断一下是什么类型再调用其方法

**透明性往往是要牺牲安全性**

**透明模式中叶子节点的三个方法都是要抛出异常的，不是可以调用的方法**



## 桥接模式

两个变化维度，例如形状和颜色，需要进行组合，如果采用继承，那么产生的类的数量是乘积关系；而如果采用组合，那么类的数量是相加的关系

继承：静态的强耦合

组合：动态的弱耦合



## 定义

桥接模式(Bridge Pattern):将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式。

又称为柄体(Handle and Body)模式或接口(Interface)模式。



## 类图

![](https://s2.ax1x.com/2019/12/24/lP3qqs.png)

![](https://s2.ax1x.com/2019/12/24/lPYYJx.png)



## 分析

![](https://s2.ax1x.com/2019/12/24/lP8eJK.png)



## 实例

![](https://s2.ax1x.com/2019/12/24/lPYrTA.png)

![](https://s2.ax1x.com/2019/12/24/lPYTkn.png)



![](https://s2.ax1x.com/2019/12/24/lPYvm4.png)

![](https://s2.ax1x.com/2019/12/24/lPYz79.png)



![](https://s2.ax1x.com/2019/12/24/lPNoR0.png)

![](https://s2.ax1x.com/2019/12/24/lPNHMT.png)

![](https://s2.ax1x.com/2019/12/24/lPU8oj.png)



## 优点

分离抽象接口及其实现部分

桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则(即一个类只有一个变化的原因)，复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法

![](https://s2.ax1x.com/2019/12/24/lPtw90.png)

提高了系统的可扩充性

实现细节对客户透明，可以对用户隐藏实现细节



## 缺点

增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程

桥接模式要求正确识别出系统中两个独立变化的维度， 因此其使用范围具有一定的局限性 



## 应用场景

总结来说有两个方面：

1. 两个变化维度
2. 抽象和实现分离



需要在构件的抽象化角色和具体化角色之间增加更多的灵活性， 避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系 

抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响 

一个类存在两个独立变化的维度 

不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系 统 



## 模式联用

![](https://s2.ax1x.com/2019/12/24/lPae74.png)

![](https://s2.ax1x.com/2019/12/24/lPa3jK.png)



# 桥接模式vs命令模式

参考：https://www.iteye.com/blog/c610367182-1965668

不仅Implementor具有变化（ConcreteImplementor），而且Abstraction也可以发生变化（RefinedAbstraction），而且两者的变化是完全独立的，RefinedAbstraction与ConcreateImplementor之间松散耦合，它们仅仅通过Abstraction与Implementor之间的关系联系起来。强调Implementor接口仅提供基本操作，而Abstraction则基于这些基本操作定义更高层次的操作

并不考虑Context的变化，只有算法的可替代性。强调Strategy抽象接口的提供的是一种算法，一般是无状态、无数据的，Context简单调用这些算法完成其操作



# 装饰者模式

对客户透明的方式动态地给一个对象附加上更多的责任

在不需要创造更多子类的情况下，将对象的功能加以扩展



## 定义

装饰模式(Decorator Pattern) :动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。

其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。



## 类图

![](https://s2.ax1x.com/2019/12/24/lPa2Nj.png)

为什么正常的component和decorator不一样？

从设计上来说，装饰者只是增加一个小职责，因此和正常的component就是不一样

从调用上来说，层层调用，最内层必须要终止，因此也要区分开来



是否破坏了Liskov替换原则

concreteDecoratorB，因addedBehavior是public的，因此是有可能破坏Liskov

但是如果只是在operation里面调用的话则不会，例如concreteDecoratorA



在抽象的Decorator中调用component的方法

![](https://s2.ax1x.com/2019/12/24/lPd3Ps.png)

具体的Decorator中调用新增的方法

![](https://s2.ax1x.com/2019/12/24/lPdJx0.png)



## 实例

![](https://s2.ax1x.com/2019/12/24/lPdhIH.png)

![](https://s2.ax1x.com/2019/12/24/lPdHQP.png)

半透明

如果只是使用move，那么就是透明的

如果要使用robot里面新加的方法，就要了解当前的类型，因此是不透明的

![](https://s2.ax1x.com/2019/12/24/lPdzJs.png)

![](https://s2.ax1x.com/2019/12/24/lPwZFJ.png)



![](https://s2.ax1x.com/2019/12/24/lPwI7F.png)

![](https://s2.ax1x.com/2019/12/24/lPwHh9.png)



## 优点

装饰模式可以提供比继承更多的灵活性

通过一种动态的方式来扩展一个对象的功能 

通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合 

具体构件类与具体装饰类可以独立变化 



## 缺点

装饰方法只能在正常对象前或者后调用，因此只能改变前置或者后置，而不能改变中间实现过程

小对象太多，可以和工厂方法连用，用来创建小对象

装饰模式比继承更加易于出错，排错也很困难，对于多次装饰 的对象，调试时寻找错误可能需要逐级排查，较为烦琐 



## 模式扩展

一个装饰类的接口必须与被装饰类的接口保持相同（实现透明性）

不要把太多的逻辑和状态放在具体构件类中 ，而是通过装饰者来进行扩展

如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类 

![](https://s2.ax1x.com/2019/12/24/lPwXX6.png)



## 透明性与接口扩充

如果想要扩充接口，就无法实现透明，如果要透明，就无法扩充接口

![](https://s2.ax1x.com/2019/12/24/lPwx0O.png)

![](https://s2.ax1x.com/2019/12/24/lP0Vnf.png)



## 应用场景

以动态、透明的方式给单个对象添加职责

当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时，例如继承会使得子类太多，或是final不能继承





# 外观模式

## 定义

外观模式(Facade Pattern):外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
外观模式又称为门面模式，它是一种对象结构型模式



## 类图

![](https://s2.ax1x.com/2019/12/24/lP0uNQ.png)

![](https://s2.ax1x.com/2019/12/24/lP0XCj.png)



## 分析

![](https://s2.ax1x.com/2019/12/24/lP06HO.png)

外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能

**外观模式并不提供抽象**

![](https://s2.ax1x.com/2019/12/24/lPBTzR.png)



## 实例

![](https://s2.ax1x.com/2019/12/24/lP0v2n.png)

![](https://s2.ax1x.com/2019/12/24/lPB9bT.png)

![](https://s2.ax1x.com/2019/12/24/lPBiaF.png)

![](https://s2.ax1x.com/2019/12/24/lPBNsP.png)



## 优点

对客户屏蔽子系统组件

实现了子系统与客户之间的松耦合关系

降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程

只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类



## 缺点

不能很好地限制客户使用子系统类

在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了"开闭原则"



## 应用场景

当要为一个复杂子系统提供一个简单接口时可以使用外观模式

客户程序与多个子系统之间存在很大的依赖性

在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度



## 模式扩展

![](https://s2.ax1x.com/2019/12/24/lPBfdU.png)

不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现

### 抽象外观

![](https://s2.ax1x.com/2019/12/24/lPBbsx.png)

![](https://s2.ax1x.com/2019/12/24/lPDuSs.png)



# 享元模式

享元模式通过共享技术实现相同或相似对象的重用 



## 定义

享元模式(Flyweight Pattern):运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为**轻量级模式**，它是一种
对象结构型模式。



## 分析

在享元模式中可以共享的相同内容称为内部状态(Intrinsic State)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的

在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象



## 类图

![](https://s2.ax1x.com/2019/12/24/lPDBm6.png)

注意这里内部状态是共享的，右下角的意思是：不共享的话内部和外部就不分了，都是私有成员

根据代码可以看出来：

享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象

享元工厂是一个简单工厂

![](https://s2.ax1x.com/2019/12/24/lPDfXt.png)



## 内部状态vs外部状态

![](https://s2.ax1x.com/2019/12/24/lPDTAS.png)

需要特别强调的是：外部状态 — 客户端保存，比如颜色的前景和背景都是保存在客户端的。只有内部状态是成员属性

![](https://s2.ax1x.com/2019/12/24/lPD7tg.png)



## 实例

![](https://s2.ax1x.com/2019/12/24/lPDxBV.png)

![](https://s2.ax1x.com/2019/12/24/lPDz7T.png)



![](https://s2.ax1x.com/2019/12/24/lPri9J.png)

![](https://s2.ax1x.com/2019/12/24/lPrAj1.png)



![](https://s2.ax1x.com/2019/12/24/lPrQ9H.png)

![](https://s2.ax1x.com/2019/12/24/lPrUUS.png)



## 优点

1. 共享
2. 减少数量



## 缺点

1. 复杂，需要分离外部状态和内部状态
2. 需要将某些状态外部化，使得运行时间变长



## 应用场景

有大量相同或者相似的对象

应当在多次重复使用享元对象时才值得使用享元模式



## 模式扩展

### 单纯享元模式

就是上面类图中的右下角，所有的享元对象都是可以共享的



### 复合享元模式（和组合模式联用）

![](https://s2.ax1x.com/2019/12/24/lPr6bV.png)



## 模式联用

### 和静态工厂联用

享元工厂是静态工厂



### 和单例模式联用

享元工厂是单例的



### 和组合模式联用

享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态，如上



# 享元模式vs原型模式

和原型模式的比较：原型是复制相同的，可以存储状态和备份等



原型管理器 vs 享元工厂

原型管理器只负责管理
享元还负责创建
原型管理器不一定要有
但原型管理器是享元是模式的一部分





# 代理模式

通过引入一个新的对象(如小图片和远程代理对象)来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象



## 定义

代理模式(Proxy Pattern) :给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式



## 类图

![](https://s2.ax1x.com/2019/12/24/lPrxxA.png)

代理对象和真实对象接口是一致的
将任务委托给真实对象
可以增加一些新的行为来控制对真实对象的访问(preRequest和postRequest)，如下

![](https://s2.ax1x.com/2019/12/24/lPsprt.png)



## 实例

![](https://s2.ax1x.com/2019/12/24/lPsPVf.png)

![](https://s2.ax1x.com/2019/12/24/lPcbyd.png)



![](/Users/cengshaoxun/Library/Application Support/typora-user-images/image-20191224221400409.png)

![](https://s2.ax1x.com/2019/12/24/lPgAwq.png)



![](https://s2.ax1x.com/2019/12/24/lP27qA.png)

![](https://s2.ax1x.com/2019/12/24/lP2LIP.png)



## 优点

代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度



## 缺点

由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢

实现代理模式需要额外的工作，有些代理模式的实现非常复杂（例如远程代理就非常复杂）



## 模式扩展

### 保护（Protect or Access）代理

控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限

该代理用于控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 见实例中的第一个例子



### 远程（Remote）代理

为一个位于不同的地址空间的对象提供一个本地的代理 对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中， 远程代理又叫做大使(Ambassador)
 

远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求

和保护模式和虚拟代理相比，远程代理和业务逻辑无关，因此其实可以放在类库里面复用

![](https://s2.ax1x.com/2019/12/24/lP208U.png)



### 虚拟（Virtual）代理

如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。虚拟代理模式是一种内存节省技术。在应用程序启动的时候，可以用代理对象代替真实对象初始化，节省了内存的占用，并大大加速了系统的启动时间

虚拟代理通过使用一个小对象来代表一个大对象，可以 减少系统资源的消耗，对系统进行优化并提高运行速度 

![](https://s2.ax1x.com/2019/12/24/lP2fPK.png)