---
title: C++学习笔记（二）
date: 2019-12-16 19:19:45
categories: c++
tags: c++
cover_img:
feature_img:
description:
keywords:
---

# 模板

两种：类属函数，类属类



## 类属函数

同一函数对不同类型的数据完成相同的操作

宏实现的缺陷：只能实现简单的功能，没有类型检查

函数重载的缺陷：需要定义的重载函数太多，定义不全

函数指针：

![image](https://s2.ax1x.com/2019/12/16/Q5Pwxs.png)

需要定义额外参数

大量指针运算

实现起来复杂

可读性差



这就是template引入的目标：完全，清晰

![image](https://s2.ax1x.com/2019/12/16/Q5Pfz9.png)

T类型只要符合：重载>操作符，有=操作符（默认有），有拷贝构造函数（默认有）（尽量使用const &的方式，可以避免使用拷贝构造）。



函数模版在编译的时候会根据传入的类型生成另一段代码，即编译系统自动实例化函数模板



函数模板的参数可以是普通参数，不过调用的时候需要显式实例化，例如：

![image](https://s2.ax1x.com/2019/12/16/Q5PvQA.png)



调用顺序：

调用非模板函数

模板的显式化版本

调用模板



其中模板的显式化版本的意思是 https://zh.cppreference.com/w/cpp/language/template_specialization

对于某个模板，可以直接给定它的类型，将其实例化

例如：

显式特化必须出现在非特化模板声明后

```c++
template<class T> class X { /*...*/ }; // 主模板
template<> class X<int> { /*...*/ }; // 同命名空间中的特化
template<class T> class Y { /*...*/ }; // 主模板
template<> class Y<double>; // 对 double 特化的前置声明
```

当特化函数模板时，若能从函数实参予以提供，则可忽略其实参：


```c++
template<class T> class Array { /*...*/ };
template<class T> void sort(Array<T>& v); // 主模板
template<> void sort(Array<int>&); // 对 T = int 的特化
// 不需要写为
// template<> void sort<int>(Array<int>&);
```



## 类属类

类属类必须显式实例化，因为类要做检查，例如push的时候就要保证每次push的都是同一个类型

![image](https://s2.ax1x.com/2019/12/16/Q5FWuR.png)

类模板中的静态成员属于实例化后的类而不是模板

是否实例化模板的某个实例由使用点来决定；如果未使用到一个模板的某个实例，则编译系统不会生成相应实例的代码



n如果在模块A中要使用模块B中定义的某模板的实例，而在模块B中未使用这个实例，则模块A无法使用这个实例（因为并没有生成对应代码）



模板元编程

![image](https://s2.ax1x.com/2019/12/16/Q5A201.png)