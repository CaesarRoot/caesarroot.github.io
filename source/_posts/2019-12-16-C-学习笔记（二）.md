---
title: C++学习笔记（二）
date: 2019-12-16 19:19:45
categories: c++
tags: c++
cover_img:
feature_img:
description:
keywords:
---

# 模板

两种：类属函数，类属类



## 类属函数

同一函数对不同类型的数据完成相同的操作

宏实现的缺陷：

1. 只能实现简单的功能
2. 没有类型检查

函数重载的缺陷：

1. 需要定义的重载函数太多
2. 定义不全

函数指针：

![image](https://s2.ax1x.com/2019/12/16/Q5Pwxs.png)



1. 需要定义额外参数
2. 大量指针运算
3. 实现起来复杂
4. 可读性差



这就是template引入的目标：完全，清晰

![image](https://s2.ax1x.com/2019/12/16/Q5Pfz9.png)

T类型只要符合：重载>操作符，有=操作符（默认有），有拷贝构造函数（默认有）（尽量使用const &的方式，可以避免使用拷贝构造）。



函数模版在编译的时候会根据传入的类型生成另一段代码，即编译系统自动实例化函数模板



函数模板的参数可以是普通参数，不过调用的时候需要显式实例化，例如：

![image](https://s2.ax1x.com/2019/12/16/Q5PvQA.png)



调用顺序：

1. 调用非模板函数
2. 模板的显式化版本
3. 调用模板



其中模板的显式化版本的意思是 https://zh.cppreference.com/w/cpp/language/template_specialization

对于某个模板，可以直接给定它的类型，将其实例化

例如：

显式特化必须出现在非特化模板声明后

```c++
template<class T> class X { /*...*/ }; // 主模板
template<> class X<int> { /*...*/ }; // 同命名空间中的特化
template<class T> class Y { /*...*/ }; // 主模板
template<> class Y<double>; // 对 double 特化的前置声明
```

当特化函数模板时，若能从函数实参予以提供，则可忽略其实参：


```c++
template<class T> class Array { /*...*/ };
template<class T> void sort(Array<T>& v); // 主模板
template<> void sort(Array<int>&); // 对 T = int 的特化
// 不需要写为
// template<> void sort<int>(Array<int>&);
```



## 类属类

类属类必须显式实例化，因为类要做检查，例如push的时候就要保证每次push的都是同一个类型

![image](https://s2.ax1x.com/2019/12/16/Q5FWuR.png)

类模板中的静态成员属于实例化后的类而不是模板

是否实例化模板的某个实例由使用点来决定；如果未使用到一个模板的某个实例，则编译系统不会生成相应实例的代码



n如果在模块A中要使用模块B中定义的某模板的实例，而在模块B中未使用这个实例，则模块A无法使用这个实例（因为并没有生成对应代码）



模板元编程

![image](https://s2.ax1x.com/2019/12/16/Q5A201.png)



# 异常处理

常见处理方法：

1. 函数参数（返回值或引用参数）
2. 逐层返回

缺点：程序结构不清楚



## 类型转化

*比重载严格，需要精确匹配*

*只有三种情况可以转化：*

*除了非**const**到**const*

*从派生类到基类*

*从数组或函数到指向数组或函数的指针*



## 静态编译

下面的代码的输出为

derived f()
Base
base f()

```c++
#include <iostream>
using namespace std;

class BaseException{
public:
    int a;
    BaseException():a(1){}
    virtual void f(){cout << "base f()" << endl;}
};

class DerivedException: public BaseException{
public:
    int a;
    DerivedException():a(100){}
    void f(){cout << "derived f()" << endl;}
};

void f(){
    DerivedException e;
    throw e;
};

int main(){
    try{
        try{
            f();
            // 引用和切片的区别在于这个catch里面能否获得动态绑定的类型
            // 抛出的时候都是基类（编译类型）
        }catch(BaseException& a){
            a.f();
            throw a;
        }
    }catch(DerivedException a){
        cout << "Derived" << endl;
        a.f();
    }
    catch(BaseException a){
        cout << "Base" << endl;
        a.f();
    }
    return 0;
}
```



# RAII

资源获得即初始化，解决多出口、碎片问题

例子：智能指针

如下：

![](https://s2.ax1x.com/2020/01/06/ly6hy8.png)



# 非虚接口解决打印问题

如果父类有打印的全局函数，想要子类也有自己的打印函数，可以再写一个，但是解决不了

```c++
Father &f = son;
cout << f << endl;
```

因此需要用到非虚接口

即在父类中写一个虚函数（子类有自己的版本），通过该虚函数可以调用到不同的版本的打印

然后再重载操作符，非虚函数调用虚函数

![](https://s2.ax1x.com/2020/01/06/lyc31P.png)



# 原型模式解决复制问题

用了一个父类的指针，又要具体的子类复制

![](https://s2.ax1x.com/2020/01/06/lycD10.png)

![](https://s2.ax1x.com/2020/01/06/lyc6nU.png)



# 不要把数组处理成多态

指针偏移会有问题，偏移量是静态编译计算好的，如果说子类的大小和父类一样，那么没有问题，否则不能正确偏移

![](https://s2.ax1x.com/2020/01/06/lycWN9.png)

