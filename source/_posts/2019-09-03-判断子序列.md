---
title: 判断子序列
date: 2019-09-03 20:39:34
categories: leetcode
tags: [刷题,动态规划]
cover_img: https://s2.ax1x.com/2019/09/03/nANnKS.png
feature_img: https://s2.ax1x.com/2019/09/03/nANnKS.png
description:
keywords:
---

# 题目

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

示例 1:
s = "abc", t = "ahbgdc"

返回 true.

示例 2:
s = "axc", t = "ahbgdc"

返回 false.

后续挑战 :

如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/is-subsequence

# 思路

原题没什么好说的，直接一个循坏找出来就行了

``` c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int i=0;
        if(s.size()==0) return true;
        bool flag = false;
        for(char c: t){
            if(c==s[i]){
                i++;
            }
            if(i==s.size()){
                flag = true;
                break;
            }
        }
        return flag;
    }
};
```

扩展部分没什么好的思路，就直接看题解了



# 题解

作者：zzzzzz-5
链接：https://leetcode-cn.com/problems/is-subsequence/solution/cpan-duan-zi-xu-lie-hou-xu-tiao-zhan-by-zzzzzz-5/

后续挑战，输入量大，小写字母创建25的二维数组，存储t的坐标，这样就可以把s的判断直接转为坐标的判断，
dp[0]代表了存储了a出现在t的所有的位置,逐个字符判断s的字符顺序是否在t内，直接返回结果。
时间复杂度O(t.size()+2000)：分别为创建数组需要O(t.size()),
索引是递增的使用二分查找s的单个字符20次之内就可找到需要O(100*20)。
适用大量的输入判断子序列。

``` c++
bool isSubsequence(string s, string t) {      
  vector<vector<int>>dp(26);
  int tag=-1;
  for(int i=0;i<t.size();i++)
    dp[t[i]-'a'].push_back(i);
  for(int i=0;i<s.size();i++){
    int now=s[i]-'a';
    int left=0,right=dp[now].size()-1;            
    if(right<0) return false;
    while(left<right){
      int mid=(left+right)/2;
      if(dp[now][mid]>tag)
        right=mid;
      else
        left=mid+1;
    }
    if(right<left || dp[now][left]<tag)return false;
    tag=dp[now][left];
  }
  return true;
}
```

不需要存储所有的字串，而是存下长字符串的坐标，然后对每个短的字串再判断
对于每个短的串，一个小循环：对每个字符，先找到比前一个字符的坐标（tag）大的最小坐标（更新为下一个tag）；第一个字符只要初始化tag=-1即可找到第一个字符的最小坐标
用二分查找，right对应的数设置为比mid大的数，这样如果存在比tag大的数，left最终会等于right，且那个位置一定是要找的那个数；如果不存在，那么最后left和right都会等于原来的right，最后判断一下dp[now][left]和tag的大小即可
注意二分查找退出的时候，其实是不会出现right<left的情况的，只有可能是找到那个数或者dp[now][left]<tag，这时候即找不到比前一个tag大的位置，故而返回false