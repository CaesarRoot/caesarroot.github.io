---
title: C++学习笔记（四）
date: 2019-12-17 15:42:51
categories: c++
tags: c++
cover_img:
feature_img:
description:
keywords:
---

# 类继承

## 成员函数

两种成员函数

1. 基类希望其派生类进行覆盖的函数，这一种函数是虚函数，当我们使用指针或引用调用虚函数时，该调用将被动态绑定，根据应用或指针所绑定的对象类型的不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数
2. 基类不希望派生类进行覆盖的函数，这一类函数为非虚函数

注意，如果派生类没有覆盖基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本



## 类型转化

派生类对象包含多个组成部分：含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的对象也有多个

![image](https://s2.ax1x.com/2019/12/17/QoLJHg.png)

## 派生类构造函数

尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分

派生类构造函数同样是铜鼓哦构造函数初始化列表来将实参传递给基类构造函数的



## 静态类型和动态类型

静态类型是在编译时就确定了的

动态类型这是在变量或表达式表示的内存中的对象的类型，运行时才可知

如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致

用dynamic_cast请求类型转换，该转换的安全检查将在运行时执行

用static_cast来强制覆盖掉编译器的检查工作，在编译期间就使得类型转化了



## 虚函数

引用或者指针调用一个函数的时候

1. 如果说非虚函数，那么编译时期就可以确定
2. 如果是虚函数，那么要到运行时刻才可以确定

通过对象调用的函数编译时就可以确定，因为对象的类型是确定不变的（静态类型等于动态类型）

虚函数一定要有定义，即使没有被用到；其他函数如果没有被用到，不需要给出定义



### override

这个关键字可以让编译器检查是否真的覆盖了虚函数

override关键字只能修饰虚函数



### final

如果被final修饰，那么将不能被覆盖

只有虚函数才能被定义为final



### 默认参数

虚函数的默认参数是静态绑定的

即如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也还是如此



## 纯虚函数

书写=0就可以将一个虚函数说明为纯虚函数

含有纯虚函数的类是抽象类

抽象类不能实例化

派生类必须给出纯虚函数的实现，否则仍然是抽象类



## 访问控制

### protected

与派生类分享，但是不会被其他类公共访问，可以看作是public和private中和后的产物

派生类的成员或友元只能通过派生类对象来访问基类的受保护成员

```c++
#include <iostream>
using namespace std;

class Father{
protected:
    int a;
    void g(){}
};

class Son:public Father{
public:
    // 子类不能直接访问父类中的protected成员或是方法
    // 只能通过他的子类来使用
    // void f(Father f){cout << f.a << endl;}
    void f(Son s){cout << s.a << endl;s.g();}
};

int main(){
    return 0;
}
```



### 派生列表中的访问说明符

派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么印象，对基类成员的访问权限只与积累中的访问说明符有关

派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限



## 类型转化

对于代码中的某个节点来说，如果积累的公有成员是可访问的，则派生类向基类的类型转化也是可访问的；反之则不行

例如：

1. 如果是私有继承，那么用户代码不能使用派生类向基类的转化
2. 无论D以什么方式继承B，D的成员函数和友元都可以使用派生类向基类的转化
3. 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的转换



## 友元和继承

友元关系不能传递，不能继承

基类的友元在访问派生类成员时不具有特殊性；派生类的友元也不能随意访问基类的成员

每个类负责控制自己的成员的访问权限，因此如果基类定义了友元，那么这个友元可以访问之类中的基类部分，即使这一部分之类都无法访问，例如：

```c++
class Father{
private:
    int father;
protected:
    friend class F;
};

class Son:public Father{
private:
    int son;
public:
    void f(Son s){}
};

class F{
public:
    // F是父类的友元，因此可以访问Son中的Father的私有部分
    // 尽管这一部分是Son都不能访问的
    void f(Son s){cout << s.father << endl;}
};
```



## 继承中的类作用域

如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找改名字的定义

### 在编译时就进行名字查找

一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的，我们能使用哪些成员仍然是由静态类型决定的



### 名字冲突与继承

派生类的成员将隐藏同名的基类成员（因为在当前作用域中就已经找到了名字，就不会再去基类找了）

可以通过using来使用一个被隐藏的基类成员

![image](https://s2.ax1x.com/2019/12/18/QTfG6J.png)



### 查找顺序

![image](https://s2.ax1x.com/2019/12/18/QTfDpD.png)



### 名字查找优先于类型检查

即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉

一旦名字找到，编译基就不再继续查找了，因此如果之类中有同名（只是同名，参数不一定相同）函数，就会覆盖掉基类中的所有同名函数



### 虚函数的调用

![image](https://s2.ax1x.com/2019/12/18/QThauj.png)

![image](https://s2.ax1x.com/2019/12/18/QThyCT.png)

![image](https://s2.ax1x.com/2019/12/18/QThDU0.png)



### 覆盖重载的函数

如果子类中有了一个同名的函数，那么基类中的所有函数都会被覆盖

如果想继承所有的函数，但是只是覆盖掉其中几个，可以用using语句

```c++
class Father{
public:
    void f(){cout << "Father f()" << endl;}
    void f(int){cout << "Father f(int)" << endl;}
};

class Son:public Father{
public:
    using Father::f;
    void f(){cout << "Son f()" << endl;}
};


int main(){
    Son s;
    s.f();
    // 使用了using就可以继承父类的所有同名方法了
    // 只会覆盖掉其中子类自定义的版本
    s.f(1);
    return 0;
}
```



## 构造函数与拷贝控制以及析构函数

无论是合成的默认构造函数，还是拷贝构造函数，还是赋值运算符，还是析构函数，它们除了负责自己的那一部分，还要负责直接基类中的那一部分的对应行为

因此如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问的函数，则派生类中对应的成员是被删除的，因为编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或者销毁操作



### 析构函数

基类的析构函数一般要定义成虚函数，这样就可以动态调用到子类的析构函数，正确释放资源

析构函数和其他不同，只要负责自己销毁，因为会自动调用父类的析构进行销毁，但是例如构造函数、拷贝控制，都要现式写明调用情况或是拷贝的情况。

即子类的析构函数只要析构自己就行了，不用再写任何其他的代码

```c++
class A{
public:
    ~A(){cout << "Father's ~" << endl;}
};

class B:public A{
public:
    ~B(){cout << "Son's ~" << endl;}
};

int main(){
    B b;
    // 输出为
    // Son's ~
    // Father's ~
    return 0;
}
```



### 构造函数

之前已经看到过了，如果要使用基类的特定构造函数，要显式写明

下面是调用拷贝构造函数和其他构造函数的写法：

```c++
#include <iostream>
using namespace std;

class A{
public:
    int a;
    A(){cout << "A's A()" <<endl;}
    A(int a):a(a){cout << "A's A(int)" << endl;}
    A(const A& a){cout<<"A's copy constructor"<<endl;}
};

class B: public A{
public:
    B(){}
    // 指定调用父类的某个构造函数
    B(int a):A(a){}
};

class C:public A{
public:
    C(){}
    C(const C& c){ cout << "C's copy constructor"<<endl;}
};

class D:public A{
public:
    D(){}
    D(const D& d):A(d){ 
        cout << "D's copy constructor"<<endl;
    }
};

int main(){
    // 如果子类没有指明调用父类的哪个构造函数
    // 那么调用默认构造函数
    B b0;
    B b(100);
    cout << endl;
    // 如果子类没有自己定义拷贝构造函数
    // 那么会自动调用父类的拷贝构造函数


    // 使用子类合成拷贝构造函数
    // 将调用父类的拷贝构造函数
    B b2(b);
    cout << endl;

    // 如果子类自定义了拷贝构造函数
    // 而没有指定基类部分如何拷贝
    // 那么默认掉用父类的默认构造函数
    C c;
    C c2(c);
    cout << endl;

    // 如果在初始化列表中指明调用了基类的拷贝构造函数
    // 那么会正确拷贝基类部分
    D d0;
    D d1(d0);
    return 0;
}
```

析构函数的执行顺序和构造函数相反：派生类的析构函数首先执行，然后是基类的析构函数；基类的构造函数先执行，然后是派生类的构造函数



### 拷贝控制

合成的拷贝控制成员负责本类的赋值操作，还要负责直接基类中对应的操作。即要负责直接基类部分的复制

上面已经看了拷贝构造函数的写法，下面看赋值运算符的写法

同样也要显式写出：

```c++
#include <iostream>
using namespace std;

class A{
public:
    A& operator=(A& a){ cout << "A's =" << endl;return *this;}
};

class B:public A{
public:
    B & operator=(B& a){ cout << "B's =" << endl;return *this;}
};

class C:public A{
public:
    C & operator=(C& a){ 
        // 注意写法
        A::operator=(a);
        cout << "C's =" << endl;return *this;
    }
};

int main(){
    // 默认不会调用基类的赋值操作
    // 因此不会拷贝基类部分
    B b1;
    B b2;
    b1 = b2;
    cout << endl;

    // 需要显式写出调用基类的赋值运算符
    C c1;
    C c2;
    c1 = c2;
    return 0;
}
```

注意这里调用赋值运算符的特殊写法

上面传递给基类的赋值运算符的时候，基类只会释放掉基类部分的空间，并且进行赋值，因此不会有问题

无论基类的构造函数或赋值运算符是定义一的还是合成的，派生类的对应操作都能使用它们



### 番外：在构造函数和析构函数中调用虚函数

执行虚构的时候，部分已经被销毁

执行构造的时候，还未完成对象创建

为了能够正确处理这种未完成状态，编译器认为对西那个的类型在构造或析构的过程中反复发生了改变一样（即类型是不确定的，按照当前构造或是析构的程度来确定当前的状态）

也就是说，当我们构建一个对象时，需要把对象的类和构造函数的类看作是同一个：对虚构函数的调用绑定真好符合这种把对象的类和构造函数的类看成同一个的要求，对析构函数也是同样的道理

上述绑定不但对直接调用虚函数有效，对间接调用也是有效的

```c++
#include <iostream>
using namespace std;

class A{
public:
    A(){f();}
    virtual void f(){cout << "A's f()"<<endl;}
    virtual ~A(){f();}
};

class B:public A{
public:
    void f(){cout << "B's f()"<<endl;}
};

int main(){
    // 无论是构造过程还是析构过程
    // 调用的都是A的f()
    // 因为到A的时候
    // 1. B还没有构造
    // 2. B已经析构
    // 因此调用的都是A的f
    B b;
    return 0;
}
```



## "继承"构造函数

类不能继承默认、拷贝和移动构造函数，因为编译器会为派生类合成默认的

和"继承"别的函数一样，使用using即可，不过using完了之后，其他函数是直接照搬过来，但是对于构造函数，编译器会稍作修改

![image](https://s2.ax1x.com/2019/12/18/QTqAUJ.png)

还有一个区别就是，普通函数的using可以改变访问级别，例如我在private里面using，那么"继承"下来的函数就会是private的，但不是构造函数不一样，基类的私有构造函数在派生类中还是一个私有构造函数，而不管using出现在哪



![image](https://s2.ax1x.com/2019/12/18/QTqBVg.png)

![image](https://s2.ax1x.com/2019/12/18/QTqIIJ.png)



## 容器与继承

容器内要放同一个类型的对象

不能放基类，否则会被切片

因此要放指针



当容器深拷贝时，不能直接push指针（否则就是浅拷贝），因此需要将一个clone函数处理成虚函数，这样就可以根据类型动态调用深拷贝

对于数组来说，下标运算符其实是指针的偏移，而指针的偏移是按照静态类型来计算的，因此不要把数组看作是多态的

![image](https://s2.ax1x.com/2019/12/18/QTXkVS.png)