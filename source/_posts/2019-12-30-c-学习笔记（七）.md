---
title: c++学习笔记（七）
date: 2019-12-30 15:53:44
categories: c++
tags: c++
cover_img:
feature_img:
description:
keywords:
---

# 杂项

## 静态成员变量

static变量一定要在类外显式初始化

否则就是声明

不调用构造函数



static在外面初始化的时候不能写static



## const成员变量

类中的const需要在成员初始化表中初始化



## 静态const成员变量

static const需要在类外初始化

如果在声明的时候直接给出初始值，这时候不会分配内存，当作宏使用，取地址会出错

例如：

```c++
class A{
public:
    // 静态成员不能在类内部初始化
    // static int a = 0;
    static int o;

    // 但是静态的常量可以在类内初始化
    const static int a = 0;
    const static int b;
};

const int A::b = 1;

int A::o = 0;


int main(){
    A a;
    // const static 如果直接在类内给出值，那么用到的时候是作为常量直接替换，不会分配存储空间
    // cout << &a.a << endl;
    // 只有在类外定义才会有存储空间
    cout << &a.b << endl;
    return 0;
}
```



## enum hack

在类内定义了const，不能将它作为数组大小的参数

```c++
class A {
public:
  const int a = 1;
  int scores[a];
};
```

上面代码是错的（即使有类内初始值），因为编译器认为a的值不确定

```c++
class A {
public:
  static const int a = 1;
  int scores[a];
};
```

加上了static const，并且使用类内初始值就行（如果不是类内初始值还是错的）



此时如果不想硬编码数组大小，就可以用enum hack

https://www.cnblogs.com/jiqingwu/p/cpp_enum_hack.html

```c++
class Game {
private:
    // static const int GameTurn;
    enum {GameTurn = 10};
    int scores[GameTurn];
};

// const int Game::GameTurn = 10;
```



## 函数返回值左值右值问题

如果返回的是const，那么不能被赋值

如果不是const，那么可以被赋值

内置类型会直接报错

自定义类型该操作没有意义



## 非const调用const的类型转换



## 类型转化的方式

1. 编译器承认的类型转化，例如派生类到基类
2. 带有一个参数的构造函数（如果是两个参数，第二个参数有默认值也行），例如

```c++
class A{
public:
    A(){cout << "A's default constructor"<<endl;}
    A(int a, int b = 1){cout << "A's constructor" << endl;}
};

A f(){
    // 会自动调用构造函数来实现隐式转化
    int a = 1;
    return a;
};

int main(){
    // 返回出来之后不会调用任何构造函数或者赋值操作
    // 这里是编译优化了
    // 应该是转移构造函数在起作用
    // 直接让a指向返回值所在的那个空间
    A a = f();
    return 0;
}
```

3. 类型转化操作符



## 编译器自动生成的函数



## 不能自定义的操作符&&全局和成员重载限制



## 指针和数组区别

sizeof

delete

数组名字不能做指针的加法操作



## 对类型进行sizeof

虚函数表占用空间



## 模板的显式具体化和隐式具体化



## 模板具体化版本在链接时候的特性



## 多继承构造函数调用顺序

