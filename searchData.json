[{"title":"ffmpeg常用功能精简使用指南","url":"/2020/04/30/ffmpeg常用功能精简使用指南/","content":"\nffmpeg命令是一个强大的流媒体处理命令。下面是几个常用的可以使用ffmpeg来解决的问题场景：\n\n1. 压缩文件大小\n2. 剪辑视频长度\n3. 下载网页视频\n\n\n\n## 安装\n\n直接看官网就行\n\nhttps://www.ffmpeg.org/download.html\n\nmacos下可以用brew安装\n\n```shell\nbrew install ffmpeg\n```\n\n\n\n## 压缩文件大小\n\nffmpeg本身支持多种压缩方法，包括码率和其他的格式等。这些命令一般比较复杂，其实有一个特别简单的方法：\n\n```shell\nffmpeg -i input.mp4 output.mp4\n```\n\n默认的ffmpeg命令就已经优化了视频的压缩算法，因此直接导入导出就可以明显缩减视频大小\n\n\n\n## 剪辑视频长度\n\n有时候只想简单的截取视频的某一部分，这时可能手边没有视频剪辑软件，或者是视频剪辑软件太重，对于这个轻量级的任务ffmpeg有更好的解法：\n\n```shell\nffmpeg -ss 00:01:00 -i input.mp4 -t 00:01:00 -c copy output.mp4\n```\n\n上面这个命令将input.mp4视频中1分钟-2分钟的部分剪辑出来，存放在output.mp4中\n\n`-ss`意思是一个偏移量，即从1分钟的地方开始\n\n`-i`意思是输入文件\n\n`-t`是要剪辑的视频长度，上面命令为一分钟\n\n`-c`表示不重新编码。这个参数应该是为了加速处理过程，应该不是特别重要\n\n\n\n## 下载网页视频\n\n在这个需求上ffmpeg真的是神器。\n\n现在网页播放的视频，基本没有网站会把完整的mp4的url放在response中，基本都会采用另外一些格式，例如m3u8格式，这种格式会有一个index文件，标识了视频的元信息，后续的视频通过分片的方式，每个分片都是一个小的ts文件，这些文件组合起来就是一个完整的视频。如果手动下载所有的ts再组合就太麻烦了，这里用ffmpeg就会变得非常简单。\n\n我们随便打开一个视频：http://www.dytt.com/vod-play-id-94467-src-1-num-7.html\n\n打开控制台，看network，搜索m3u8\n\n<img src=\"https://s1.ax1x.com/2020/04/30/JbEDEQ.png\" alt=\"JbEDEQ.png\" border=\"0\" />\n\n点开看请求头\n\n<img src=\"https://s1.ax1x.com/2020/04/30/JbEfDU.png\" alt=\"JbEfDU.png\" border=\"0\" />\n\n复制到命令行，如下\n\n```shell\nffmpeg -i https://us8.wl-cdn.com/hls/20200403/090990addb56baa30668886c0095679b/index.m3u8 output.mp4\n```\n\n就会开始自动下载了\n\n<img src=\"https://s1.ax1x.com/2020/04/30/JbEzUH.png\" alt=\"JbEzUH.png\" border=\"0\" />\n\n整个过程就是下载ts文件，然后拼起来\n\n<img src=\"https://s1.ax1x.com/2020/04/30/JbeggI.png\" alt=\"JbeggI.png\" border=\"0\" />\n\n\n\n## 在线播放视屏\n\n利用ffplay可以直接在线播放，而不用等到视屏下载完毕，支持多种格式，例如m3u8格式只要输入如下命令：\n\n```shell\nffplay -i https://youku.com-iqiyi.net/20180128/IVmdoB2k/index.m3u8\n```\n\n会弹出一个窗口直接播放，且支持快进、暂停等","categories":["linux"]},{"title":"flink源码阅读和解析笔记--任务执行","url":"/2020/03/15/flink源码阅读和解析笔记-任务执行/","content":"\n# Flink任务运行流程\n\n## StreamTask\n\n该类是所有流计算任务的基类，一个任务是部署在`TaskManager`上并且由它运行的一个本地处理单元。另外，有关checkpoint的实现也在这里。\n每一个任务运行着一个或多个`StreamOperator`，如下图所示\n\n![image](https://s1.ax1x.com/2020/03/15/83kiDK.png)\n\n这些`StreamOperator`会形成operator chain，形成条件包括上下游算子的并行度等。\n代码中将单个`StreamOperator`和它们所形成的chain统一表示，即统一采用`StreamTask`。对于chain来说，`StreamTask`包含了chain的\"head\"，此时`StreamTask`的类型就是这个\"head\" operator的类型。\n\n```java\npublic abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>\n\t\textends AbstractInvokable\n\t\timplements AsyncExceptionHandler {\n    ...\n\t/** the head operator that consumes the input streams of this task. */\n\tprotected OP headOperator;\n    ...\n}\n```\n\n一个chain里面的所有算子在同一个线程中同步执行，因此它们在同一个stream partition上。\n一个任务处理一个流的建立（由head operator读入），和流的产生（chain中最后一个operator的输出），注意一个chain可能有多个流出（end）。\n\n## 生命周期\n\n一个task的生命周期如下：\n\n```shell script\n *  -- setInitialState -> provides state of all operators in the chain\n *\n *  -- invoke()\n *        |\n *        +----> Create basic utils (config, etc) and load the chain of operators\n *        +----> operators.setup()\n *        +----> task specific init()\n *        +----> initialize-operator-states()\n *        +----> open-operators()\n *        +----> run()\n *        +----> close-operators()\n *        +----> dispose-operators()\n *        +----> common cleanup\n *        +----> task specific cleanup()\n```\n\n注意：在一个chain里面，`StreamOperator`的方法是不能并发调用的，内部实现是通过一个锁。\n\n```java\npublic final void invoke() throws Exception {\n    try {\n        beforeInvoke();\n\n        // final check to exit early before starting to run\n        if (canceled) {\n            throw new CancelTaskException();\n        }\n\n        // let the task do its work\n        runMailboxLoop();\n\n        // if this left the run() method cleanly despite the fact that this was canceled,\n        // make sure the \"clean shutdown\" is not attempted\n        if (canceled) {\n            throw new CancelTaskException();\n        }\n\n        afterInvoke();\n    }\n    finally {\n        cleanUpInvoke();\n    }\n}\n```\n\n在`beforeInvoke`中会做一些初始化工作，包括提取出所有的operator等。\n在`runMailboxLoop`中调用task运行\n在`afterInvoke`中结束\n\n任务的运行使用了`mailbox-based execution model`，这个模型做了很多封装。\n在invoke中会启动这个模型的处理循环吗，之后各个行为都被封装在Action中被调用执行。invoke的调用链：\n\n```shell script\ninvoke() -> runMailboxLoop() -> mailboxProcessor.runMailboxLoop()\n```\n\n最后交由`MailboxProcessor`来循环处理各个action，因此只要关注任务的action即可把握任务的运行情况。\n\n## 执行任务\n\n这个是任务运行的核心，即这里会产生action交由`MailboxProcessor`执行。\n`processInput`方法处理输入，是task的默认action，在输入上处理一个事件（event）。该方法又会调用`StreamInputProcessor`来处理输入，返回一个处理后的状态。\n判断当前状态来决定是否要继续这个action：如果当前有更多输入，且输出（`recordWriter`）就绪，那么直接返回（因为还有更多的输入，因此不结束action）；如果输入已经结束，标记一下action为结束状态，直接返回；否则将当前的action暂停，直到有输入且输出（`recordWriter`）就绪的时候恢复执行（异步等待）\n\n```java\nprotected void processInput(MailboxDefaultAction.Controller controller) throws Exception {\n    InputStatus status = inputProcessor.processInput();\n    if (status == InputStatus.MORE_AVAILABLE && recordWriter.isAvailable()) {\n        return;\n    }\n    if (status == InputStatus.END_OF_INPUT) {\n        controller.allActionsCompleted();\n        return;\n    }\n    CompletableFuture<?> jointFuture = getInputOutputJointFuture(status);\n    MailboxDefaultAction.Suspension suspendedDefaultAction = controller.suspendDefaultAction();\n    jointFuture.thenRun(suspendedDefaultAction::resume);\n}\n```\n\n### StreamInputProcessor\n\n这个是真正执行读取上游输入并且处理任务的接口，该接口只有一个方法：\n\n```java\npublic interface StreamInputProcessor extends AvailabilityProvider, Closeable {\n\t/**\n\t * @return input status to estimate whether more records can be processed immediately or not.\n\t * If there are no more records available at the moment and the caller should check finished\n\t * state and/or {@link #getAvailableFuture()}.\n\t */\n\tInputStatus processInput() throws Exception;\n}\n```\n\n该方法处理完输入之后，会返回状态，是一个枚举类型：\n\n```java\npublic enum InputStatus {\n\n\t/**\n\t * Indicator that more data is available and the input can be called immediately again\n\t * to emit more data.\n\t */\n\tMORE_AVAILABLE,\n\n\t/**\n\t * Indicator that no data is currently available, but more data will be available in the\n\t * future again.\n\t */\n\tNOTHING_AVAILABLE,\n\n\t/**\n\t * Indicator that the input has reached the end of data.\n\t */\n\tEND_OF_INPUT\n}\n```\n\n`StreamInputProcessor`有三个实现类，分别是：\n\n```java\nStreamOneInputProcessor\nStreamTwoInputProcessor\nStreamMultipleInputProcessor\n```\n\n这三个实现类都有一个成员变量：\n\n```java\nprivate final OperatorChain<?, ?> operatorChain;\n```\n\n配套这个成员变量的还有两组成员变量，配套的意思是如果是`StreamTwoInputProcessor`，那么下面就有两组：\n\n```java\nprivate final StreamTaskInput<IN> input;\nprivate final DataOutput<IN> output;\n```\n\n这里的input负责读，读到ouput中，调用ouput的方法，例如`emitRecord`，这个方法的实现类一般是某个`StreamTask`子类的实现类，在这里会开始处理这个输入数据，例如`OneInputStreamTask`的内部类中的一个实现：\n\n```java\n@Override\npublic void emitRecord(StreamRecord<IN> record) throws Exception {\n    numRecordsIn.inc();\n    operator.setKeyContextElement1(record);\n    operator.processElement(record);\n}\n```\n\n下面具体看一下整个调用链\n\n#### StreamOneInputProcessor\n\n核心的方法为：\n\n```java\npublic InputStatus processInput() throws Exception {\n    InputStatus status = input.emitNext(output);\n\n    if (status == InputStatus.END_OF_INPUT) {\n        operatorChain.endHeadOperatorInput(1);\n    }\n\n    return status;\n}\n```\n\n`StreamInputProcessor`的三个实现类都有类似的语句，可以看到`StreamTaskInput`类型的`emitNext`方法返回的`InputStatus`即为`processInput`判断的状态，即只包含三种输入流的状态。\n在这个方法中，最核心的就是下面这条语句：\n\n```java\nInputStatus status = input.emitNext(output);\n```\n\n这里的input和output分别是：\n\n```java\nprivate final StreamTaskInput<IN> input;\nprivate final DataOutput<IN> output;\n```\n\n`StreamTaskInput`有`emitNext`接口方法，两个实现，其中一个还是TODO状态，`StreamTaskNetworkInput`已有实现。\n首先，从deserializer中获得一个反序列化之后的结果\n\n```java\n@Override\npublic InputStatus emitNext(DataOutput<T> output) throws Exception {\n\n    while (true) {\n        // get the stream element from the deserializer\n        if (currentRecordDeserializer != null) {\n            DeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate);\n            if (result.isBufferConsumed()) {\n                currentRecordDeserializer.getCurrentBuffer().recycleBuffer();\n                currentRecordDeserializer = null;\n            }\n\n            if (result.isFullRecord()) {\n                processElement(deserializationDelegate.getInstance(), output);\n                return InputStatus.MORE_AVAILABLE;\n            }\n        }\n\n        Optional<BufferOrEvent> bufferOrEvent = checkpointedInputGate.pollNext();\n        if (bufferOrEvent.isPresent()) {\n            processBufferOrEvent(bufferOrEvent.get());\n        } else {\n            if (checkpointedInputGate.isFinished()) {\n                checkState(checkpointedInputGate.getAvailableFuture().isDone(), \"Finished BarrierHandler should be available\");\n                if (!checkpointedInputGate.isEmpty()) {\n                    throw new IllegalStateException(\"Trailing data in checkpoint barrier handler.\");\n                }\n                return InputStatus.END_OF_INPUT;\n            }\n            return InputStatus.NOTHING_AVAILABLE;\n        }\n    }\n}\n```\n\n再将这个结果放到`DataOutput`中，根据流中元素的类型，调用不同的方法，例如，如果是一条记录，那么调用其`emitRecord`方法：\n\n```java\nprivate void processElement(StreamElement recordOrMark, DataOutput<T> output) throws Exception {\n    if (recordOrMark.isRecord()){\n        output.emitRecord(recordOrMark.asRecord());\n    } else if (recordOrMark.isWatermark()) {\n        statusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), lastChannel);\n    } else if (recordOrMark.isLatencyMarker()) {\n        output.emitLatencyMarker(recordOrMark.asLatencyMarker());\n    } else if (recordOrMark.isStreamStatus()) {\n        statusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), lastChannel);\n    } else {\n        throw new UnsupportedOperationException(\"Unknown type of StreamElement\");\n    }\n}\n```\n\n在这里，output的实现类就会将这一条输入记录进行处理，例如调用各种operator等。\n\n```java\n@Override\npublic void emitRecord(StreamRecord<IN> record) throws Exception {\n    numRecordsIn.inc();\n    operator.setKeyContextElement1(record);\n    operator.processElement(record);\n}\n```\n\n#### OperatorChain\n\n另外说一下chain operator是怎么处理元素的，上面说到只要实现`DataOutput`接口就可以处理输入，但是我们可以看到实现`DataOutput`接口的类其实很少，比如`OperatorChain`就没有实现这个接口，那么是如何实现处理的呢？\n看到它的内部有一个实现类：\n\n```java\nstatic class ChainingOutput<T> implements WatermarkGaugeExposingOutput<StreamRecord<T>> {\n    ...\n    @Override\n    public void collect(StreamRecord<T> record) {\n        if (this.outputTag != null) {\n            // we are not responsible for emitting to the main output.\n            return;\n        }\n        pushToOperator(record);\n    }\n\n    protected <X> void pushToOperator(StreamRecord<X> record) {\n        try {\n            // we know that the given outputTag matches our OutputTag so the record\n            // must be of the type that our operator expects.\n            @SuppressWarnings(\"unchecked\")\n            StreamRecord<T> castRecord = (StreamRecord<T>) record;\n\n            numRecordsIn.inc();\n            operator.setKeyContextElement1(castRecord);\n            operator.processElement(castRecord);\n        }\n        catch (Exception e) {\n            throw new ExceptionInChainedOperatorException(e);\n        }\n    }\n\n    @Override\n    public void emitWatermark(Watermark mark) { ...}\n\n    @Override\n    public void emitLatencyMarker(LatencyMarker latencyMarker) { ... }\n    ...\n}\n```\n\n在这里实现了operator对数据的处理，而在这个内部类外面，有个方法可以返回一组Output：\n\n```java\nprivate <IN, OUT> WatermarkGaugeExposingOutput<StreamRecord<IN>> createChainedOperator(...){...}\n```\n\n这个`WatermarkGaugeExposingOutput`继承于`Output`接口（注意不是`DataOutput`接口）,该接口定义了几个方法\n\n```java\npublic interface Output<T> extends Collector<T> {\n\tvoid emitWatermark(Watermark mark);\n\n\t<X> void collect(OutputTag<X> outputTag, StreamRecord<X> record);\n\n\tvoid emitLatencyMarker(LatencyMarker latencyMarker);\n}\n```\n\n在`Operator`接口的各个实现中，很多都有`Output`类型的的成员变量或是其内部实现类，这些类通过层层调用，达到处理元素或者其他消息的目的。即`Output`一般是作为实现了`DataOutput`接口的成员变量而存在的，通过调用`DataOutput`，用`Output`来处理，推测可能是因为版本的原因，`Output`很早的版本就已经存在了（我看了1.4版本就已经有了），但是`DataOutput`是之后的版本才加入的，引入的目的就是重构读取输入并且处理的这个框架。它们之间的调用情况可以看一个具体的类实现：\n\n```java\npublic class SourceReaderStreamTask<T> extends StreamTask<T, SourceReaderOperator<T>> {\n  /**\n\t * Implementation of {@link DataOutput} that wraps a specific {@link Output} to emit\n\t * stream elements for {@link SourceReaderOperator}.\n\t */\n\tprivate static class StreamTaskSourceOutput<T> extends AbstractDataOutput<T> {\n\n\t\tprivate final Output<StreamRecord<T>> output;\n\n\t\tStreamTaskSourceOutput(\n\t\t\t\tOutput<StreamRecord<T>> output,\n\t\t\t\tStreamStatusMaintainer streamStatusMaintainer) {\n\t\t\tsuper(streamStatusMaintainer);\n\n\t\t\tthis.output = checkNotNull(output);\n\t\t}\n\n\t\t@Override\n\t\tpublic void emitRecord(StreamRecord<T> streamRecord) {\n\t\t\toutput.collect(streamRecord);\n\t\t}\n\n\t\t@Override\n\t\tpublic void emitLatencyMarker(LatencyMarker latencyMarker) {\n\t\t\toutput.emitLatencyMarker(latencyMarker);\n\t\t}\n\n\t\t@Override\n\t\tpublic void emitWatermark(Watermark watermark) {\n\t\t\toutput.emitWatermark(watermark);\n\t\t}\n\t}\n}\n```\n\n这里output的collect会进一步调用到operator的`processElement`（可以看到`OperatorChain`的实现就是这样）\n\n可以理解成整个读取输入并处理的过程就是从input读取，给output处理，中间通过几个接口的委托，最后会委托到具体算子来处理\n\n\n\n### 输出结果\n\n在`StreamTask`中有一个成员变量：\n\n```java\nprivate final RecordWriterDelegate<SerializationDelegate<StreamRecord<OUT>>> recordWriter;\n```\n\n改成员变量负责写入结果，其内部又代理给了`RecordWriter`，这个类里面定义了各种类型的`emit`方法，在这里面写记录\n\n\n\n#### numRecordsIn\n\n这个`Counter`类型的变量封装了处理的记录数，基本上，每次operator处理一条记录，都会累加以`numRecordsIn`为变量名的`Counter`类型的变量，例如在各种的Output里面等。\n\n","tags":["flink"],"categories":["并行计算"]},{"title":"C++学习笔记（五）","url":"/2019/12/30/C-学习笔记（五）/","content":"\n# 面向对象\n\n## 为什么要有OO\n\n解决名空间冲突问题\n\n消除安全隐患（对成员的直接赋值和修改）\n\n封装和信息隐藏\n\n封装内部结构，提供统一接口，更多的类型检查\n\n\n\n## 构造函数\n\n### 重载构造函数\n\n```c++\nclass A{\npublic:\n    A(){ cout << \"Default\" << endl; }\n    A(int i) { cout << \"int i\" << endl; }\n    A(char *p) { cout << \"char *p\" << endl; }\n};\n\nint main(){\n    A a1 = A(1); // 等价于A a1(1); A a1 = 1;\n    A a2 = A(); // 等价于 A a2;\n    A a3 = A(\"abcd\"); // 调用A(char *p)\n    A a[4]; // 调用a[0]、a[1]、a[2]、a[3]的A()\n    A b[5] = { A(), A(1), A(\"abcd\"), 2, \"xyz\" };\n    return 0;\n}\n```\n\n\n\n### 成员初始化表\n\n初始化表先于构造函数，因此const和引用要用初始化表初始化\n\n初始化表式按照对象的声明次序初始化\n\n```c++\n/*\n引用和常量必须在初始化列表中初始化\n*/\nclass A{\npublic:\n    int x;\n    const int y;\n    int z;\n    int &w;\n    A():w(x),y(1),z(x),x(0){ x = 100; }\n};\n\nclass CString{\npublic:\n    char *p;\n    int size;\n    // 按声明顺序执行初始化表\n    // 且初始化表是最先执行的\n    // 而此时size还未初始化\n    CString(int x):size(x),p(new char[size]){}\n};\n\nint main(){\n    A a;\n    cout << a.w << endl;  // 100，w设置成为了x的引用\n    cout << a.x << endl;  // 100\n    cout << a.y << endl;  // 1\n    cout << a.z << endl;  // 0，初始化表先执行，且按照声明顺序，因此x先被赋值成0，然后z赋值成x\n\n    CString s(10);\n    return 0;\n}\n```\n\n如果要调用某个成员函数的非默认构造函数，也要在成员初始化表里面显式写出\n\n要调用父类的特定构造函数，也要在成员初始化表里面显式写出\n\n\n\n## 析构函数\n\nRAII\n\nresoure acquisition is initialization\n\n对象获得即初始化\n\n核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源\n\n\n\n强制在堆上分配空间：将析构函数设为private\n\n```c++\nclass A{\nprivate:\n    ~A(){}\npublic:\n    void destroy() { delete this; }\n};\n\nint main(){\n    // A a; // 将会报错，因为析构函数是私有的，因此不能在栈上创建\n    A* a = new A;\n    // delete a; // 将会报错，因为delete默认调用析构函数\n    a -> destroy();\n    return 0;\n}\n```\n\n除了destroy，还可以写成一个静态方法：\n\n```c++\nstatic void free(A* p){ delete p; }\nA::free(p);\n```\n\n\n\n强制在栈上分配空间：将new操作符设为private\n\n```c++\nclass A\n{\nprivate:\n    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的\n    void operator delete(void* ptr){} // 重载了new就需要重载delete\npublic:\n    A(){}\n    ~A(){}\n};\n\nint main(){\n    // 将new操作符访问级别设为private可以强制只能在栈上分配对象空间\n    // A a = new A;\n    return 0;\n}\n```\n\n\n\n## 拷贝构造函数\n\n调用时机：\n\n1. 初始化的时候 A b = a;\n2. 函数参数传递\n3. 函数返回值\n\n\n\n默认的拷贝构造函数是浅拷贝，指针指向同一块内存区域，这样当一个对象析构的时候，指向同一块内存区域的指针就会变成悬挂指针（野指针）\n\n\n\n如果定义了自己的拷贝构造函数，那么就覆盖掉了默认生成的：\n\n```c++\nclass A{\npublic:\n    int x,y;\n    A(){ x = y = 0;}\n    void inc(){ x++; y++; }\n};\n\nclass B{\npublic:\n    int z;\n    A a;\n    B(){ z = 0; }\n    B(const B& b):a(b.a){ z = b.z; }\n    void inc(){ z++; a.inc(); }\n};\n\nint main(){\n    B b1;  // b1.z = b1.a.x = b1.a.y = 0\n    cout << b1.z << \" \" << b1.a.x << \" \" << b1.a.y << endl;\n    b1.inc();  // b1.z = b1.a.x = b1.a.y = 1\n    cout << b1.z << \" \" << b1.a.x << \" \" << b1.a.y << endl;\n    B b2(b1);  \n    // 如果是默认的拷贝构造函数，那么 b2.z = b2.a.x = b2.a.y = 1\n    // 如果是自己的拷贝构造函数但是没有初始化列表，那么 b2.z = 1 b2.a.x = b2.a.y = 0\n    // 如果是自己的拷贝构造函数且有初始化列表，那么 b2.z = b2.a.x = b2.a.y = 1\n    cout << b2.z << \" \" << b2.a.x << \" \" << b2.a.y << endl;\n    return 0;\n}\n```\n\n\n\n## new 和 delete\n\n### 为什么要有new和delete？\n\n会调用构造函数和析构函数\n\n\n\n### new vs malloc\n\n和malloc不同的是，new返回的是有类型的指针，不用再强制类型转化；而malloc只返回void*\n\n而且new可以重载，用于更加精细化内存管理，例如内存池模式\n\n\n\n### 调用重载构造函数\n\nnew默认调用默认构造函数，如果要调用其他构造函数，要写成：\n\n```c++\nA p = new A(1);\n```\n\n\n\nnew也可以用于内置基本类型\n\n\n\n###动态数组\n\n如果new申请的是一个数组，直接调用delete p而不是delete p[]，那么只会释放掉第一个对象的空间\n\ndelete void*会释放空间，因为分配的空间是和指针存放在一起的，但是不会调用析构函数\n\ndelete之后最好赋值成nullptr，可以防止二次delete（啥都不做）\n\n```c++\nclass A{\npublic:\n    A(){ cout << \"A's default constructor\" << endl; }\n    A(int i){ cout << \"A's int\" << endl; }\n    ~A(){ cout << \"A's de-constructor\" << endl; }\n};\n\nint main(){\n    A *p = new A[10]{1};  // 调用1次带有参数的构造函数和9次默认的构造函数，且只能调用默认构造函数\n    cout << p << endl;\n    cout << &p[0] << endl;\n    // delete p;  // 只调用一个析构函数，然后再调用delete []p会报错\n    delete []p;  // 调用10个析构函数，且是逆序delete的\n\n    void* vp = new A;\n    delete vp;  // 会有编译警告，且不会调用析构函数\n    return 0;\n}\n```\n\n\n\n## const成员函数\n\n实际上是this参数变为\n\n```c++\nvoid show(cosnt A* const this);\n```\n\nmutable关键字强调是可变的，因此可以在const成员函数里面修改mutable标记的变量\n\n```c++\n/*\n本质上是函数的参数变为了 const A* const this\n\n注意const重载的时候\n自身是否是const不会重载\n只有指向的是const还是非const才会构成重载\n类的const成员函数就会构成这样的重载\n*/\nclass A{\npublic:\n    int x,y;\n    int &indirect_int;\n    mutable int m;\n    A(int x1, int y1):indirect_int(*new int){};\n    void f();\n    // 非const和const形成了重载\n    void show() const;\n    void show();\n};\n\nvoid A::f(){\n    x = 1;\n    y = 1;\n}\n\n// 一定要写明到底有没有const\nvoid A::show(){\n    cout << \"Not const\" << endl;\n}\n\n// 一定要写明到底有没有const\nvoid A::show() const {\n    // 注意不能修改变量的值\n    // x = 1;\n    // 引用特殊，实际上引用就是const，修改的是引用指向的值\n    // 事实上不存在const &，没有意义\n    indirect_int = 1;\n    // 标记为mutable的变量永远可修改\n    m = 1;\n    cout << \"Const\" << endl;\n}\n\nint main(){\n    A a(0,0);\n    // 调用的是非const的方法\n    a.show();\n\n    const A ca(0,0);\n\n    // const对象不能调用非const的方法\n    // ca.f();\n    ca.show();\n\n    return 0;\n}\n```\n\n\n\n## 静态成员\n\n同一个类的不同对象如何共享变量？\n\n- 如果把这些共享变量定义为全局变量，则缺乏数据保护\n\n- 名污染\n\n使用static成员可以解决这个问题\n\n\n\n头文件中只是声明静态成员变量，因此不会调用静态成员变量的构造函数\n\nstatic变量初始化：\n\n```c++\n/*\n引用、常量、静态\n\n引用和常量必须在初始化列表中初始化\n静态成员变量在类外初始化且不能再带有static关键字\n*/\nclass A{\npublic:\n    // 静态成员不能在类内部初始化\n    // static int a = 0;\n    static int o;\n\n    // 但是静态的常量可以在类内初始化\n    const static int a = 0;\n    const static int b;\n};\n\nconst int A::b = 1;\n\nint A::o = 0;\n\n\nint main(){\n    A a;\n    // const static 如果直接在类内给出值，那么用到的时候是作为常量直接替换，不会分配存储空间\n    // cout << &a.a << endl;\n    // 只有在类外定义才会有存储空间\n    cout << &a.b << endl;\n    return 0;\n}\n```\n\n\n\n## 友元\n\n### 为什么要有友元？\n\n相对于c引入了访问权限，不能访问private成员，只能通过public方法，但是这会降低效率。既要有访问控制，又要有访问效率，因此就引入了友元，使得声明成友元的类或者方法可以直接使用该类的private成员\n\n\n\n友元可以访问私有成员和私有方法\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass B{\npublic:\n    void g();\n};\n\nclass A{\nprivate:\n    int a;\n    void f(){cout << \"A's f()\" << endl;}\n    friend class B;\n};\n\nvoid B::g(){\n    A a;\n    // 友元类的成员函数可以调用私有方法\n    a.f();\n    // 友元类的成员函数可以调用私有成员\n    cout << a.a << endl;\n};\n\nint main(){\n    B b;\n    b.g();\n    return 0;\n}\n```\n\n\n\n### 不完全声明\n\n下面这个例子不能通过编译，因为看不到Vector的声明\n\n编译器要提前计算每个数据的大小，由于引用或者指针都是一样大的，因此编译器只要知道类型的确存在就行了，所以只要写 class Vector; 就可以通过编译\n\n注意这里是因为是引用或者指针才能用不完全声明来解决，如果要用到具体类型的成员方法或者成员变量，还是要看到具体的完全声明。因此如果是两个友元类的方法互相声明，那将无法解决\n\n```c++\nclass Matrix\n\t\t{    ......\n \t\t     friend void multiply(Matrix &m, Vector &v, Vector &r);\n\t\t};\nclass Vector\n{    ......\n  \tfriend void multiply(Matrix &m, Vector &v, Vector &r);\n};\n\n```\n\n\n\n\n\n友元不具有传递性，也和继承体系无关\n\n\n\n## 继承\n\n### 访问权限\n\nprotected：外部访问不到，子类能访问；子类的友元也访问不到，只能通过子类来访问\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\nprotected:\n    void func1(){\n        cout << \"A's func1\" << endl;\n    }\n};\n\nclass B: public A{\npublic:  \n    // 子类中可以直接通过A来调用protected\n    void func2(){\n        A::func1();\n    }\n    // 不能通过A类型的对象来调用protected\n    void fg(A a){\n        // a.func1();\n    }\n    // 在B类中可以使用B对象的protected\n    void g(B b){\n        b.func1();\n    }\n    friend void gg();\n};\n\nvoid gg(){\n    // 在友元中可以通过子类来使用protected\n    B b;\n    b.func1();\n    // 友元中不能直接通过A来调用protected\n    // A::func1();\n}\n\nint main(){\n    B b;\n    // 在B类的外部无法使用protected\n    // b.func1();\n    return 0;\n}\n```\n\n\n\n### 继承权限\n\n不管是哪一种权限，对自己的类没有影响\n\n如果写成private，那么相当于把父类的public和protected改成自己的private\n\n因此如果是private，那么它的子类啥都使用不了\n\n如果是pretocted，就是把父类中的public变成自己的protected\n\n默认是private，一般情况下没有意义\n\n\n\n私有继承目的是复用基类的数据和方法，类似于组合，但是可以重载virtual function，更加灵活一点\n\n私有继承而且还可以节省派生对象的大小，如果私有继承的子类没有成员函数，那么大小是0，组合的话还有一个组合对象的指针\n\n注意私有继承在设计上没有意义，只是实现上复用方法以及节省空间\n\n在设计上没有意义是因为私有继承和protected继承不能转化成基类\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    virtual void func1(){\n        cout << \"A's func1\" << endl;\n    }\n};\n\nclass B: public A{\nprivate:  \n    virtual void func1(){\n        cout << \"B's func1\" << endl;\n    }\n};\n\nint main(){\n    // 有两点需要注意\n    // 1. 如果在某个时刻，通过B的对象不能访问A的公有方法，那么此时B不能转化成A，指针和引用也不行\n    // 2. 一旦B的某个形式可以转化成A，那么即使在B中为private，只要它是虚函数，通过A都可以访问到这个函数（编译器期间确定访问权限）\n    A* a = new B;\n    a -> func1();\n    return 0;\n}\n```\n\n\n\n\n\n### 不完全声明\n\n```c++\n//错误声明\nClass Undergraduated_Student:public Student;\n//正确声明\nClass Undergraduated_Student;\n// 不完全声明不需要指出继承关系\n```\n\n\n\n### 继承成员\n\n如果子类中有同名的变量或者方法，会直接覆盖掉父类的\n\n如果要保留父类的，那么要写明 A::f 或者 using A::f\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Father{\npublic:\n    void f(){cout << \"Father f()\" << endl;}\n    void f(int){cout << \"Father f(int)\" << endl;}\n};\n\nclass Son:public Father{\npublic:\n    using Father::f;\n    void f(){cout << \"Son f()\" << endl;}\n};\n\n\nint main(){\n    Son s;\n    s.f();\n    // 使用了using就可以继承父类的所有同名方法了\n    // 只会覆盖掉其中子类自定义的版本\n    s.f(1);\n    return 0;\n}\n```\n\nusing可以改变默认的访问权限\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    void f(int){cout << \"A's f(int)\"<<endl;}\n};\n\nclass B:private A{\npublic:\n    // using 可以让private继承而来的函数变成public\n    using A::f;\n    void f(){cout << \"B's f()\"<<endl;}\n};\n\nint main(){\n    B b;\n    b.f(1);\n    return 0;\n}\n```\n\n对构造函数的处理特殊，见下\n\n\n\n### 构造函数调用顺序\n\n单继承：\n\n从上往下调用构造函数\n\n从下往上调用析构函数\n\n\n\n### 继承构造函数\n\n类不能继承默认、拷贝和移动构造函数，因为编译器会为派生类合成默认的\n\n和\"继承\"别的函数一样，使用using即可，不过using完了之后，其他函数是直接照搬过来，但是对于构造函数，编译器会稍作修改\n\n![image](https://s2.ax1x.com/2019/12/18/QTqAUJ.png)\n\n还有一个区别就是，普通函数的using可以改变访问级别，例如我在private里面using，那么\"继承\"下来的函数就会是private的，但不是构造函数不一样，基类的私有构造函数在派生类中还是一个私有构造函数，而不管using出现在哪\n\n\n\n![image](https://s2.ax1x.com/2019/12/18/QTqBVg.png)\n\n![image](https://s2.ax1x.com/2019/12/18/QTqIIJ.png)\n\n\n\n事实上，如果有private版本的重载函数（非构造函数），那么不能使用using\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\nprivate:\n    A(int){}\n    void f(int){cout << \"A's f(int)\"<< endl;}\npublic:\n    A(){}\n    void f(){cout << \"A's f()\" << endl;}\n};\n\nclass B:public A{\npublic:\n    // 如果有重载的版本为private的，那么不能继承，编译报错\n    // 构造函数例外，编译不会报错，只是不会改变访问权限，仍然是private\n    // using A::f;\n    using A::A;\n    void f(){cout << \"B's f()\"<<endl;}\n};\n\nint main(){\n    B b;\n    b.f();\n    return 0;\n}\n```\n\n\n\n\n\n## 虚函数\n\n### 赋值相容，类型相容\n\n可以通过=赋值的就是赋值相容的，例如可以把子类对象赋值给父类，对象切片，对象的身份发生了变化\n\n类型相容是指保留了派生类的类型，例如通过指针或者引用来将派生类赋值给基类\n\n\n\n### 前期绑定vs后期绑定\n\n前期绑定\n\n- 编译时刻\n- 依据对象的静态类型\n- 效率高、灵活性差\n\n动态绑定：\n\n- 运行时刻\n- 依据对象的实际类型（动态）\n- 灵活性高、效率低\n\nc++注重效率，因此默认前期绑定，后期绑定需要显式指出(virtual)\n\n\n\n### 限制\n\n- 累的成员函数才可以是虚函数\n- 静态成员函数不能是虚函数\n- 内联成员函数不能是虚函数\n- 构造函数不能是虚函数\n- 析构函数可以（往往）是虚函数\n\n**虚函数一定要有实现！！！纯虚函数例外**\n\n\n\n### 虚析构函数\n\n如果析构函数不是虚函数，那么派生对象得到的资源可能不会被释放\n所以析构函数应该定义成虚函数\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    int a;\n    ~A(){\n        cout << \"A's de-constructor\" << endl;\n    }\n    A(){}\n    A(const A& a){\n        cout << \"A's copy function\" << endl;\n    }\n};\n\nclass B:public A{\n    int b;\npublic:\n    ~B(){\n        cout << \"B's de-constructor\" << endl;\n    }\n    B(){}\n    B(const B& b){\n        cout << \"B's copy function\" << endl;\n    }\n};\n\n// 析构函数也会层层调用\n// 调用如下函数，函数退出的时候\n// 会依次调用B的析构函数和A的析构函数\nvoid func(){\n    B b;\n    return;\n}\n\nint main(){\n    A* a = new B;\n    // 如果析构函数非虚，那么只会调用A的析构函数\n    delete a;\n    func();\n    return 0;\n}\n```\n\n\n\n### 原理\n\n维护一张虚函数表\n\n因此对对象做sizeof，除了成员变量的大小之外，还有虚函数表的指针大小\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\n    virtual void f(){}\n};\n\nclass B:A{\n    int a;\n};\n\nint main(){\n    B b;\n    // 大小比没有虚函数的大\n    cout << sizeof(b) << endl;\n    return 0;\n}\n```\n\n\n\n### 到底调用哪个版本\n\n**根据静态类型看能否调用；如果是virtual，且是通过指针和引用调用，根据动态类型找到调用哪个版本**\n\n\n\n非虚调虚，行为变化（非虚接口）\n\n虚调非虚，行为不变\n\n注意如果是非指针的对象调用非虚函数，里面又调用了虚函数，仍然可以动态绑定。因为方法默认第一参数为*this是一个指针（非虚接口）\n\n\n\n例子：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Father{\npublic:\n    void f(){cout << \"father's f()\" << endl;}\n    void f(int a){cout << \"father's f(int)\" << endl;}\n    virtual void g() {cout << \"father's g()\" << endl;}\n};\n\nclass Son:public Father{\npublic:\n    void f(){cout << \"son's f()\" << endl;}\n    void g() {cout << \"son's g()\" << endl;}\n};\n\nint main(){\n    // 调用非虚函数，调用的都是父类的\n    // 只有虚函数会动态调用到子类的\n    Father *f = new Son;\n    f->f(1);\n    f->f();\n\n    // 如果不是指针，那么即使是虚函数也不会动态调用\n    Father ff = Son();\n    ff.g();\n    return 0;\n}\n```\n\n\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Father{\npublic:\n    virtual void f(){\n        cout << \"Father: f()\"<<endl;\n        g();\n    }\n    void f(int a){cout << \"Father: f2(int a)\"<<endl;}\n    virtual void g(){cout << \"Father: g()\"<<endl;}\n\n    void nvf(){\n        cout << \"Father: nvf()\" << endl;\n        g();\n    }\n};\n\nclass Son:public Father{\npublic:\n    // using Father::f;\n    void f(){\n        cout << \"Son: f()\"<<endl;\n        g();\n    }\n\n    void g(){\n        cout << \"Son: g()\"<<endl;\n    }\n};\n\nint main(){\n    // 虚函数调用非虚函数和虚函数的行为都是一致的\n    // 前提是子类没有同名的非虚函数\n    Father *f = new Son;\n    // 会调用子类的g()\n    // 无论此时g是否是virtual\n    f->f();\n    cout << endl;\n\n    Father *ff = new Father;\n    ff->f();\n    // 会调用父类的g()\n    // 无论此时g是否是virtual\n    cout << endl;\n\n\n\n    // 非虚函数调用虚函数和非虚函数是有区别的\n    // 这也是模版方法的实现基础\n    // 这时候如果g是virtual，那么可以调用到子类的g()\n    // 否则调用的是父类的g\n    f->nvf();\n    cout << endl;\n\n\n\n\n    // 如果不是指针，那么只能调用父类的方法，与virtual无关\n    Father f2 = Son();\n    f2.f();\n    cout << endl;\n\n    Son s;\n    // virtual与redefined无关\n    // 如果有同名方法仍旧会被覆盖\n    // 需要使用using\n    // s.f(2);\n    return 0;\n}\n```\n\n\n\n特别注意下面这个例子，权限检查是静态时完成的，一旦静态类型检查通过，运行时就会动态调用：\n\nhttps://www.zhihu.com/question/22526510\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    virtual void f(){cout << \"A's f()\" << endl;}\n};\n\nclass B:public A{\nprivate:\n    void f(){cout << \"B's f()\" << endl;}\n};\n\nint main(){\n    A* a = new B;\n    // 仍然可以调用B的私有方法\n    // 权限检查是静态编译过程中就确定了的\n    a -> f();\n    return 0;\n}\n```\n\n\n\n\n\n### 构造函数和析构函数中调用虚函数\n\n不会有虚函数的特性，构造和析构到哪一步，调用那一步类型的对应函数\n\n\n\n构造函数中B（子类）的虚函数表还没构造\n\n因此调用的还是A（父类）的f\n\n也可以理解成B还没构造完的时候，仍然是A对象\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    A(){f();}\n    virtual void f(){cout << \"A's f()\"<<endl;}\n    virtual ~A(){f();}\n};\n\nclass B:public A{\npublic:\n    void f(){cout << \"B's f()\"<<endl;}\n};\n\nint main(){\n    // 无论是构造过程还是析构过程\n    // 调用的都是A的f()\n    // 因为到A的时候\n    // 1. B还没有构造\n    // 2. B已经析构\n    // 因此调用的都是A的f\n    B b;\n    return 0;\n}\n```\n\n\n\n\n\n### final && override\n\n见例子：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    virtual void f()final{}\n    void g(){}\n};\n\nclass B:public A{\npublic:\n    void g(int a){}\n};\n\n\n// 只有虚函数才能被定义为final\n// 不允许再被覆盖\nint main(){\n    A a;\n    return 0;\n}\n```\n\n```c++\n#include <iostream>\nusing namespace std;\n\nstruct A{};\nstruct C:A{};\n\nstruct B{\n    virtual void f1(int) const;\n    virtual A& fc();\n    virtual double fc2();\n    virtual void f2();\n    void f3();\n    // 非虚函数不能用final修饰\n    // void f5(int) final;\n\n    virtual void f5(int) final;\n};\n\nstruct D:B{\n    // 正确\n    void f1(int) const override;\n\n    // 错误，virtual重载的返回类型也要一致\n    // int f1(int) const override;\n\n    // 正确，虽然要求返回值相同\n    // 但是协变也是可以的\n    // https://blog.csdn.net/gjggj/article/details/72626794\n    C& fc()override;\n    // 基本类型没有协变\n    // int fc2()override;\n\n\n    // 错误，因为没有重载任何函数\n    // 因为不是const\n    // void f1(int) override;\n\n\n    // 下面这是重写的f1，而不是重载\n    void f1(int);\n\n\n    // 错误，没有重载任何函数\n    // void f2(int) override;\n\n    // 错误，f3不是virtual修饰，不能重载\n    // 只能重写\n    // void f3() override;\n\n    // 因为f5是final，因此不能重载\n    // void f5(int);\n};\n\nint main(){\n    return 0;\n}\n```\n\n另外注意，如果子类中没有virtual，那么调用的还是父类的版本\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass B{\npublic:    \n    virtual void f1(){ cout << \"father's f1()\" << endl; };\n};\n\nclass D:public B{\npublic:\n    void f1(int){ cout << \"son's f1()\" << endl; };\n};\n\nint main(){\n    B *b = new D;\n    b -> f1();\n    return 0;\n}\n```\n\n\n\n### 纯虚函数\n\n纯虚函数也可以有实现，但是不能是在类中实现，只能写在类外\n\n有默认实现的纯虚函数仍然不能实例化，派生类仍然需要重写\n\n可以显式调用纯虚函数的默认实现\n\n抽象类不能被实例化，因此抽象类作为接口的时候，只能传递指针和引用，不会有对象切片的问题\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    virtual void func1()=0;\n    // 纯虚函数不能直接写inline实现\n    // {\n    //     cout << \"default A func1\" << endl;\n    // }\n\n    void func2()\n    {\n        // 普通函数或普通虚函数可以直接写inline实现\n        cout << \"default A func2\" << endl;\n    }\n};\n\n// 纯虚函数可以有实现，但是实现只能在类定义的外部，不能inline\nvoid A::func1(){\n    // 纯虚函数即使有默认实现，派生类仍然需要重写该方法\n    cout << \"default A func1\" << endl;\n}\n\nclass B: public A{\npublic:    \n    void func1(){\n        // 这样就可以调用纯虚函数的默认实现了\n        A::func1();\n        cout << \"B func1\" << endl;\n    }\n};\n\nint main(){\n    B b;\n    b.func1();\n    b.func2();\n    return 0;\n}\n```\n\n\n\n### 虚函数的默认参数\n\n默认参数静态绑定，如果是动态绑定，那么调用的时候还要再查找一次默认参数的值\n这样就要查表两次（找虚函数一次，找默认参数）效率低，因此编译的时候直接用值来替换默认参数，即对象中只记录虚函数的入口地址\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    virtual void f(int a = 0) { cout << \"A's f() \" << a << endl;}\n};\n\nclass B:public A{\npublic:\n    void f(int a = 1) { cout << \"B's f() \" << a << endl;}\n};\n\nclass C:public A{\npublic:\n    void f(int a) { cout << \"C's f() \" << a << endl;}\n};\n\nint main(){\n    // 默认参数静态绑定\n    // 下面全都是打印0\n    A *p_a;\n    B b;\n    p_a = &b;\n    p_a -> f();\n\n    A *p_a1;\n    C c;\n    p_a1 = &c;\n    p_a1 -> f();\n    return 0;\n}\n```\n\n\n\n## 多继承\n\n**非虚直线继承(单继承)**\n\nB继承A，C继承B，那么C可以使用A中的成员变量和方法，但是不允许直接调用A的构造函数，**即只能负责直接基类的构造函数调用**\n\n构造函数调用顺序为：\n\n对C实例化，要先实例化B，要先实例化A\n\n因此可以看到下面的输出为：\n\nA's int a 2\nB's int a 1\nC's int a 0326696997（无意义的值）\nA's f()（这个是在C的构造方法里面调用的A的f）\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\nprotected:\n    int a;\npublic:\n    A(){}\n    A(int a){cout << \"A's int a \" << a << endl;}\n    void f(){cout << \"A's f()\" << endl;};\n};\n\nclass B:public A{\npublic:\n    B(){}\n    B(int a):A(2){cout << \"B's int a \" << a << endl;}\n};\n\nclass C:public B{\npublic:\n    C(){}\n    // 可以这样使用间接非虚拟基类的可访问的成员变量和成员方法（但是不能直接调用构造方法）\n    C(int a):B(1){cout << \"C's int a \" << a << A::a << endl;A::f();}\n    // 不允许使用间接非虚拟基类的构造函数\n    // C(int a):A(1){cout << \"C's int a\" << endl;}\n};\n\nint main(){\n    // 构造函数层层调用\n    C c(0);\n    return 0;\n}\n```\n\n\n\n**非虚菱形继承**\n\n构造函数的调用顺序为派生列表中基类的出现顺序保持一致\n\n如果有同名变量要加上基类类型\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    int a;\n    A(){}\n    A(int a):a(a){cout << \"A's int a \" << a << endl;}\n};\n\nclass B:public A{\npublic:\n    B(){}\n    B(int a):A(2){cout << \"B's int a \" << a << endl;}\n};\n\nclass C:public A{\npublic:\n    C(){}\n    C(int a):A(1){cout << \"C's int a \" << a << endl;}\n};\n\nclass D:public C, public B{\npublic:\n    D(){}\n    // 可以通过::来访问不同父类中的同名变量\n    // 该同名变量可能是父类自身的，也可能是父类继承而来的\n    D(int a):B(1),C(2){cout << \"D's int a in B is \" << B::a << endl;}\n};\n\nint main(){\n    // 构造函数层层调用\n    // 顺序为派生类的继承列表顺序\n    // 且此时因为B和C是非虚继承\n    // 因此A会初始化两次\n    D d(0);\n    // D中的a不明确，二义性\n    // cout << d.a << endl;\n    // 正确的是要加上明确的父类\n    cout << d.B::a << endl;\n    return 0;\n}\n```\n\n构造函数和析构函数的调用顺序\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    int a;\n    A(){}\n    A(int a):a(a){cout << \"A's constructor\" << endl;}\n    ~A(){cout << \"A's deconstructor\" << endl;}\n};\n\nclass B:public A{\npublic:\n    B(){}\n    B(int a):A(2){cout << \"B's constructor\" << endl;}\n    ~B(){cout << \"B's deconstructor\" << endl;}\n};\n\nclass C:public A{\npublic:\n    C(){}\n    C(int a):A(1){cout << \"C's constructor\" << endl;}\n    ~C(){cout << \"C's deconstructor\" << endl;}\n};\n\nclass D:public C, public B{\npublic:\n    D(){}\n    D(int a):B(1),C(2){cout << \"D's constructor\" << endl;}\n    ~D(){cout << \"D's deconstructor\" << endl;}\n};\n\nint main(){\n    // 构造函数层层调用\n    // 顺序为派生类的继承列表顺序\n    // 且此时因为B和C是非虚继承\n    // 因此A会初始化两次\n    // 析构函数是相反的顺序\n    D d(0);\n    return 0;\n}\n```\n\n\n\n**虚基类**\n\n如果直接基类有公共的基类，则该公共基类中的成员变量，在多继承的派生类中有多个副本，**为了消除这种多副本的情况，使用虚基类**\n\n下面这两种都行：\n\n```c++\nclass A;\nclass B:virtual public A;\nclass C:public virtual A;\nclass D:B, C;\n```\n\n显然，整体设计好了之后才会知道哪些需要虚继承\n\nis a关系变为has a关系，没有拷贝，B和C中只是有指向同一个A对象的指针，在没有实例化D时，虚基类不会构造，**虚基类的构造函数是由最新派生出的类（D）的构造函数来调用的（其他类对该基类的构造函数调用完全不起作用），且虚基类的构造函数优先非虚基类的构造函数执行**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\nprotected:\n    int a;\npublic:\n    A(){}\n    A(int a):a(a){cout << \"A's int a \" << a << endl;}\n};\n\nclass B:virtual public A{\nprotected:    \n\npublic:\n    B(){}\n    // 此时B不会调用A的构造函数\n    B(int a):A(2){cout << \"B's int a \" << a << endl;}\n    void f(){cout << \"B's f()\" << A::a << endl;}\n};\n\nclass C:virtual public A{\nprotected:\n    int a;\npublic:\n    C(){}\n    // 此时C不会调用A的构造函数\n    C(int a):A(1){cout << \"C's int a \" << a << endl;}\n    void f(){cout << \"C's f()\" << A::a << endl;}\n};\n\nclass D:public C, public B{\nprotected:\n    int a;\npublic:\n    D(){}\n    // 如果使用了虚继承，那么初始化A的责任就交到了D身上\n    // 如果D没有调用A的构造函数，那么A不会被初始化，此时B::a因为是继承自A的，那么将会是任意值\n    // 如果D指明调用A的构造函数，那么无论A在初始化列表中的位置如何，永远优先调用A的构造函数\n    // B和C对于A的初始化完全没有作用\n    D(int a):B(1),C(2),A(100){cout << \"D's int a \" << a << endl;}\n    // 可以使用A::a来访问A的成员变量和方法\n    // 如果存在vitual和非virtual，或者两个非virtual继承，那么都认为同名的变量或者方法是不明确的，不能使用A::a\n    void f(){cout << \"D's f()\" << A::a << endl; B::f(); C::f();}\n};\n\nint main(){\n    D d(0);\n    // B和C公用同一个A，持有指向同一个a对象的指针\n    d.f();\n    return 0;\n}\n```\n\n输出：\n\n```c++\nA's int a 100\nC's int a 2\nB's int a 1\nD's int a 0\nD's f()100\nB's f()100\nC's f()100\n```\n\n\n\n**虚继承和非虚继承同时存在**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\nprotected:\n    int a;\npublic:\n    A(){}\n    A(int a):a(a){cout << \"A's int a \" << a << endl;}\n};\n\nclass B:virtual public A{\nprotected:    \n\npublic:\n    B(){}\n    // 此时B不会调用A的构造函数\n    B(int a):A(2){cout << \"B's int a \" << a << endl;}\n    void f(){cout << \"B's f()\" << A::a << endl;}\n};\n\nclass C:virtual public A{\nprotected:\n    int a;\npublic:\n    C(){}\n    // 此时C不会调用A的构造函数\n    C(int a):A(1){cout << \"C's int a \" << a << endl;}\n    void f(){cout << \"C's f()\" << A::a << endl;}\n};\n\nclass E:public A{\nprotected:\n    int a;\npublic:\n    E(){}\n    E(int a):A(1000){cout << \"E's int a \" << a << endl;}\n    void f(){cout << \"E's f()\" << A::a << endl;}\n};\n\nclass D:public E,public C, public B{\nprotected:\n    int a;\npublic:\n    D(){}\n    // 虚基类的构造函数优先非虚基类的构造函数执行\n    D(int a):B(1),C(2),E(3),A(100){cout << \"D's int a \" << a << B::a << endl;}\n    void f(){cout << \"D's f()\" << endl; B::f(); C::f();E::f();}\n};\n\nint main(){\n    D d(0);\n    // B和C公用同一个A，持用指向同一个a对象的指针，且和D中的相同\n    // E有自己的A\n    d.f();\n    return 0;\n}\n```\n\n输出为\n\n```c++\nA's int a 100\nA's int a 1000\nE's int a 3\nC's int a 2\nB's int a 1\nD's int a 0100\nD's f()\nB's f()100\nC's f()100\nE's f()1000\n```\n\n\n\n### 小结和补充\n\n一个子类可以继承多个类，每一个继承都可以有自己的继承方式，成员变量的情况和单继承一样，只不过是多个\n\n多继承的构造函数的调用顺序为派生列表中基类的出现顺序保持一致，且子类只能负责直接基类的构造函数调用（非虚继承的情况下）\n\n子类可以继承构造函数，但是如果继承而来的构造函数是一样的，那么就会出错，此时子类必须要有自定义版本的该构造函数\n\n![](https://s2.ax1x.com/2019/12/31/l1XQEt.png)\n\n\n\n**类型转化的二义性错误**\n\n![](https://s2.ax1x.com/2019/12/31/l1XT2D.png)\n\n\n\n**同名的变量或者方法的二义性错误**\n\n![](https://s2.ax1x.com/2019/12/31/l1jzwR.png)\n\n除非指明调用的版本\n\n```c++\ncout << d.B::a << endl;\n```\n\n\n\n**内存布局**\n\n![](https://s2.ax1x.com/2019/12/31/l3SY0H.png)\n\n","tags":["c++"],"categories":["c++"]},{"title":"设计模式-结构型模式","url":"/2019/12/24/设计模式-结构型模式/","content":"\n# 适配器模式\n\n当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作\n\n\n\n## 定义\n\n适配器模式(Adapter Pattern) :将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。\n\n适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。\n\n\n\n## 类图\n\n分为两种\n\n![image](https://s2.ax1x.com/2019/12/24/lPiuJx.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPiQSK.png)\n\n类适配器中Target是接口，因为Adapter继承Adaptee，单继承\n\n![image](https://s2.ax1x.com/2019/12/24/lPFmng.png)\n\n类适配器是通过继承的方式调用被适配的接口\n\n![image](https://s2.ax1x.com/2019/12/24/lPFMAs.png)\n\n而对象适配器则是通过关联一个被适配者的对象来实现的\n\n![image](https://s2.ax1x.com/2019/12/24/lPkCKU.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPkPrF.png)\n\n第三方模块是被适配者，原来的模块是目标类target，采用对象适配器模式类图如下\n\n![image](https://s2.ax1x.com/2019/12/24/lPkXLD.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPVdsK.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPVcRI.png)\n\n\n\n## 优点\n\n将目标类和适配者类解耦\n\n增加了类的透明性和复用性\n\n灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 \n\n\n\n\n\n## 类适配器vs对象适配器\n\n由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 \n\n对于类适配器来说，Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类（因为有的方法没有实现，因此不能让它实例化）， 不能为具体类，其使用有一定的局限性，不能将一个适 配者类和它的子类都适配到目标接口。 \n\n一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。\n\n与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。\n\n\n\n具体选择哪一种，可以稍微写一下代码实现，从实现角度来考虑。\n\n类适配器用的多：猜测是因为有的时候适配需要修改一些父类的实现才能实现适配。\n\n类适配器一般是一对一的情况下使用。\n\n\n\n## 应用场景\n\n![image](https://s2.ax1x.com/2019/12/24/lPEtu8.png)\n\n总的来说有两条\n\n1. 修改接口。定义一个抽象，这个抽象是客户想要的接口，然后有一个实现，实现中调用另外的符合需求的接口\n2. 将两个类扭在一起\n\n\n\n## 模式扩展\n\n### 默认适配器\n\n当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式\n\nhttps://blog.csdn.net/IO_Field/article/details/52791975\n\n**本质就是绕过接口必须实现**这一规则\n\n\n\n### 双向适配器\n\n在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器。\n\n分析：只能用对象适配器模式，且两边都是，因此是一个对称的结构。且要有专门的方法set进适配者。在两个不同的方法中封装对于实现方法的调用\n\n![image](https://s2.ax1x.com/2019/12/24/lPZLhd.png)\n\n\n\n# 组合模式\n\n树形结构，递归调用，一致处理叶子节点和非叶子节点\n\n\n\n## 组合模式\n\n组合模式(Composite Pattern):组合多个对象形成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象(即叶子对象)和组合对象(即容器对象)的使用具有一致性。\n\n组合模式又可以称为“整体-部分”(Part-Whole)模式，属于对象的结构模式，它将对象组织到树结构中，可以用来描述整体与部分的关系。\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lPutuq.png)\n\n由于要叶子和非叶子要相同对待，那么就要继承自统一的接口。其中如果是非叶子节点，那么还要聚合这个接口\n\n对于叶子节点来说，有三个方法都是不能有实现的，因此：\n\n![image](https://s2.ax1x.com/2019/12/24/lPKBeP.png)\n\n**透明性往往是要牺牲安全性**\n\n**这里的叶子节点的三个方法都是要抛出异常的，不是可以调用的方法**\n\n\n\n同时注意非叶子节点中的operation代码，需要遍历列表调用：\n\n![image](https://s2.ax1x.com/2019/12/24/lPKgzj.png)\n\n**因为组合是递归的，是一次性调用下去的，是内部遍历**\n\n**如果需要迭代器，那么是一个外部遍历，要额外维护一个栈或者队列来记录当前访问到哪一个元素**\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPK4e0.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPMY7V.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPMY7V.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPM5jA.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPQ9H0.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPQtKA.png)\n\n\n\n## 优点\n\n可以清楚地定义分层次的复杂对象 \n\n客户端可以一致的使用组合结构或其中单个对象 \n\n定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可 以形成复杂的树形结构\n\n更容易在组合体内加入对象构件（例如上面的例子中新增一个新的文件类型）\n\n\n\n## 缺点\n\n使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联\n\n增加新构件时可能会产生一些问题，很难对容器中的构件类型进行限制。 \n\n\n\n## 应用场景\n\n需要表示一个对象整体或部分层次\n\n一致对待整体和部分\n\n客户端可以针对抽象构件编程，无须关心对象层次结构的细节\n\n对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们\n\n\n\n## 模式扩展\n\n### 透明组合模式和安全组合模式\n\n所谓的透明，是对于客户端来说透明，及叶子节点和非叶子节点没有任何区别，这样接口固定，但是必然导致叶子节点有多余的方法，这样就不安全\n\n所谓安全，及叶子节点只有operation方法，而非叶子节点有增加删除的方法，接口只有operation，这样会保证不会进行非法操作，但是要判断是叶子节点还是非叶子节点，这样就不透明了\n\n![image](https://s2.ax1x.com/2019/12/24/lPQbrR.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPlnzQ.png)\n\n即：\n\n透明模式：对待叶子节点和非叶子节点一样，所有的接口方法都可以调用\n\n安全模式：调用前要先判断一下是什么类型再调用其方法\n\n**透明性往往是要牺牲安全性**\n\n**透明模式中叶子节点的三个方法都是要抛出异常的，不是可以调用的方法**\n\n\n\n## 桥接模式\n\n两个变化维度，例如形状和颜色，需要进行组合，如果采用继承，那么产生的类的数量是乘积关系；而如果采用组合，那么类的数量是相加的关系\n\n继承：静态的强耦合\n\n组合：动态的弱耦合\n\n\n\n## 定义\n\n桥接模式(Bridge Pattern):将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式。\n\n又称为柄体(Handle and Body)模式或接口(Interface)模式。\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lP3qqs.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPYYJx.png)\n\n\n\n## 分析\n\n![image](https://s2.ax1x.com/2019/12/24/lP8eJK.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPYrTA.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPYTkn.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPYvm4.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPYz79.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPNoR0.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPNHMT.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPU8oj.png)\n\n\n\n## 优点\n\n分离抽象接口及其实现部分\n\n桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则(即一个类只有一个变化的原因)，复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法\n\n![image](https://s2.ax1x.com/2019/12/24/lPtw90.png)\n\n提高了系统的可扩充性\n\n实现细节对客户透明，可以对用户隐藏实现细节\n\n\n\n## 缺点\n\n增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程\n\n桥接模式要求正确识别出系统中两个独立变化的维度， 因此其使用范围具有一定的局限性 \n\n\n\n## 应用场景\n\n总结来说有两个方面：\n\n1. 两个变化维度\n2. 抽象和实现分离\n\n\n\n需要在构件的抽象化角色和具体化角色之间增加更多的灵活性， 避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系 \n\n抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响 \n\n一个类存在两个独立变化的维度 \n\n不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系 统 \n\n\n\n## 模式联用\n\n![image](https://s2.ax1x.com/2019/12/24/lPae74.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPa3jK.png)\n\n\n\n# 桥接模式vs命令模式\n\n参考：https://www.iteye.com/blog/c610367182-1965668\n\n不仅Implementor具有变化（ConcreteImplementor），而且Abstraction也可以发生变化（RefinedAbstraction），而且两者的变化是完全独立的，RefinedAbstraction与ConcreateImplementor之间松散耦合，它们仅仅通过Abstraction与Implementor之间的关系联系起来。强调Implementor接口仅提供基本操作，而Abstraction则基于这些基本操作定义更高层次的操作\n\n并不考虑Context的变化，只有算法的可替代性。强调Strategy抽象接口的提供的是一种算法，一般是无状态、无数据的，Context简单调用这些算法完成其操作\n\n\n\n# 装饰者模式\n\n对客户透明的方式动态地给一个对象附加上更多的责任\n\n在不需要创造更多子类的情况下，将对象的功能加以扩展\n\n\n\n## 定义\n\n装饰模式(Decorator Pattern) :动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。\n\n其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lPa2Nj.png)\n\n为什么正常的component和decorator不一样？\n\n从设计上来说，装饰者只是增加一个小职责，因此和正常的component就是不一样\n\n从调用上来说，层层调用，最内层必须要终止，因此也要区分开来\n\n\n\n是否破坏了Liskov替换原则\n\nconcreteDecoratorB，因addedBehavior是public的，因此是有可能破坏Liskov\n\n但是如果只是在operation里面调用的话则不会，例如concreteDecoratorA\n\n\n\n在抽象的Decorator中调用component的方法\n\n![image](https://s2.ax1x.com/2019/12/24/lPd3Ps.png)\n\n具体的Decorator中调用新增的方法\n\n![image](https://s2.ax1x.com/2019/12/24/lPdJx0.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPdhIH.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPdHQP.png)\n\n半透明\n\n如果只是使用move，那么就是透明的\n\n如果要使用robot里面新加的方法，就要了解当前的类型，因此是不透明的\n\n![image](https://s2.ax1x.com/2019/12/24/lPdzJs.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPwZFJ.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPwI7F.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPwHh9.png)\n\n\n\n## 优点\n\n装饰模式可以提供比继承更多的灵活性\n\n通过一种动态的方式来扩展一个对象的功能 \n\n通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合 \n\n具体构件类与具体装饰类可以独立变化 \n\n\n\n## 缺点\n\n装饰方法只能在正常对象前或者后调用，因此只能改变前置或者后置，而不能改变中间实现过程\n\n小对象太多，可以和工厂方法连用，用来创建小对象\n\n装饰模式比继承更加易于出错，排错也很困难，对于多次装饰 的对象，调试时寻找错误可能需要逐级排查，较为烦琐 \n\n\n\n## 模式扩展\n\n一个装饰类的接口必须与被装饰类的接口保持相同（实现透明性）\n\n不要把太多的逻辑和状态放在具体构件类中 ，而是通过装饰者来进行扩展\n\n如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类 \n\n![image](https://s2.ax1x.com/2019/12/24/lPwXX6.png)\n\n\n\n## 透明性与接口扩充\n\n如果想要扩充接口，就无法实现透明，如果要透明，就无法扩充接口\n\n![image](https://s2.ax1x.com/2019/12/24/lPwx0O.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lP0Vnf.png)\n\n\n\n## 应用场景\n\n以动态、透明的方式给单个对象添加职责\n\n当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时，例如继承会使得子类太多，或是final不能继承\n\n\n\n\n\n# 外观模式\n\n## 定义\n\n外观模式(Facade Pattern):外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n外观模式又称为门面模式，它是一种对象结构型模式\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lP0uNQ.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lP0XCj.png)\n\n\n\n## 分析\n\n![image](https://s2.ax1x.com/2019/12/24/lP06HO.png)\n\n外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能\n\n**外观模式并不提供抽象**\n\n![image](https://s2.ax1x.com/2019/12/24/lPBTzR.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lP0v2n.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPB9bT.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPBiaF.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPBNsP.png)\n\n\n\n## 优点\n\n对客户屏蔽子系统组件\n\n实现了子系统与客户之间的松耦合关系\n\n降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程\n\n只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类\n\n\n\n## 缺点\n\n不能很好地限制客户使用子系统类\n\n在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了\"开闭原则\"\n\n\n\n## 应用场景\n\n当要为一个复杂子系统提供一个简单接口时可以使用外观模式\n\n客户程序与多个子系统之间存在很大的依赖性\n\n在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度\n\n\n\n## 模式扩展\n\n![image](https://s2.ax1x.com/2019/12/24/lPBfdU.png)\n\n不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现\n\n### 抽象外观\n\n![image](https://s2.ax1x.com/2019/12/24/lPBbsx.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPDuSs.png)\n\n\n\n# 享元模式\n\n享元模式通过共享技术实现相同或相似对象的重用 \n\n\n\n## 定义\n\n享元模式(Flyweight Pattern):运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为**轻量级模式**，它是一种\n对象结构型模式。\n\n\n\n## 分析\n\n在享元模式中可以共享的相同内容称为内部状态(Intrinsic State)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的\n\n在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lPDBm6.png)\n\n注意这里内部状态是共享的，右下角的意思是：不共享的话内部和外部就不分了，都是私有成员\n\n根据代码可以看出来：\n\n享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象\n\n享元工厂是一个简单工厂\n\n![image](https://s2.ax1x.com/2019/12/24/lPDfXt.png)\n\n\n\n## 内部状态vs外部状态\n\n![image](https://s2.ax1x.com/2019/12/24/lPDTAS.png)\n\n需要特别强调的是：外部状态 — 客户端保存，比如颜色的前景和背景都是保存在客户端的。只有内部状态是成员属性\n\n![image](https://s2.ax1x.com/2019/12/24/lPD7tg.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPDxBV.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPDz7T.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPri9J.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPrAj1.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPrQ9H.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPrUUS.png)\n\n\n\n## 优点\n\n1. 共享\n2. 减少数量\n\n\n\n## 缺点\n\n1. 复杂，需要分离外部状态和内部状态\n2. 需要将某些状态外部化，使得运行时间变长\n\n\n\n## 应用场景\n\n有大量相同或者相似的对象\n\n应当在多次重复使用享元对象时才值得使用享元模式\n\n\n\n## 模式扩展\n\n### 单纯享元模式\n\n就是上面类图中的右下角，所有的享元对象都是可以共享的\n\n\n\n### 复合享元模式（和组合模式联用）\n\n![image](https://s2.ax1x.com/2019/12/24/lPr6bV.png)\n\n\n\n## 模式联用\n\n### 和静态工厂联用\n\n享元工厂是静态工厂\n\n\n\n### 和单例模式联用\n\n享元工厂是单例的\n\n\n\n### 和组合模式联用\n\n享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态，如上\n\n\n\n# 享元模式vs原型模式\n\n和原型模式的比较：原型是复制相同的，可以存储状态和备份等\n\n\n\n原型管理器 vs 享元工厂\n\n原型管理器只负责管理\n享元还负责创建\n原型管理器不一定要有\n但原型管理器是享元是模式的一部分\n\n\n\n\n\n# 代理模式\n\n通过引入一个新的对象(如小图片和远程代理对象)来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象\n\n\n\n## 定义\n\n代理模式(Proxy Pattern) :给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lPrxxA.png)\n\n代理对象和真实对象接口是一致的\n将任务委托给真实对象\n可以增加一些新的行为来控制对真实对象的访问(preRequest和postRequest)，如下\n\n![image](https://s2.ax1x.com/2019/12/24/lPsprt.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPsPVf.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPcbyd.png)\n\n\n\n![image](/Users/cengshaoxun/Library/Application Support/typora-user-images/image-20191224221400409.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPgAwq.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lP27qA.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lP2LIP.png)\n\n\n\n## 优点\n\n代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度\n\n\n\n## 缺点\n\n由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢\n\n实现代理模式需要额外的工作，有些代理模式的实现非常复杂（例如远程代理就非常复杂）\n\n\n\n## 模式扩展\n\n### 保护（Protect or Access）代理\n\n控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限\n\n该代理用于控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 见实例中的第一个例子\n\n\n\n### 远程（Remote）代理\n\n为一个位于不同的地址空间的对象提供一个本地的代理 对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中， 远程代理又叫做大使(Ambassador)\n\n\n远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求\n\n和保护模式和虚拟代理相比，远程代理和业务逻辑无关，因此其实可以放在类库里面复用\n\n![image](https://s2.ax1x.com/2019/12/24/lP208U.png)\n\n\n\n### 虚拟（Virtual）代理\n\n如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。虚拟代理模式是一种内存节省技术。在应用程序启动的时候，可以用代理对象代替真实对象初始化，节省了内存的占用，并大大加速了系统的启动时间\n\n虚拟代理通过使用一个小对象来代表一个大对象，可以 减少系统资源的消耗，对系统进行优化并提高运行速度 \n\n![image](https://s2.ax1x.com/2019/12/24/lP2fPK.png)","tags":["软件设计"],"categories":["软件设计"]},{"title":"设计模式--创建型模式","url":"/2019/12/22/设计模式-创建型模式/","content":"\n# 简单工厂模式\n\nSimple Factory Pattern\n\n又称为静态工厂方法 Static Factory Method\n\n属于类创建型模式：类来创建，不需要实例化出对象来创建\n\n在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类（创建的是具体类型，但是返回的还是抽象类型）\n\n\n\n## 类图\n\n三个角色：\n\n工厂角色\n\n抽象产品角色\n\n具体产品角色\n\n![image](https://s2.ax1x.com/2019/12/22/QzFLQJ.png)\n\n简单工厂代码\n\n![image](https://s2.ax1x.com/2019/12/22/QzkZwt.png)\n\n\n\n## 分析\n\n复杂性转移：整个程序的复杂性没有变化，只不过转移了\n\n将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。 \n\n工厂方法是静态方法，可以通过类名直接调用。\n\n可以将调用时所传入的参数写在配置文件中\n\n**简单工厂模式的要点在于:当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节**\n\n\n\n策略模式经常和工厂模式配合，因为要新建一个策略，通常可以通过工厂来管理\n\n模式的引入经常会增加对象的数量，因此工厂模式很容易和其他模式结合\n\n\n\n## 优点\n\n工厂类含有必要的判断逻辑，可以决定在什么时候创建 哪一个产品类的实例，客户端可以免除直接创建产品对 象的责任，而仅仅“消费”产品;简单工厂模式通过这种做法实现了**对责任的分割，它提供了专门的工厂类用于创建对象**。 \n\n客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名 ，通过**简单工厂模式可以减少使用者的记忆量。** \n\n通过引入**配置文件**，可以在不修改任何客户端代码的情 况下更换和增加新的具体产品类，在一定程度上提高了 系统的灵活性。 \n\n对于需要先创建一些xx，才能创建xx的情况，简单工厂提供了封装。\n\n\n\n## 缺点\n\n工厂类的职责相对过重。由于工厂类集中了所有产品创建逻辑，一旦不 能正常工作，整个系统都要受到影响。 具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性\n\n使用简单工厂模式将会增加系统中类的个数， 在一定程序上增加了系统的复杂度和理解难度 \n\n系统扩展困难，一旦添加新产品就不得不修改 工厂逻辑，在产品类型较多时，有可能造成工 厂逻辑过于复杂，不利于系统的扩展和维护。 \n\n简单工厂模式由于使用了静态工厂方法，造成 工厂角色无法形成基于继承的等级结构。 \n\n简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这违背了 “开闭原则”。\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QzkllQ.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QzkUYT.png)\n\n注意上面对于具体产品的关系是依赖（虚线表示）\n\n可以和代理模式结合起来\n\n![image](https://s2.ax1x.com/2019/12/22/Qzkj1g.png)\n\n\n\n在JDK类库中，日期时间类用到了简单工厂模式：\n\n![image](https://s2.ax1x.com/2019/12/22/QzAE3F.png)\n\n\n\n加密也可以使用简单工厂\n\n![image](https://s2.ax1x.com/2019/12/22/QzAZjJ.png)\n\n\n\n\n\n## 应用场景\n\n工厂类负责创建的对象比较少:由于**创建的对象较少**，不会造成工厂方法中的业务逻辑太过复杂。 \n\n客户端只知道传入工厂类的参数，**对于如何创建对象不关心**:客户端既不需要关心创建细节 ，甚至连类名都不需要记住，只需要知道类型 所对应的参数。 \n\n**变化比较少的情况**\n\n\n\n## 模式扩展\n\n![image](https://s2.ax1x.com/2019/12/22/QzAUHI.png)\n\n\n\n# 工厂方法模式\n\nFactory Method Pattern\n\n虚拟构造器 Virtual Constructor\n\n多态工厂 Polymorphic Factory\n\n类创建型模式\n\n我们先定义一个**抽象的按钮工厂类**，再定义**具体的工厂**类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在**不修改具体工厂类的情况下引进新的产品**，如果出现新的按钮类型，只需要为这种新类型的按钮**创建一个具体的工厂类**就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性\n\n\n\n## 分析\n\n不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给**专门的工厂子类**去完成\n\n在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作**延迟到工厂子类中完成**，即**通过工厂子类来确定究竟应该实例化哪一个具体产品类**\n\n具体化延迟：将具体化子类的实例化工作延迟到具体工厂来完成\n\n不是时间上的延迟，而是设计上的延迟\n\n\n\n**并不是解决简单工厂的if else的问题**，因为就算是工厂模式，具体的工厂仍然需要指明（可以把工厂方法看作是策略模式的应用，那么这个缺点其实就是策略模式的弊端）\n\n工厂方法**解决的是简单工厂增添产品需要大幅度修改的问题**\n\n工厂方法只需要增加具体的工厂就行，可修改性更好\n\n\n\n工厂方法模式退化后可以演变成简单工厂模式\n\n\n\n**为了提高系统的可扩展性和灵活性，在定义工厂和产品时都必须使用抽象层**\n\n\n\n工厂方法模式也是策略模式的一个体现。具体的工厂可以看成是一类策略，抽象的工厂就是策略的接口\n\n\n\n## 类图\n\n对比简单工厂，这里的类图增加了一个工厂父类\n\n![image](https://s2.ax1x.com/2019/12/22/QzEMrj.png)\n\n为了提高系统的可扩展性和灵活性，在定义工厂和产品时都必须使用抽象层\n\n客户端代码：\n\n![image](https://s2.ax1x.com/2019/12/22/QzEcRO.png)\n\n**工厂方法模式里面的具体工厂仍然可以接受参数，将不太会变化的放在一类工厂里面**\n\n一般将具体工厂类的实例化过程进行改进，不直接使用new关键字来创建对象，而是将具体类的类名写入配置文件中，再通过Java的反射机制，读取XML格式的配置文件，根据存储在XML文件中的类名字符串生成对象。\n\n\n\n## 补充：JAVA反射\n\n![image](https://s2.ax1x.com/2019/12/22/QzETFP.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QzEOyQ.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QzVCWT.png)\n\n客户端拥有两个抽象的父类，具体的工厂和具体的产品都是实现父类接口，然后由具体工厂创建具体产品\n\n![image](https://s2.ax1x.com/2019/12/22/QzVwp8.png)\n\n工厂方法模式也是策略模式的一个体现。具体的工厂可以看成是一类策略，抽象的工厂就是策略的接口\n\n\n\n## 优点\n\n用户只需要关心所需产品对应的工厂，**无须关心创建细节，甚至无须知道具体产品类的类名**。（这一点和简单工厂类似）\n\n基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它 能够使**工厂可以自主确定创建何种产品对象，而如何创建这个对象 的细节则完全封装在具体工厂内部**。工厂方法模式之所以又被称为 多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 \n\n使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修 改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而**只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”**（比简单工厂改进的地方） \n\n\n\n## 缺点\n\n需要编写新的具体产品类，而且**还要提供与之对应的具体工厂类**，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度\n\n增加了系统的抽象性和理解难度\n\n每种产品都是独立创建，无法在产品之间创建依赖关系，即无法生产一组互相依赖的产品\n\n\n\n## 应用场景\n\n一个类不知道它所需要的对象的类，只需要知道所对应的工厂即可\n\n将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。\n\n\n\n# 抽象工厂模式\n\n我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象\n\n\n\n产品等级结构:产品等级结构即产品的**继承结构**\n\n产品族:在抽象工厂模式中，**产品族是指由同一个工厂生产的 ，位于不同产品等级结构中的一组产品**\n\n产品等级结构和产品族：**纵向和横向关系**，产品族包含了多个产品等级结构的产品\n\n\n\n当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。\n\n工厂方法模式针对的是**一个产品等级结构**，而抽象工厂模式则需要面对**多个产品等级结构**\n\n\n\n抽象工厂模式(Abstract Factory Pattern):提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为**Kit模式**，属于对象创建型模式。\n\n\n\n## 类图\n\n对比于工厂方法模式，至少有两个抽象产品，一个具体的工厂和这些产品都有联系\n\n客户端持有抽象的工厂和所有抽象的产品\n\n![image](https://s2.ax1x.com/2019/12/22/QzmpFI.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QzmAOg.png)\n\n和上面的类图一模一样\n\n![image](https://s2.ax1x.com/2019/12/22/QzmQpV.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/22/Qzm3XF.png)\n\n这里的connection和statement是针对一个同一个系列的产品的，应该组合起来一起生产\n\n有两种数据库，对应的就是抽象的connection和statement有两种产品\n\n![image](https://s2.ax1x.com/2019/12/22/Qzmf9P.png)\n\n\n\n## 优点\n\n隔离了具体类的生成\n\n只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为\n\n增加新的具体工厂和产品族很方便，无须修改已有系统，符合“\n开闭原则”\n\n（以上都是工厂方法哦是就有的优点）\n\n能够保证客户端始终只使用同一个产品族中的对象（这个才是抽象工厂引入的目的）\n\n\n\n## 缺点\n\n在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品。\n\n因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。\n\n开闭原则的倾斜性（**增加新的工厂和产品族容易，增加新的产品等级结构麻烦**）\n\n1. 增加产品族:对于增加新的产品族，工厂方法模式很好的支持 了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工 厂即可，对已有代码无须做任何修改。 \n2. 增加新的产品等级结构:对于增加新的产品等级结构，需要修 改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生 产新产品的方法，不能很好地支持“开闭原则”。 \n\n\n\n## 应用场景\n\n一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的 \n\n系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。\n\n系统中有多于一个的产品族，而每次只使用其中某一产品族。\n\n属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。\n\n\n\n# 三个工厂模式的关系\n\n当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式\n\n当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式\n\n\n\n# 建造者模式\n\n复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。**由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里**，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机\n\n**外部化：把本来放在一起的职责分开创建对象的职责放到另一个对象中**\n\n\n\n## 定义\n\n建造者模式(Builder Pattern):将一个复杂对象的**构建**与它的**表示**分离，使得同样的构建过程可以创建不同的表示\n\n**表示：一个对象的不同内容**\n\n建造者模式是**一步一步创建一个复杂的对象**，它允许用户**只通过指定复杂对象的类型和内容**就可以构建它们，用户不需要知道内部的具体构建细节。\n\n对象创建型模式，又可称为生成器模式\n\n\n\n## 类图\n\n分成两大部分\n\nDirector负责封装创建过程（可以被复用）\n\nBuilder负责创建具体的每个部分（可以被多个指挥者复用；也可以被工厂方法代替，由工厂方法生产产品）\n\n**下面这个类图稍微有点问题，主要是Product和Builder的关系有点问题，详见实例第一题的图**\n\n![image](https://s2.ax1x.com/2019/12/22/Qzr9qe.png)\n\n其中Builder是一个抽象类，代码如下\n\n![image](https://s2.ax1x.com/2019/12/22/QzrVRP.png)\n\nDirector的作用主要有两个：一方面它隔离了客户与生产过程;另一方面它负责控制产品的生成过程\n\n客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。**也就是说客户将Builder传入指挥者，就可以返回构造之后的对象了**\n\n![image](https://s2.ax1x.com/2019/12/22/QzrQaj.png)\n\n客户端：\n\n![image](https://s2.ax1x.com/2019/12/22/Qzrby8.png)\n\n\n\n## 分析\n\n其实说的是三件事情\n\n1. 返回给客户端的是一个完整的、构造完的对象\n2. 创建过程（步骤）被封装在Director中\n3. 具体的每个部分的构造由Builder完成\n\n后两条就是定义中的将**对象的表现（Builder中完成的）和对象的构建（Director中完成的）分离开**，使得同样的构建过程可以创建出不同的表现\n\n第一条说的是另一个好处：**客户只需要确定指挥者和构造者就可以得到构造完的对象**\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QzsJkd.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QzyC4A.png)\n\n\n\nJavaMail\n\n![image](https://s2.ax1x.com/2019/12/22/Qz6GRI.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/22/Qz6oWR.png)\n\n\n\n\n\n## 优点\n\n客户端不必知道产品内部组成的细节\n\n将对象的构建与它的表示分离，使得相同的创建过程可以创建不同的产品对象\n\n用户使用不同的具体建造者即可得到不同的产品对象\n\n可以更加精细地控制产品的创建过程\n\n增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象\n建造者类编程，系统扩展方便，符合“开闭原则”\n\n\n\n## 缺点\n\n建造者模式所创建的产品一般具有较多的共同点，其组成部分相似（**例如套餐这样的**），如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制\n\n如果产品的内部变化复杂（**变化复杂而不是构造过程复杂，导致的结果是类数目增多**），可能会导致需要定义很多具体建造者类\n来实现这种变化，导致系统变得很庞大\n\n一个改进的尝试：在指挥者中指定各个部分的构造，而不是在builder中让他们组合；即指挥者来决定如何组合builder\n但是这样其实没有好处（基本可以认为是复杂性转移，将builder的工作移动到了director中），反而将生产原料的生产和组装放在一起，理解更困难\n\n\n\n## 应用场景\n\n需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多\n个成员属性\n\n需要生成的产品对象的属性相互依赖，需要指定其生成顺序\n\n对象的创建过程独立于创建该对象的类\n\n隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同\n的产品\n\n\n\n## 模式扩展\n\n省略抽象建造者角色:如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。 \n\n省略指挥者角色:在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让Builder角色扮演指挥者与建造者双重角色。 **这样的话就和普通的构造函数没什么区别只不过分到了很多小的方法中去**\n\n\n\n# 建造者模式和抽象工厂的关系\n\n与抽象工厂模式相比，建造者模式返回一个**组装好的完整产品**，而抽象工 厂模式返回**一系列相关的产品**，这些产品位于不同的产品等级结构，构成 了一个产品族。 \n\n在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以**不直接调用建造者的相关方法， 而是通过指挥者类来指导如何生成对象**，包括对象的组装过程和建造步骤， **它侧重于一步步构造一个复杂对象，返回一个完整的对象**。 \n\n如果将抽象工厂模式看成**汽车配件生产工厂**，生产一个产品族的产品，那么建造者模式就是一个**汽车组装工厂**，通过对部件的组装可以返回一辆完整的汽车。 \n\n\n\n# 原型模式\n\n建造者模式 — 复杂对象，表现很不一样；原型模式：复杂对象，但是很像\n\n使用原型模式来复制一个对象自身，从而克隆出多个与原型对象一模一样的对象 \n\n在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法 创建出更多同类型的对象，这就是原型模式的意图所在。 \n\n\n\n## 定义\n\n原型模式(Prototype Pattern):原型模式是一种对象创建型模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节。\n\n\n\n## 类图\n\n原型模式的基本工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝原型自己来实现创建过程\n\n![image](https://s2.ax1x.com/2019/12/22/QzWhGQ.png)\n\n\n\n## Java提供的机制\n\n![image](https://s2.ax1x.com/2019/12/22/QzgUUg.png)\n\n![image](https://s2.ax1x.com/2019/12/22/Qz2tQ1.png)\n\n\n\n## 深克隆和浅克隆\n\n通常情况下，一个类包含一些成员对象，在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式:深克隆和浅克隆。\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QzRupd.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QzRETO.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/22/QzRL3d.png)\n\n\n\n## 优点\n\n当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。（**只要按位拷贝就行了**）\n\n可以动态增加或减少产品类。 \n\n原型模式提供了简化的创建结构。 \n\n可以使用深克隆的方式**保存对象的状态**。 \n\n\n\n## 缺点\n\n**需要为每一个类配备一个克隆方法**，而且这个克隆方法 需要对类的功能进行通盘考虑，这对全新的类来说不是 很难，但对已有的类进行改造时，不一定是件容易的事， 必须修改其源代码，违背了“开闭原则”。 \n\n在**实现深克隆时需要编写较为复杂的代码**。 \n\n\n\n## 应用场景\n\n**创建新对象成本较大**。新的对象可以通过原型模式对已有对象\n进行复制来获得，如果是相似对象，则可以**对其属性稍作修改**。\n\n如果系统要**保存对象的状态**，而对象的**状态变化很小**，或者对象本身占内存不大的时候，也可以使用原型模式**配合备忘录模式来应用**。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用**状态模式**会比原型模式更好。 \n\n需要避免使用分层次的工厂类来创建分层次的对象，并且类的 实例对象只有一个或很少的几个组合状态，通过复制原型对象 得到新实例可能比使用构造函数创建一个新实例更加方便。 \n\n\n\n## 补充：备忘录模式\n\nhttps://www.runoob.com/design-pattern/memento-pattern.html\n\n![image](https://s2.ax1x.com/2019/12/22/QzW7q0.png)\n\n将备忘录对象作为状态，实现clone方法，每次都clone一下，然后改变一些状态，保存起来\n\n\n\n## 模式扩展\n\n带原型管理器的原型模式\n\n![image](https://s2.ax1x.com/2019/12/22/QzRWcR.png)\n\n\n\n很多情况下，复制所得到的对象与原型对象并不是完全相同的，它们的某些属性值存在异同。**通过原型模式获得相同对象后可以再对其属性进行修改，从而获取所需对象**。如多个学生对象的信息的区别在于性别、姓名和年龄，而专业、学院、学校等信息都相同，为了简化创建过程，可以通过原型模式来实现相似对象的复制。\n\n","tags":["软件设计"],"categories":["软件设计"]},{"title":"软件设计—行为型模式","url":"/2019/12/22/软件设计-行为型模式/","content":"\n# 策略模式\n\n## 一个例子\n\n我们要设计一个鸭子类型，自然的就想到继承。设计一个父类为鸭子，然后具体的鸭子子类去继承这个父类\n\n![image](https://s2.ax1x.com/2019/12/22/QxvKKK.png)\n\n如果我们需要添加接口，就在父类上添加接口，然后具体的子类实现\n\n但是这会产生一个问题，即添加的行为不是所有子类都有，例如有的橡皮鸭子不会飞\n\n而且每次产生新的类型的鸭子的时候，可能都需要覆盖掉这些不需要的方法\n\n因此我们考虑接口，如下：\n\n![image](https://s2.ax1x.com/2019/12/22/QxvY8I.png)\n\n\n\n但是接口同样不好，因为我们不能复用代码，例如有的行为是一样的，原先继承父类的方法就行了，现在接口就无法复用代码了\n\n因此我们要重新设计一样\n\n\n\n## 封装变化\n\n这一思想是几乎所有设计模式的宗旨\n\n唯一不变的就是变化，变化可以来自外在，也可能来自内驱\n\n设计的原则就是封装变化的部分\n\n**首先要将变化的和不变的分离出来**，对象是封装的基本单位，要把变化的部分变成新的类\n\n在上述例子中，我们需要把那些行为从鸭子类中分离出来\n\n\n\n**然后再封装**\n\n如何封装？\n\n根据需求来封装\n\n想想设计原则中的面向抽象编程，之前的设计都是根据具体编程（子类中有具体的行为实现，子类中有具体的接口的实现），因此我们要改变，面对抽象编程\n\n我们将行为抽象成为接口，然后让具体的行为去实现这个接口。这样我们可以复用这些行为的实现，还可以动态的添加这些行为，并且可以通过委托代理的方式让具体的鸭子有这些行为，委托 — 调用非本类的方法，调用其他类的方法\n\n![image](https://s2.ax1x.com/2019/12/22/QxxseO.png)\n\n这就是策略模式\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/22/Qxx7Tg.png)\n\n\n\n## 分析\n\n策略 strategy，有时又被称为 Policy\n\n定义了一组算法，将它们封装起来，让算法和客户代码独立开\n\n\n\n## 应用场景\n\n我们有一组算法，如果采用硬编码的形式将会产生大量的判断，像这种有一大堆if else来判断行为的，我们可以将它们分离出去，形成单独的策略类\n\n![image](https://s2.ax1x.com/2019/12/22/QxzQtH.md.png)\n\n一些类仅仅是行为上有一些区别（例如鸭子的例子），采用继承+覆盖的形式不灵活，无法动态配置，修改起来也麻烦。因此可以考虑采用策略模式，动态的去配置这种行为\n\n对于一个算法来说，我们有一组实现（空间或时间上的权衡），我们可以动态的选择用哪种算法。当我们让算法形成单独的类之后，我们就可以将这些变化封装起来\n\n我们还可以隐藏复杂的数据结构，将数据封装起来，和客户端分离开\n\n\n\n## 限制\n\n客户端需要知道所有的策略，需要做出选择\n\nstrategy需要设置\n\n使用者就要知道更多细节\n\n这些细节本来只要开发者知道\n\n同时也增加了类的数量\n\n\n\n# 状态模式\n\n## 定义\n\n状态模式(State Pattern) :允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。 \n\n\n\n## 分析\n\n1. 状态模式描述了对象状态的变化\n2. 对象如何在每一种状态下表现出不同的行为\n\n关键是引入了一个抽象类来专门表示对象的状态，这个类我们叫做抽象状态类，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了不同状态的行为，**包括各种状态之间的转换**\n\n即：\n\n**策略模式中策略的转化不需要由具体的策略完成**\n\n**而状态模式中状态的转化要具体的状态来负责**\n\n\n\n用抽象类来表示对象的状态而不是用接口：\n\n抽象类 — 可以有默认实现，例如全都实现为抛出异常，然后需要实现的方法就覆盖掉这些默认实现\n\n\n\n实现状态转化的两种方法：\n\n1. 由具体的状态负责\n2. 由上下文负责\n\n在实现状态切换时，在具体状态类内部需要调用环境类Context的setState()方法进行状态的转换操作\n\n在具体状态类中可以调用到环境类的方法，因此状态类与环境类之间通常还存在关联关系或者依赖关系。通过在状态类中引用环境类的对象来回调环境类的setState()方法实现状态的切换\n\n\n\n酒店的例子中，执行一个动作之后的状态是不确定的（下图中，入住之后转化到的状态要根据当前状态来确定），因此只能在具体的状态中执行状态的转化\n\n![image](https://s2.ax1x.com/2019/12/23/lSzKNF.png)\n\n\n\n环境类和状态类：\n\n![image](https://s2.ax1x.com/2019/12/23/lpVap6.png)\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/23/lSjxgI.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/23/lpSKqP.png)\n\n重构之后的代码为：\n\n![image](https://s2.ax1x.com/2019/12/23/lpSQVf.png)\n\n上面代码存在一点问题：\n\n没必要if else，可以写成很多个单独方法\n\n没必要每次都new，可以保存一下，下次再取出来\n\n进一步因为没有成员对象，就可以写成静态方法\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/lpVw6O.png)\n\n这个例子中，两个地方需要注意\n\n1. 可以和代理模式联用（论坛三个等级，不同行为，就可以让三个等级的具体行为再委托其他类来执行类似的方法，这样就可以复用）\n2. 状态的转化可以在环境类中进行，因为转化规则相对固定；而不像酒店的例子中那样，转化是动态的，只能放在具体的状态中进行\n\n![image](https://s2.ax1x.com/2019/12/23/lpV5ng.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/lpeKLF.png)\n\n![image](https://s2.ax1x.com/2019/12/23/lpeJRx.png)\n\n\n\n## 优点\n\n封装了转换规则。 \n\n枚举可能的状态，在枚举状态之前需要确定状态种类。 \n\n将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 \n\n允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 \n\n可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 \n\n\n\n## 缺点\n\n状态模式的使用必然会增加系统类和对象的个数。\n\n状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。\n\n状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码（可能是其他某些状态类，也可能是环境类），否则无法切换到新增状态;而且修改某个状态类的行为也需修改对应类的源代码。 （新增加状态的源状态是要改变的（转向这个新状态），目标状态不用（新增的状态可以写转向什么状态，和开闭原则是没有关系的））\n\n上面说的开闭原则指的是可切换状态的状态模式，有一种简单状态模式是不破坏开闭原则的：\n\n这种简单状态模式类似于命令模式，封装了某个状态下对应的一系列操作\n\n![image](https://s2.ax1x.com/2019/12/23/lpuJWn.png)\n\n破坏开闭原则的解决思路：将抽象放进代码，细节放进源数据。可以将转化后的状态放到配置文件中，读取配置文件（当然这是一种改进，不属于模式本身，模式本身是带有这个缺点的）\n\n\n\n## 应用场景\n\n1. 对象的行为依赖于它的状态(属性)并且可以根 据它的状态改变而改变它的相关行为。 \n2. 代码中包含大量与对象状态有关的条件语句。\n\n\n\n## 模式扩展\n\n共享状态 \n\n在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象。 \n\n\n\n# 状态模式和策略模式对比\n\n比策略模式更进一步，状态模式还封装了对应的行为，不再需要判断具体的命令，而是由状态来负责变化到的下一个状态\n\n即：策略模式中策略的转化不需要由具体的策略完成；而状态模式中状态的转化要具体的状态来负责\n\n\n\n# 命令模式\n\n请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。\n\n命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。\n\n\n\n## 定义\n\n命令模式(Command Pattern):将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化;对请求排队或者记录请求日志，以及支持可撤销的操作。\n\n参数化：将行为转成数据，实现空间和时间上的跨越\n\n三个应用场景：\n\n1. 封装请求\n2. 队列、行为日志\n3. 撤销操作\n\n命令模式是一种对象行为型模式\n\n**别名为动作(Action)模式或事务(Transaction)模式**\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/23/lpI8AI.png)\n\n\n\n## 分析\n\n对命令进行封装，将发出命令的责任和执行命令的责任分割开\n\n请求的一方发出请求，要求执行一个操作;接收的一方收到请求，并执行操作\n\n命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n\n**关键在于引入了抽象命令接口**，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/23/lpo7Zj.png)\n\n电视机是receiver，它执行真正的操作\n\n遥控器是invoker，它持有许多命令对象\n\n抽象命令类定义一个接口\n\n有三个具体命令类实现了抽象命令接口，内部关联了receiver，并在命令的执行方法中调用了receiver来真正执行动作\n\n客户端只是负责装配\n\n![image](https://s2.ax1x.com/2019/12/23/lpT1Yt.png)\n\n\n\n和遥控器那个例子不同，遥控器上的功能都是写死的，这里要求可以动态配置。所以就让invoker有一个set方法，可以动态set进来\n\n![image](https://s2.ax1x.com/2019/12/23/lp7CjS.png)\n\n![image](https://s2.ax1x.com/2019/12/23/lp7J41.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/lpHFxK.png)\n\n\n\n## 优点\n\n降低系统的耦合度\n\n新的命令可以很容易地加入到系统中\n\n可以比较容易地设计一个命令队列和宏命令(组合命令)\n\n可以方便地实现对请求的Undo和Redo\n\n\n\n## 缺点\n\n使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。\n\n\n\n## 应用场景\n\n系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 \n\n系统需要在不同的时间指定请求、将请求排队和执行请求。 \n\n系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\n\n系统需要将一组操作组合在一起，即支持宏命令。 \n\n\n\n## 模式扩展\n\n### 撤销\n\n只要在抽象命令加一个undo接口即可\n\n具体的命令类要实现这个接口\n\ninvoker调用undo方法即可\n\n![image](https://s2.ax1x.com/2019/12/23/lpHmad.png)\n\n\n\n### 宏命令\n\n宏命令又称为组合命令，它是命令模式和组合模式联用的产物\n\n在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法 \n\n实现的方式也很简单，将接口（这时候需要是一个抽象类）加上add方法、remove方法和getCommand方法，然后有具体的宏命令实现，可以将多个命令add进一个command的arraylist，执行的时候依此调用arraylist中的execute\n\n![image](https://s2.ax1x.com/2019/12/23/lpHgo9.png)\n\n\n\n# 观察者模式\n\n建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应\n\n\n\n## 定义\n\n观察者模式(Observer Pattern):定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。\n\n观察者模式又叫做发布-订阅(Publish/Subscribe)模式、模型-视图\n(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。\n\n观察者模式是一种对象行为型模式。\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/23/lpbspt.png)\n\n为什么观察者是接口而不是抽象类\n\n声明成接口的都是和应用功能正交的功能，而且观察者中的update都是需要各个观察者自己实现的，基本上没有什么公共部分\n\n\n\n## 分析\n\n被观察者对观察者通知之后，观察者有两种方法可以得到被观察者的信息：\n\n1. 一种是上图中的，观察者留有一个被观察者的引用，通过其getState方法可以得到状态信息。这种适用于状态信息比较大的情况\n2. 另外一种是在update的时候就直接传参。这一种适合数据量比较小的情况\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/23/lpqq2t.png)\n\n![image](https://s2.ax1x.com/2019/12/23/lpLAMV.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/lpOBtJ.png)\n\n![image](https://s2.ax1x.com/2019/12/23/lpOR0O.png)\n\n\n\n## 优点\n\n观察者模式可以实现表示层和数据逻辑层的分离 \n\n观察者模式在观察目标和观察者之间建立一个抽象的耦合 \n\n观察者模式支持广播通信\n\n观察者模式符合“开闭原则”的要求 \n\n\n\n## 缺点\n\n如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 \n\n如果在观察者和观察目标之间有循环依赖的话，观察目标会触 发它们之间进行循环调用，可能导致系统崩溃。 （尽量不要实现间接观察，因为有可能会造成循环通信）\n\n观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 \n\n\n\n## 应用场景\n\n一个抽象模型有两个方面，其中一个方面依赖于另一个方面。 将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n\n一个对象的改变将导致其他一个或多个对象也发生改变，而不 知道具体有多少对象将发生改变\n\n一个对象必须通知其他对象，而并不知道这些对象是谁。 \n\n需要在系统中创建一个触发链，A对象的行为将影响B对象，B 对象的行为将影响C对象......，可以使用观察者模式创建一种链式触发机制\n\n\n\n## Java中的观察者模式\n\n![image](https://s2.ax1x.com/2019/12/23/lpO4tH.png)\n\n图上标注的意思是，update的第一个参数是Observable，用来让观察者识别当前到底是哪个被观察者发来的更新信息，以便进行下一步处理\n\n![image](https://s2.ax1x.com/2019/12/23/lpOxhj.png)\n\nnotify有两个版本，有参数的是push模式，将所有信息都push过去，无参数的是pull模式，传递给update的第二个参数是null，观察者保留被观察者的引用，然后主动去pull信息。对应的是两种得到被观察者信息的方式\n\n被观察者很难控制更新粒度：这就是setChanged方法的作用。对于不需要发生通知的变化，我们就不要setChanged，那么就不会更新（notify之前会检查是否setChanged）。一系列的变化之后，可以用 `clearChanged()`撤消更新\n\n\n\n## 模式扩展\n\n观察者列表，加一个参数，分辨到底是哪一类事件，只通知那一类事件的观察者\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/lpj6eK.png)\n\n\n\n外部观察者模式：委托外部对象来管理观察者和被观察者，可以解决java类库是父类的问题，还可以统一管理复杂的观察关系（java内置的不行，因为这样需要二维数组，来维护每一个被观察者的观察者列表）（例如我们就可以检测是否有环），缺点就是有了中心的节点，性能可能会成为瓶颈\n\n\n\n# 中介者模式\n\n用于解决通信问题\n\n\n\n## 定义\n\n中介者模式(Mediator Pattern)定义:用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n中介者模式又称为调停者模式，它是一种对象行为型模式。\n\n\n\n## 类图\n\n![](https://s2.ax1x.com/2019/12/24/lPBDiQ.png)\n\n\n\n## 分析\n\n体现了迪米特法则，没有了复杂的依赖关系，都直接和中介者交流\n\n外部观察者其实也体现了中介者模式，维护一个表，由外部观察者来通知信息\n\n减少子类生成：不用像分身一样存在于很多个不同的关系网络中\n\n思想：转移复杂度\n\n在结构和行为两方面承担职责\n\n\n\n## 实例\n\n![](https://s2.ax1x.com/2019/12/24/lCWbi6.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lCW5L9.png)\n\n\n\n![](https://s2.ax1x.com/2019/12/24/lCfuoq.png)\n\n\n\n## 优点\n\n简化了对象之间的交互。\n\n将各同事解耦。\n\n减少子类生成。\n\n可以简化各同事类的设计和实现。\n\n\n\n## 缺点\n\n在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。\n\n\n\n## 应用场景\n\n系统中对象之间存在复杂的引用关系\n\n一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象\n\n想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的中介者类\n\n\n\n# 中介者模式与迪米特法则\n\n在中介者模式中，通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，中介者模式就是迪米特法则的一个典型应用。\n\n\n\n# 模板方法模式\n\n模板方法模式是基于继承的代码复用基本技术\n\n\n\n## 定义\n\n模板方法模式(Template Method Pattern):定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法是一种类行为型模式。\n\nc++中的非虚接口就是模版方法（父类中的非虚函数是复用部分，子类中覆盖的虚函数是自定义的）\n\n模板方法模式导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合“开闭原则”\n\n\n\n## 类图\n\n![](https://s2.ax1x.com/2019/12/24/lC4PxS.png)\n\n\n\n## 分析\n\n实现这些具体逻辑步骤的方法称为基本方法(Primitive Method)，而将这些基本法方法汇总起来的方法称为模板方法(Template Method)，模板方法模式的名字从此而来。\n\n模板方法:一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。\n\n基本方法:基本方法是实现算法各个步骤的方法，是模板方法的组成部分。\n\n基本方法有三种：\n\n1.  抽象方法\n2. 具体方法\n3. 钩子方法\n\n![](https://s2.ax1x.com/2019/12/24/lC4JaR.png)\n\n钩子方法有两种：\n\n1. 一种是空方法，嵌入在算法的步骤中（例如开头或者结尾，用户可以添加实现，也可以不添加）\n2. 一种是返回bool值的方法，可以控制是否执行某个步骤\n\n![](https://s2.ax1x.com/2019/12/24/lCoqJI.png)\n\n![](https://s2.ax1x.com/2019/12/24/lC4RRf.png)\n\n\n\n## 实例\n\n![](https://s2.ax1x.com/2019/12/24/lC47on.png)\n\n![](https://s2.ax1x.com/2019/12/24/lC4jQU.png)\n\n\n\n![](https://s2.ax1x.com/2019/12/24/lC5EQO.png)\n\n![](https://s2.ax1x.com/2019/12/24/lC5VyD.png)\n\n\n\n\n\n![](https://s2.ax1x.com/2019/12/24/lCIPBQ.png)\n\n\n\n![](https://s2.ax1x.com/2019/12/24/lCIEhq.png)\n\n\n\n## 优点缺点\n\n每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，但是更加符合“单一职责原则”，使得类的内聚性得以提高。\n\n\n\n## 应用场景\n\n各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复\n\n对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现\n\n控制子类的扩展，确保父类控制处理流程的逻辑顺序\n\n\n\n\n\n# 鼓励继承的模板方法&&好莱坞原则\n\n模板方法模式鼓励我们恰当使用继承，此模式可以用来改写一些拥有相同功能的相关类，将可复用的一般性的行为代码移到父类里面，而将特殊化的行为代码移到子类里面。这也进一步说明，虽然继承复用存在一些问题，但是在某些情况下还是可以给开发人员带来方便，模板方法模式就是体现继承优势的模式之一。\n\n\n\n![](https://s2.ax1x.com/2019/12/24/lCoFKO.png)\n\n\n\n# 策略模式vs命令模式vs模板模式\n\n参考\n\nhttps://jayfeng.com/2016/04/10/理解设计模式之命令模式、策略模式、模板方法模式/\n\n\n\n## 关联\n\n策略模式是命令模式的一个特例，而策略模式又和模板方法模式都是算法替换的实现，只不过替换的方式不同\n\n\n\n## 区别\n\n命令模式强调的是对已有行为的一个封装，而策略模式强调的是一系列未知算法的替换，这些算法需要独立的实现\n\n模板方法的重点是定义这些算法的结构，让子类去替换某些步骤；而策略模式是替换掉一整个算法实现（一般来说就是一个方法，更换策略相当于将整个算法实现替换掉）\n\n","tags":["软件设计"],"categories":["软件设计"]},{"title":"软件设计--面向对象设计原则概述","url":"/2019/12/22/软件设计-面向对象设计原则概述/","content":"\n# 软件的可维护性和可复用性\n\n**软件的复用(Reuse)或重用**拥有众多优点，如可以提高软件的开发效率，提高软件质量，节约开发成本，**恰当的复用还可以改善系统的可维护性**。\n\n面向对象设计复用的目标在于**实现支持可维护性的复用**。\n\n在面向对象的设计里面，**可维护性复用都是以面向对象设计原则为基础的**，这些设计原则首先都是复用的原则，遵循这些设计原 则可以有效地提高系统的复用性，同时提高系统的可维护性 。\n\n\n\n笔记：\n\n复用和维护通常情况下目标是相同的，但是有时候会有抵触，中的目标是既能复用，又将维护成本降低到最小。\n\n对算法、数据结构的复用通常会破坏可维护性，面向对象设计就是为了解决复用和维护的矛盾。\n\n\n\n# 重构\n\n重构(Refactoring)是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。 \n\n\n\n# 面向对象设计原则\n\n常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。 \n\n**地位不同：目标、具体操作、指导思想**\n\n![image](https://s2.ax1x.com/2019/12/22/QxypdJ.png)\n\n\n\n## 单一职责原则\n\nSingle Responsibility Princip SRP\n\n**是一个目标**\n\n### 定义\n\n一个对象应该只包含单一的职责，并且该职责被完整地封装\n在一个类中\n\n笔记：\n\n控制类的粒度，有利于复用，需要改动的可能降低到最低\n\n复用的粒度是类\n\n\n\n### 分析\n\n一个类(或者大到模块，小到方法)承担的职责越多，它被复用的可能性越小 \n\n类的职责主要包括两个方面：**数据职责和行为职责**，**数据职责通过其属性来体现，而行为职责通过其方法来体现。**\n\n单一职责原则是实现高内聚、低耦合的指导方针 \n\n\n\n### 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QxysyT.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QxyyOU.png)\n\n\n\n## 开闭原则\n\n是最高目标\n\nOpen-Closed Principle, OCP\n\n### 定义\n\n一个软件实体应当**对扩展开放，对修改关闭**。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。\n\n**软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。**\n\n\n\n### 分析\n\n**抽象化**是开闭原则的关键\n\n开闭原则还可以通过一个更加具体的“**对可变性封装原则**”来描述，对可变性封装原则(**Principle of Encapsulation of Variation, EVP**)要求找到系统的可变因素并将其封装起来\n\n\n\n### 实例\n\n![image](https://s2.ax1x.com/2019/12/22/Qx6Zpq.png)\n\n可以看到Button是变化的部分，应该要单独抽象出来，形成一个抽象接口\n\n![image](https://s2.ax1x.com/2019/12/22/Qx6J91.png)\n\n \n\n## 里氏代换原则\n\nLiskov Substitution Principle, LSP\n\n### 定义\n\n所有引用基类(父类)的地方必须能透明地使用其子类的对象\n\n\n\n笔记：\n\n**继承和多态：并不是为了复用，而是为了提供一个稳定的抽象层。把不确定的，变化的部分封装起来形成一个稳定的抽象层。不使用具体方法，而是使用抽象的方法。新的类只要实现这些抽象方法，就可以被直接使用**\n\n\n\n### 分析\n\n在软件中如果能够使用基类对象，那么一定能够使用其子类对象。 \n\n里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子 类对象，因此**在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**。\n\n\n\n笔记：\n\n父类都是抽象方法，子类都要实现\n\n子类的额外方法是**私有方法**\n\n**不依赖具体子类**，而是在运行时使用具体子类，来**替换父类**\n\n**行为上一样；语法上可替换**\n\n**子类的前置条件更弱，后置条件更强**\n\n\n\n### 实例\n\n和开闭原则中的例子差不多\n\n![image](https://s2.ax1x.com/2019/12/22/QxcAbD.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QxcK2t.png)\n\n\n\n## 依赖倒转原则\n\nDependence Inversion Principle, DIP\n\n### 定义\n\n高层模块**不应该依赖低层模块**，它们都应该**依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。**\n\n**要针对接口编程，不要针对实现编程**\n\n\n\n### 分析\n\n代码要**依赖于抽象的类**，而不要依赖于具体的类；要**针对接口或抽象类编程**，而不是针对具体类编程\n\n\n\n依赖倒转原则的常用实现方式之一是**在代码中使用抽象类，而将具体类放在配置文件中**\n\n“**将抽象放进代码，将细节放进元数据**” \n\n\n\n笔记：\n\n修改的时候改配置文件就行了，**尽量将具体类的使用延后**\n\n\n\n类之间的耦合关系：\n\n零耦合关系（没有任何关系）\n\n具体耦合关系（和具体类耦合）\n\n抽象耦合关系（至少有一方是抽象类）\n\n**以抽象方式耦合是依赖倒转原则的关键**\n\n\n\n依赖注入：\n\n构造注入(Constructor Injection):通过构造函数注入实例变量。 \n\n设值注入(Setter Injection):通过Setter方法注入实例变量 。 \n\n接口注入(Interface Injection):通过接口方法注入实例变量。 \n\n\n\n### 实例\n\n一般来说看到类图中没有抽象类，都可以考虑用依赖倒转\n\n![image](https://s2.ax1x.com/2019/12/22/QxgFWn.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QxgEQ0.png)\n\n\n\n## 接口隔离原则\n\nInterface Segregation Principle, ISP \n\n\n\n### 定义\n\n客户端不应该依赖那些它不需要的接口。 \n\n一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。\n\n\n\n### 分析\n\n接口隔离原则是指使用**多个专门的接口，而不使用单一的总接口**（接口是一组方法的集合）\n\n1. 一个接口就只代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫做“角色隔离原则”。（**类似于单一职责**）\n2. 接口仅仅提供客户端需要的行为，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可 能小的单独的接口，而不要提供大的总接口。 （**语言层面的要求**）\n\n\n\n首先必须满足**单一职责原则**，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。\n 可以在进行系统设计时采用**定制服务**的方式，即为不同的客户端提供**宽窄不同**的接口，只提供用户需要的行为，而隐藏用户不需要的行为。\n\n\n\n### 实例\n\n看到巨大的接口就要拆分\n\n![image](https://s2.ax1x.com/2019/12/22/Qxgrlt.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QxgyOf.png)\n\n\n\n## 合成复用原则\n\nComposite Reuse Principle, CRP\n\n合成：组合和聚合都算合成\n\n\n\n### 定义\n\n**尽量使用对象组合（合成），而不是继承来达到复用的目的**\n\n\n\n### 分析\n\n合成复用原则就是指在一个新的对象里通过**关联关系(包括组合关系和聚合关系)**来使用一些已有的对象，使之成 为新对象的一部分;新对象通过**委派调用已有对象的方法达到复用其已有功能的目的**。简言之:**要尽量使用组合/聚合关系，少用继承**。\n\n\n\n继承复用和组合复用：\n\n继承复用:实现简单，易于扩展。破坏系统的封装性; 从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性;只能在有限的环境中使用。 (“**白箱**”复用 ) \n\n组合/聚合复用:耦合度相对较低，选择性地调用成员对象的操作;可以在运行时动态进行。(“**黑箱**”复用 ) \n\n\n\n**一般首选使用组合/聚合来实现复用**\n\n \n\n笔记：\n\n如果是改写接口的返回值等进行复用，那么可以用组成（**不涉及中间步骤的更改，只是在头尾修改**）\n如果要改变其中几个步骤，那么需要用继承\n\n\n\n正确的观点：\n\n**继承复用的是抽象接口**\n**合成复用的是具体实现**\n\n并且**合成的还是抽象耦合，使用的还是抽象类型**\n\n\n\n### 实例\n\n一般来说就是改继承为组合\n\n![image](https://s2.ax1x.com/2019/12/22/Qxgb0U.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QxgXtJ.png)\n\n\n\n## 迪米特法则\n\nLaw of Demeter, LoD\n\n又称为最少知识原则(Least Knowledge Principle, LKP)\n\n\n\n### 定义\n\n1. **不要和“陌生人”说话**\n2. **只与你的直接朋友通信**\n\n3. **每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位**\n\n在狭义的迪米特法则中，**如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用**，如果其中的一个类需要调用另一个类的某一个方法的话， 可以通过**第三者转发这个调用**\n\n因为要转发，因此**通常和效率是矛盾的**\n\n广义的迪米特法则:指对对象（模块）之间的信息流量、流向以及信息的影响的控制，主要是对**信息隐藏**的控制，控制信息的过载\n\n \n\n朋友：\n\n1. 当前对象本身(this); \n\n2. 以参数形式传入到当前对象方法中的对象; \n\n3. 当前对象的成员对象; \n\n4. 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友; \n\n5. 当前对象所创建的对象。\n\n    \n\n陌生人：\n\n调用其他方法返回出来的对象\n\n\n\n指导行为：\n\n1. 在类的划分上，应当尽量创建**松耦合**的类，类之间的耦合度 越低，就越有利于复用，一个处在松耦合中的类一旦被修改 ，不会对关联的类造成太大波及; \n2. 在类的结构设计上，每一个类都应当尽量**降低其成员变量和成员函数的访问权限; **\n3. 在类的设计上，只要有可能，一个类型应当设计成**不变类;**\n4.  在对其他类的引用上，一个对象对其他对象的**引用应当降到最低** \n\n\n\n### 实例\n\n一般来说就是通信非常复杂，就引入中间层\n\n![image](https://s2.ax1x.com/2019/12/22/Qx2Ehd.png)\n\n![image](https://s2.ax1x.com/2019/12/22/Qx28hj.png)\n\n\n\n# 什么是设计模式\n\n设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结\n\n设计模式不会给出具体的代码实现，需要结合需求来给出实现\n\n设计模式不是发明出来的，而是发现的\n\n设计模式和设计原则大部分都是针对解决变化这个问题，允许系统的一部分单独变化而不会影响其他部分\n\n设计模式提供了共同语言\n\n设计模式被证实是一种好的面向对象设计经验\n\n\n\n# 为什么需要设计模式\n\n设计模式形成了术语，节约交流成本，可以让开发人员在设计层面上思考问题，而不是更细节的层面。注重设计，而不会迷失在细节当中\n\n设计模式的名字就可以概括一大堆设计中的细节和特点，交流付出的代价更小\n\n可以让年轻的设计人员更快上手\n\n\n\n只了解设计原则还不够，好的设计人员需要想的更多，让软件可维护性更好，更加灵活，可以应对更多变化。这就是设计模式的意义。但是设计原则是一个很好的指导。设计模式可以给出一个好的设计，符合设计原则的设计\n\n\n\n# 设计模式和类库和框架的关系\n\n设计模式比类库的层次更高，它知道我们如果解决一类问题，而不是着眼于一个具体的问题\n\n框架和类库不是设计模式，它们提供了具体的实现。但是它们的实现过程中使用了大量设计模式\n\n\n\n# 类行为型模式和对象行为型模式\n\n只有继承关系，没有对象关联关系，是类的行为型模式\n类行为型模式：继承来实现","tags":["软件设计"],"categories":["软件设计"]},{"title":"c++学习笔记（六）","url":"/2019/12/21/c-学习笔记（六）/","content":"\n# C部分\n\n## Data\n\n数据包括：\n\n1. 名\n2. 值\n3. 地址\n4. 类型\n5. 性质\n\n其中类型指的是：取值范围和操作\n\nc++是强类型，动静结合的语言（实际上还是静态）\n\n\n\n## 基本数据类型\n\nchar int float double\n\n修饰符：long short signed unsigned\n\nchar 只能用signed、unsigned修饰\n\nfloat 不能被修饰\n\ndouble 只能用long修饰\n\nint 可以用以上4种修饰符组合修饰，例如long long int a;实际上为8个字节，和long long长度一样，当然长度是和机器有关的\n\n\n\n一个char的大小和一个机器字节一样，8bits\n\nwchar_t为宽字符类型，16bits\n\n\n\nint short long 和 long long都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型，例如unsigned long，类型unsigned int可以缩写为unsigned\n\nchar有三种类型：char、signed char、unsigned char\n\n\n\n### 类型别名typedef\n\ntypedef可以定义类型的别名，含有typedef的声明语句定义的不再是变量而是类型别名，如下：\n\n![image](https://s2.ax1x.com/2019/12/21/QjdeEV.png)\n\n再如：\n\npstring是char *的别名\n\n![image](https://s2.ax1x.com/2019/12/21/QjdHaV.png)\n\npstring指代的类型要作为整体来看，不能直接带入原来的类型\n\n![image](https://s2.ax1x.com/2019/12/21/QjdzrR.png)\n\n上面的常量指针表达好像有点问题，见下面这个例子\n\n```c++\nint main(){\n    int i = 1;\n    const pa i1 = &i;\n    // 正确\n    // i1并不是指向常量，而是指针本身不可修改\n    *i1 = 2;\n    const int *i2 = &i;\n    // 错误\n    // i2指向常量\n    // *i2 = 2;\n    return 0;\n}\n```\n\n\n\ntypedef和数组\n\n```c++\ntypedef int A[10];\n\nvoid f(int (&a)[11]){\n\n}\n\nint main(){\n    A a;\n    cout << sizeof(a)/sizeof(a[0]) << endl;\n    // 错误\n    // A是长度为10的数组\n    // f的参数为长度为11的数组的引用，不兼容\n    // f(a);\n    return 0;\n}\n```\n\n\n\n## 表达式求值\n\n副作用值得是求值次序引起的结果不确定：例如y+ ++y\n\n\n\n### 计算中的类型转换\n\n```c++\nint main(){\n    int x=10;\n    int y=3; double d=2.0 ;\n    // 因为计算顺序问题会产生不同的结果\n    // cout << d + x/y*d + ++y << endl;\n\n    // 因为x/y仍然是整数，因此结果为8\n    cout << d + x/y*d << endl;\n    // 因为d*x/y是浮点数，因此结果为浮点数\n    cout << d + d*x/y << endl;\n\n    // 要注意下面这样其实是没用的，结果还是3\n    cout << 1.0*(x / y) << endl;\n    return 0;\n}\n```\n\n\n\n### 三目操作符的嵌套\n\n```c++\nint main(){\n    int x = -100;\n    // 三目运算符可以嵌套\n    // 遵循就近原则\n    // 结果为-1\n    cout << (x > 0? 1: x == 0? 0 : -1) << endl;\n    return 0;\n}\n```\n\n\n\n### 逗号表达式\n\n如果有一连串的逗号表达式赋值，那么最右边的那个表达式的值会赋值给左边，如下：\n\n```c++\nint main(){\n    int a,b,c;\n    int d = (a = 1, b = a+2, c = b+3);\n    // 最后一个表达式的值赋值给d\n    // 输出结果为6\n    cout << d <<endl;\n    return 0;\n}\n```\n\n\n\n### 位运算符\n\n主要是异或的运算比较特别\n\n![image](https://s2.ax1x.com/2019/12/21/Qjq3M4.png)\n\n\n\n### switch的优化\n\n如果内部实现成多个if else嵌套，那么最多找到正确的分支的时间为O(N)\n\n![image](https://s2.ax1x.com/2019/12/21/QjXFxO.png)\n\n优化成只比较一次：\n\n首先取出switch中的值，然后和最大值比较，如果超过，那么跳转到default，否则直接跳转到对应的情况的起始地址（专门做了一张表，按照顺序存放了各个可能情况的处理代码的起始地址，这样switch中的值就是作为偏移量，*4之后加上这张表的基址，就可以直接找到对应处理代码的起点）\n\n![image](https://s2.ax1x.com/2019/12/21/Qjzlkj.png)\n\n\n\n### 表驱动编程\n\n处理错误的时候，可以在一个数组中放struct，struct为错误信息，处理错误的函数指针（因为错误处理函数的接口都一样，因此可以统一定义类型）\n\n\n\n## 函数\n\n### 函数调用过程分析\n\n函数传递参数有两种形式：值传递和引用传递\n\n下面先看值传递的情况：\n\n![image](https://s2.ax1x.com/2019/12/21/Qv9P7F.png)\n\n例子中调用者维护堆栈：\n\n调用前，ebp在高地址，esp在低地址，中间是main函数的栈（已经包含了将要调用的函数的参数空间）\n\n参数从右到左放入（使用mov，移动到esp+某个偏移量，这样效率比push高）\n\n返回地址压栈（push，esp向下移动）\n\n跳转到新函数的起始地址开始执行\n\npush ebp，将ebp压栈，保存原来的ebp\n\n然后将ebp移动到此时的esp处（和第一个参数间隔0x8）\n\nesp移动到下面，分配足够这个函数运行的栈空间\n\n执行函数体，通过esp+0x8可以取出第一个参数，+0xc取出第二个参数，返回值放在eax中\n\n将esp置回esp的位置\n\n弹栈，还原main函数的ebp\n\n再弹栈，找到原先压入的返回地址\n\n返回之后，将eax的值（返回值）放到相应位置\n\n![image](https://s2.ax1x.com/2019/12/21/QvCwKx.png)\n\n![image](https://s2.ax1x.com/2019/12/21/QvCRxI.png)\n\n上面这种方式为cdecl call，由调用者清理参数的栈，这可以应对可变参数的情况（因为调用者知道有多少个实际参数，从而可以正确清理堆栈）\n\n另一种方式是stdcall，由被调用者清理堆栈，不能处理可变参数的情况\n\n还有一种方式是fastcall，用寄存器传递参数\n\ncdecl call的栈情况\n\n![image](https://s2.ax1x.com/2019/12/21/QvFKxA.png)\n\n\n\n下面看引用传递的情况：\n\n![image](https://s2.ax1x.com/2019/12/21/QvkWtS.png)\n\n和前面的区别是放入栈中的不再是一个数字，而是一个地址\n\n这个地址就是引用变量的地址，之后通过lea就可以操作原来的那个变量的值了\n\n\n\n![image](https://s2.ax1x.com/2019/12/21/Qvk6mt.png)\n\n![image](https://s2.ax1x.com/2019/12/21/Qvkr6A.png)\n\n\n\n总结：\n\n![image](https://s2.ax1x.com/2019/12/21/QvEJIK.png)\n\n\n\n还有两种特别奇葩的方式：c++好像没有实现\n\n![image](https://s2.ax1x.com/2019/12/21/QvV3lQ.png)\n\n![image](https://s2.ax1x.com/2019/12/21/QvVGOs.png)\n\n### 函数声明\n\n使用外部c函数要声明extern \"C\"，因为c++有重载c无重载，所以符号表不一样，因此一定要声明来自c，否则找不到\n\n\n\n### 函数重载\n\n返回值类型不作为区别重载函数的依据\n\n但是const可以区分，例如：\n\n```c++\n/*\n注意const重载的时候\n自身是否是const不会重载（因为没有意义）\n只有指向的是const还是非const才会构成重载\n类的const成员函数就会构成这样的重载\n*/\nvoid f(int *a){\n    cout << \"Not const\" << endl;\n}\n\n// 不构成重载\n// void f(int *const a){\n\n// }\n\nvoid f(const int *a){\n    cout << \"Const\" << endl;\n}\n```\n\n\n\n函数重载可能会出现二义性问题\n\n```c++\nvoid f(int a){\n    cout << \"f(int)\" << endl;\n};\n\nvoid f(double a){\n    cout << \"f(double)\" << endl;\n};\n\n// 如果是精确匹配不会有问题\n// 非精确匹配如果有转化优先级则不会有问题\n// 否则就会有问题\nint main(){\n    // long a = 1;\n    short a = 1;\n    f(a);\n    return 0;\n}\n```\n\n上面的例子中如果是第一行，因为long转为int和double并没有优先级，会报错，short优先转为int，因此不会报错\n\n\n\n### 默认参数\n\n靠右边写，因为函数的参数是从右向左压栈\n\n默认参数会导致二义性：\n\n```c++\nvoid f(int);\nvoid f(int, int=2);\n```\n\n\n\n### inline函数\n\n推荐而非强制，取决于调用方式\n\n加上inline不一定真的是内联函数，是否真的是inline还要看编译器的决定，如果inline被拒绝，那么每一份单独的文件里面都会出现该函数，仍然是函数调用，只不过被限制了作用域（static）\n\ninline函数不能是递归函数，如果是递归，那么拒绝inline\n\n如果有对inline函数取地址的操作，那么也会拒绝inline\n\n和宏相比：有类型检查\n\ninline函数调用前必须要有函数体，因为编译系统将为inline函数创建一段代码，每次调用时，用相应的代码替换，因此内联函数，包括函数模板中的内联 – 一般都是放在头文件中\n\n\n\ninline的缺点：增大目标代码；病态的换页；降低指令块取装置的命中率\n\n\n\n## 程序组织\n\n### extern\n\n在头文件中声明，源文件中定义\n\n头文件中声明成extern不会再分配空间，会在符号表留下位置\n\n\n\n### const\n\nconst默认作用域为本文件，因为编译之后直接拿值替换了\n\n例如：\n\na.cpp为：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nconst int a = 1;\n\nint main(){\n    return 0;\n}\n```\n\nb.cpp为：\n\n```c+\nextern const int a;\n\nvoid f(){\n    int b = a;\n}\n```\n\nlink阶段会报错\n\n为了使得可以共享同一常量，应该将常量统一写在头文件中\n\n\n\n### static\n\nstatic修饰函数内变量有全生命周期，但是可访问的范围还是不变\n\n```c++\nclass A{\npublic:\n    ~A(){cout << \"~ A\" << endl;}\n};\n\nvoid f(){\n    static A a;\n    return;\n}\n\nint main(){\n    f();\n    cout << \"main finished\" << endl;\n    return 0;\n}\n```\n\n上面的例子中，先打印main finished，再打印~ A\n\n\n\nstatic可以记录下函数的访问次数\n\n```c++\nint fun(void){\n    static int count = 0;\n    return count++;\n}\n\n// static变量全生命周期\n// 且可以用来记录访问次数\n// 这一点和类的static成员变量类似\nint main(void)\n{    \n    for(int i = 0; i < 10; i++)\n        cout << fun() << endl;    \n    return 0;\n}\n```\n\n\n\n不作任何处理的变量和函数都是程序级的（都可以访问）\n\n加上static表示文件级的，两个文件中有同名的static函数（因为限制在文件级中，不会冲突）\n\n\n\n### namespace\n\n在约束作用域方面，替代static\n\n解决全局变量/函数的名冲突\n\n两种形式：\n\nusing-declaration，例如using L::k\n\nusing-directive, 例如using namespace L（不建议在同一作用域两次使用using-directive）\n\n\n\n#### 支持别名\n\n```c++\nnamespace ATT = American_Telephone_and_Telegraph\n```\n\n\n\n#### 可嵌套\n\n```c++\nnamespace L1 { \n  inta;\n\t.......\n\tnamespace L2 { \n    void f() ;\n\t\t.......\n\t} \n}\n........\n\nL1::L2::f();\nusing namespace L1; \nL2::f();\n```\n\n内层命名空间声明的名字将隐藏外层命名空间声明的同名成员。在嵌套命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码想要访问它必须在名字前添加限定符\n\n\n\n#### 可以是不连续的\n\n![image](https://s2.ax1x.com/2019/12/21/Qv2DoQ.png)\n\n\n\n#### 全局命名空间\n\n全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在全局命名空间中。\n\n作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并没有名字：\n\n```c++\n::member_name\n```\n\n\n\n#### 例子\n\n```c++\n// 全局变量，默认初始化为0\nint a;\n\nnamespace X { \n    // 命名空间中的变量，默认初始化为0\n    int a;\n    void f(){\n        int a = 0;\n        // 临时变量\n        a++;\n        // X中的a\n        X::a++;\n        // 全局的a\n        ::a++;\n        // 三个都输出1\n        cout << ::a << endl;\n        cout << X::a << endl;\n        cout << a << endl;\n    }\n};\n\nint main(){\n    X::f();\n    return 0;\n}\n```\n\n\n\n## 预处理宏\n\n优点：\n\n方便程序修改\n\n提高程序运行效率\n\n\n\n缺点：\n\n看不到名字，不利于调试\n\n不能数值拷贝\n\n不能做参数类型检查\n\n可能会降低可读性\n\n\n\n### 常量\n\n可以用#define定义常量，已被const取代\n\n\n\n### 内联函数\n\n可以用#define定义无数个重载版本，已被inline取代。inline有类型检查\n\n\n\n### 泛型函数\n\n可以用#define定义无数个重载版本，实现泛型编程，已被template取代\n\n\n\n### 泛型类型\n\n同样被template取代\n\n\n\n### 重命名\n\n可以用#define进行重命名，已被namespace取代\n\n\n\n### 字符串拼接\n\n无法取代\n\n```c++\n#define conn(x,y) x##y\n#define ToChar(x) #@x\n#define ToString(x) #x\n```\n\nhttps://blog.csdn.net/xdsoft365/article/details/5911596\n\n\n\n### 预定义ifndef\n\n无法取代\n\n![image](https://s2.ax1x.com/2019/12/21/QvhjgA.png)\n\n\n\n\n\n### 控制程序组织\n\n例如#pragma可以定义内存布局\n\n\n\n## 数组\n\n相同类型，连续存储\n\n注意字符数组：\n\n![image](https://s2.ax1x.com/2019/12/21/Qv4PUS.png)\n\n\n\n### 多维数组\n\n可以这样看：\n\n```c++\nT A[c1][c2]\ntypedef T T1[c2]\nT1 A[c1];\n```\n\n\n\n作为函数参数，需要传递第二维，省略第一维：\n\n```c++\nvoid f(int a[][3], int n);\n```\n\n\n\n## struct\n\n可以控制对齐的程度\n\n\n\n## Union\n\n共享存储空间\n\n\n\n例子：\n\n```c++\nunion B{\n    char b;\n    int a;\n    short c;\n};\n\nint main(){\n    B b;\n    b.a = 0x12345678;\n    cout << b.a << endl; \n    // 输出的是16进制78的十进制值\n    // 因为是小端存储，因此78放在高地址处\n    // 可见char是对齐到高地址处\n    cout << (int)b.b << endl; \n    return 0;\n}\n```\n\n\n\n### 例题\n\n定义数组，存储100个图形（直线、矩形，圆）\n\n直线和矩形都要4个int\n\n圆只要3个int\n\n不能统一定义\n\n需要加一个字段表示类型\n\n因此最后的形式为：\n\n![image](https://s2.ax1x.com/2019/12/21/Qv7EnA.png)\n\n![image](https://s2.ax1x.com/2019/12/21/Qv7uh8.png)\n\n\n\n## 指针\n\n空指针不一定是0，例如：\n\n```c++\n// 如果定义空指针是0\n// 那么下面的代码将产生问题\nvoid f(int);\nvoid f(int *);\nf(NULL)\n```\n\n因此引入专门的值：nullptr\n\n\n\n### 指针运算\n\n指针加减整数运算，+1会偏移sizeof(基类型)\n\n![image](https://s2.ax1x.com/2019/12/21/QvHrRS.png)\n\n\n\n\n\n同类型的指针相减，得到的是整型，偏移量，具体为：\n\n值差/sizeof(基类型)，和上面加减整数的定义保持一致\n\n![image](https://s2.ax1x.com/2019/12/21/QvHRZn.png)\n\n\n\n### 指针的输出\n\nchar*特殊，直接输出的话是字符串，如果输出\\*p，那么因为p其实是第一个元素的地址，所以输出的是第一个字符，如果真的要输出地址，那么需要转型为(int\\*)\n\n![image](https://s2.ax1x.com/2019/12/21/QvHWaq.png)\n\n\n\n### void*指针\n\n只管理地址信息，定义的是指针类型的公共接口，任何指针都可以转化为void*指针（可以强制转化，也可以直接写void\\* a = &x），反之则不行（只能强制类型转换）\n\n\n\n用途：\n\n![image](https://s2.ax1x.com/2019/12/21/QvbkdI.png)\n\n![image](https://s2.ax1x.com/2019/12/21/QvqbU1.png)\n\n\n\n### 指针常量和常量指针\n\n从最靠近变量名开始向外看\n\n![image](https://s2.ax1x.com/2019/12/21/Qvq9hV.png)\n\n\n\n### const_cast\n\n可以将const转为非const\n\n可以用于函数调用中，但是修改const的值仍然是不允许的\n\n```c++\n#include <iostream> \nusing namespace std; \n  \nint fun(int* ptr) \n{ \n    *ptr = *ptr + 10; \n    return (*ptr); \n} \n  \nint main(void) \n{ \n    // val本来就是const，改变了const的值\n    // 输出是未定义的\n    const int val = 10; \n    const int *ptr = &val; \n    int *ptr1 = const_cast <int *>(ptr); \n    fun(ptr1); \n    cout << val << endl; \n    return 0; \n} \n```\n\n如果删除掉val原来的const定义，那么下面的行为是允许的：\n\n```c++\n#include <iostream> \nusing namespace std; \n  \nint fun(int* ptr) \n{ \n    *ptr = *ptr + 10; \n    return (*ptr); \n} \n  \nint main(void) \n{ \n    // val本来就是const，改变了const的值\n    // 输出是未定义的\n    const int val = 10; \n    const int *ptr = &val; \n    int *ptr1 = const_cast <int *>(ptr); \n    fun(ptr1); \n    // 输出10，因为常量的值编译时候就填入了\n    cout << val << endl; \n    return 0; \n} \n```\n\n\n\n像上面例子一样，看下面这个例子：\n\n因为常量的值编译的时候就会做替换，所以同一个地址看起来有两个值：\n\n![image](https://s2.ax1x.com/2019/12/21/QvLi5t.png)\n\n\n\n### 指针常量\n\n<类型>* const<指针变量>\n\n必须在定义的时候就初始化（所有常量都是如此）\n\n\n\n### 指针与函数\n\n作为形式参数：\n\n![image](https://s2.ax1x.com/2019/12/21/QvLeKg.png)\n\n\n\n作为函数指针：\n\n注意两种等价形式\n\n![image](https://s2.ax1x.com/2019/12/21/QvL82T.png)\n\n\n\n应用，计算器程序：\n\n![image](https://s2.ax1x.com/2019/12/21/QvLxJ0.png)\n\n进一步优化：\n\n![image](https://s2.ax1x.com/2019/12/21/QvOVF1.png)\n\n\n\n泛型冒泡排序：\n\n![image](https://s2.ax1x.com/2019/12/21/QvONSf.png)\n\n \n\n计算积分的接口：\n\n![image](https://s2.ax1x.com/2019/12/21/QvjCVJ.png)\n\n\n\n### 指针与数组\n\n数组的名字可以直接使用，为指向第一个元素的指针，因此用指针访问数组元素和使用下标具有同等的能力\n\n但是数组名不能修改，即不能a++，（这并不代表它是一个常量，事实上，指针名可以作为参数传入非const的一维指针形参）如下：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int a[10] = {0};\n    int *p = a;\n    for(int i = 0; i < 10; i++){\n        cout << *(a+i) << endl;\n        // 错误 a是指向第一个元素，但是是int *const\n        // cout << *(a++) << endl;\n\n        // 正确，相当于把 int *const赋值给int *\n        cout << *(p++) << endl;\n    }\n    return 0;\n}\n```\n\n\n\n对于二维数组来说，可以按照一维数组来访问，当然也可以按照二维数组来访问\n\n```c++\n&a[0][0] == a[0]\n&b[0] == b // 对于二维数组也同样适用\n```\n\n\n\n下面的q就是一个指向大小为3的数组的指针，其类型和a的第一个维度相同，因此可以直接赋值\n\n**使用指针++的形式效率更高（inc指令，只要一条指令即可）**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int a[2][3] = {1,2,3,4,5,6};\n    // 或者 &a[0][0]\n    int *p = a[0];\n    for(int i = 0; i < 6; i++){\n        // 输出 1 2 3 4 5 6\n        // 可以越界访问，但是输出是随机值\n        cout << *(p++) << endl;\n    }\n    int (*q)[3] = a;\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 3; j++){\n            cout << q[i][j] << endl;\n        }\n    }\n    return 0;\n}\n```\n\n\n\n计算偏移量访问：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int a[2][3] = {1,2,3,4,5,6};\n    // 或者 &a[0][0]\n    int *p = a[0];\n\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 3; j++){\n            // 一维指针计算偏移量\n            cout << *(p + 3*i + j) << endl;\n        }\n    }\n\n    int (*q)[3] = a;\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 3; j++){\n            // 二维指针计算偏移量\n            cout << *(*(q + i) + j) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n\n\n对数组名使用sizeof得到的是整个数组的大小\n\n如果将指针名赋值给一个int，sizeof得到的是指针大小而不是数组大小\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int *p = nullptr;\n    // 输出8\n    // 运行时该编译器默认指针长度为8\n    cout << sizeof(p) << endl;\n\n    int a0[10] = {0};\n    // 输出40\n    // 40 = 4 * 10\n    cout << sizeof(a0) << endl;\n    // 输出8\n    // a0+1为指向第二个元素的指针，长度为8\n    cout << sizeof(a0+1) << endl;\n\n    int a[2][3] = {1,2,3,4,5,6};\n    // 输出24\n    // 24 = 2 * 3 * 4\n    cout << sizeof(a) << endl;\n    // 输出8\n    // a+1指向的类型为int (*)[3]\n    // 是一个指针，因此长度为 8（int *的长度为8）\n    cout << sizeof(a+1) << endl;\n\n    // 输出8\n    // 尽管指向的位置和a0相同\n    // 但是sizeof得到的是q（指针）的大小\n    int *q = a0;\n    cout << sizeof(q) << endl;\n    return 0;\n}\n```\n\n\n\n#### 降维\n\n通过取地址就可以完成\n\n可以让二维数组使用一维数组的接口：\n\n![image](https://s2.ax1x.com/2019/12/22/QzqijS.png)\n\n\n\n#### 升维\n\n需要借助typedef或者用强制类型转换\n\n```c++\n#include <iostream>\nusing namespace std;\n\nvoid show(int a[], int n){\n    for(int i=0;i<n;i++)\n        cout << a[i] << \" \" << endl;\n    cout << endl;\n};\n\nvoid show(int a[][2], int n){\n    for (int i=0;i<n;i++)\n        for (int j=0;j<2;j++) {\n                cout << *(a+i)+j << \":\"\n                     << a[i][j] << \" \";\n                // 每输出4个值就换行     \n                if ((i*2+j+1)%4 == 0) cout << endl;\n        }\n        cout << endl;\n};\n\nvoid show(int a[][2][3], int n){\n    for (int i=0;i<n;i++)\n        for (int j=0;j<2;j++) \n            for (int k=0;k<3;k++){\n                cout << *(*(a+i)+j)+k << \":\"\n                     << a[i][j][k] << \" \";\n            if ((i*6+j*3+k+1)%4 == 0) cout << endl;\n            }\n            cout << endl;\n};\n\n\nint main(){\n    int b[12];\n    for (int i=0;i<12;i++) b[i] = i+1;\n    show(b,12);\n    typedef int T[2]; \n    show( ( T *) b,6);\n    // 等价形式，注意括号\n    show( ( int (*)[2]) b,6);\n    typedef int A[3]; \n    typedef A B[2]; \n    show((B *) b,2);\n    // 等价形式，注意括号\n    show( ( int (*)[2][3]) b,2);\n    cout << endl;\n    return 0;\n}\n```\n\n\n\n### 多级指针\n\n如果是一个指针类型例如char *，那么取地址之后就是char **\n\n如果是一个数组名，例如 char p[5]，那么取地址之后就是char (*)[5]，而不是char **\n\n```c++\n#include <iostream>\nusing namespace std;\n\nvoid swap(char **p1, char **p2) { \n    char *tmp = *p1;\n    *p1 = *p2;\n    *p2 = tmp; \n};\n\nint main(){\n    // 报错，&p1的类型是char (*)[5]\n    // char p1[] = \"abcd\"; \n    // char p2[] = \"1234\";\n    char *p1 = \"abcd\";\n    char *p2 = \"1234\";\n    // 可以正确交换\n    cout << p1 << \" \" << p2<<endl; \n    swap( &p1,&p2 ); \n    cout << p1 << \" \" << p2<<endl; \n    return 0;\n}\n```\n\n\n\n正确的版本：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nvoid swap(char *&p1, char *&p2) { \n    char *tmp = p1;\n    p1 = p2;\n    p2 = tmp; \n};\n\nvoid f(char *c){}\n\nint main(){\n    // 可以正确交换\n    char p1[] = \"abcd\"; \n    char p2[] = \"1234\";\n    cout << p1 << \" \" << p2<<endl; \n    swap( p1,p2 ); \n    cout << p1 << \" \" << p2<<endl; \n    return 0;\n}\n```\n\n注意指针名并不是const，它是可以交换的！！！\n\n\n\n## 可变参数\n\n![image](https://s2.ax1x.com/2019/12/23/lSML7D.png)\n\n第一个的参数的地址是必须提供的，也就是可变参数必须至少包含一个参数，这个参数用来寻址，实现对所有参数的访问\n\n\n\n### printf\n\n主要是理解三个宏：\n\n![image](https://s2.ax1x.com/2019/12/23/lSMXAe.png)\n\n\n\n因为是以32位对齐，所以可变参数部分需要实现以int的长度为单位的向上取整，即_INTSIZEOF(x)\n\n使用：\n\n![image](https://s2.ax1x.com/2019/12/23/lSQENQ.png)\n\nmarker的类型是char*，每次+都只增加一个内存单元\n\n\n\n## 动态变量\n\nmalloc返回void *，需要类型转化\n\n如果返回null则说明申请失败\n\n\n\n和new的区别就是\n\n1. new调用构造函数\n2. new返回的是有类型的指针\n3. new可以重载，让内存分配更加合理\n4. new如果失败会抛出bad_alloc异常\n\n\n\n返回的指针仍然是在栈中\n\n\n\nnew一个数组：\n\n多维数组可以升维得到\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    // 申请一维数组\n    int *p = new int[10];\n    // 然后类型转换\n    int (*p2)[5] = (int (*)[5])p;\n    for (int i=0;i<10;i++) p[i] = i+1;\n    for (int j=0;j<2;j++){ \n        for (int k=0;k<5;k++)\n            cout << p2[j][k] << \" \"; \n        cout << endl;\n    }\n    return 0;\n}\n```\n直接得到多维数组：\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    // 先定义一个中间类型\n    typedef int i5Array[5];\n    // 然后直接申请得到二维数组\n    i5Array* p = new i5Array[2];\n    for (int j=0;j<2;j++)\n        for (int k=0;k<5;k++)\n            p[j][k] = (j*5)+(k+1);\n    return 0;\n}\n```\n\n\n\n### 归还\n\nnew 对应 delete\n\n如果是数组，那么要用delete []\n\n实现的机制是\n\n在返回地址的上面一个地址记录申请到的size，所以返回的指针不能动，不然不能正确free\n\n```\nA *p = new A[10]\n如果是delete p\n只会调用一个析构函数\n但是如果是delete[] p\n会调用所有的析构函数\n\n如果是int的话就没区别，上面的区别是针对类的\n```\n\n\n\nmalloc 对应 free\n\n\n\n## 链表\n\n### 结点定义\n\n![image](https://s2.ax1x.com/2019/12/23/l9CaBn.png)\n\n### 插入操作\n\n表头插入需要判断表头是否为空，分为两种情况讨论\n\n![image](https://s2.ax1x.com/2019/12/23/l9Co9O.png)\n\n表为插入要求head非空\n\n找到next为null的节点，将next赋值\n\n![image](https://s2.ax1x.com/2019/12/23/l9CjEt.png)\n\n某个值的节点后面插入\n\n从head开始搜索，只要不是null，就判断值是否是a（短路表达式），一直循环下去\n\n循环外要判断是否为null\n\n![image](https://s2.ax1x.com/2019/12/23/l9Psat.png)\n\n某个值前面插入\n\n因为是单向链表，需要记录前一个节点（guard node）\n\n![](https://s2.ax1x.com/2019/12/23/l9iKFP.png)\n\n### 删除操作\n\n如果使用next来判断的话比较简单，不用保存前一个节点用于连接（见有序链表）\n\n否则要保存前一个节点用来连接\n\n![](https://s2.ax1x.com/2019/12/23/l9iaF0.png)\n\n\n\n### 有序链表\n\n基本结构：\n\n![](https://s2.ax1x.com/2019/12/23/l9iBSU.png)\n\n插入：\n\n类似于在节点后插入（简单一点，不用guard node）\n\n![](https://s2.ax1x.com/2019/12/23/l9FVpT.png)\n\n删除操作：\n\n使用next判断比较简单\n\n![](https://s2.ax1x.com/2019/12/23/l9kp8K.png)\n\n\n\n要特别注意指针操作：\n\n![](https://s2.ax1x.com/2019/12/23/l9FUnH.png)\n\n## 引用\n\n引用变量时必须要有初始化\n\n\n\n引用要保持类型相同，例如指针的引用仍然要是指针\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int *p = new int;\n    int *&x = p;\n    cout << *x << endl;\n    return 0;\n}\n```\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/l9eaDS.png)\n\n\n\n非const引用不能引用一个非左值\n\n```c++\nint main(){\n    // 错误\n    // int &p = 1;\n    // 正确\n    const int &p = 1;\n    return 0;\n}\n```\n\n\n\n如果函数返回值的类型是引用或指针类型，则不应把局部变量或局部变量的地址作为返回值返回。因为函数退出的时候会将栈破坏掉，局部变量都不会保留下来\n\n注意如果传入数组，返回数组中元素的引用，那是可以的\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint &max3(int x[], int num) { \n    int i, j;\n    j = 0;\n    for (i=1; i<num; i++)\n        if (x[i] > x[j]) j = i; \n    return x[j];\n}\n\nint main(){\n    int a[] = {1,2};\n    cout << max3(a, 2) << endl;\n    return 0;\n}\n```\n\n由于返回的是引用，甚至可以 max3(xxx, 2) = 100;\n\n\n\n对于指针来说也一样：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint * max2(int x[], int num) { \n    int *p,*q;\n    p = x; q = x+1; \n    while (num > 1){ \n        if (*q > *p) p = q;\n        q++; num--; \n    }\n    return p; \n}\n\nint main(){\n    int a[] = {1,2};\n    cout << *max2(a, 2) << endl;\n    return 0;\n}\n```\n\n\n\n释放堆中变量的引用\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int *p = new int(100);\n    int &x = *p;\n    cout << x << endl;\n    // 这里要取地址\n    delete &x;\n    return 0;\n}\n```\n\n","tags":["c++"],"categories":["c++"]},{"title":"C++学习笔记（四）","url":"/2019/12/17/C-学习笔记（四）/","content":"\n# 类继承\n\n## 成员函数\n\n两种成员函数\n\n1. 基类希望其派生类进行覆盖的函数，这一种函数是虚函数，当我们使用指针或引用调用虚函数时，该调用将被动态绑定，根据应用或指针所绑定的对象类型的不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数\n2. 基类不希望派生类进行覆盖的函数，这一类函数为非虚函数\n\n注意，如果派生类没有覆盖基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本\n\n\n\n## 类型转化\n\n派生类对象包含多个组成部分：含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的对象也有多个\n\n![image](https://s2.ax1x.com/2019/12/17/QoLJHg.png)\n\n## 派生类构造函数\n\n尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分\n\n派生类构造函数同样是铜鼓哦构造函数初始化列表来将实参传递给基类构造函数的\n\n\n\n## 静态类型和动态类型\n\n静态类型是在编译时就确定了的\n\n动态类型这是在变量或表达式表示的内存中的对象的类型，运行时才可知\n\n如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致\n\n用dynamic_cast请求类型转换，该转换的安全检查将在运行时执行\n\n用static_cast来强制覆盖掉编译器的检查工作，在编译期间就使得类型转化了\n\n\n\n## 虚函数\n\n引用或者指针调用一个函数的时候\n\n1. 如果说非虚函数，那么编译时期就可以确定\n2. 如果是虚函数，那么要到运行时刻才可以确定\n\n通过对象调用的函数编译时就可以确定，因为对象的类型是确定不变的（静态类型等于动态类型）\n\n虚函数一定要有定义，即使没有被用到；其他函数如果没有被用到，不需要给出定义\n\n\n\n### override\n\n这个关键字可以让编译器检查是否真的覆盖了虚函数\n\noverride关键字只能修饰虚函数\n\n\n\n### final\n\n如果被final修饰，那么将不能被覆盖\n\n只有虚函数才能被定义为final\n\n\n\n### 默认参数\n\n虚函数的默认参数是静态绑定的\n\n即如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也还是如此\n\n\n\n## 纯虚函数\n\n书写=0就可以将一个虚函数说明为纯虚函数\n\n含有纯虚函数的类是抽象类\n\n抽象类不能实例化\n\n派生类必须给出纯虚函数的实现，否则仍然是抽象类\n\n\n\n## 访问控制\n\n### protected\n\n与派生类分享，但是不会被其他类公共访问，可以看作是public和private中和后的产物\n\n派生类的成员或友元只能通过派生类对象来访问基类的受保护成员\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Father{\nprotected:\n    int a;\n    void g(){}\n};\n\nclass Son:public Father{\npublic:\n    // 子类不能直接访问父类中的protected成员或是方法\n    // 只能通过他的子类来使用\n    // void f(Father f){cout << f.a << endl;}\n    void f(Son s){cout << s.a << endl;s.g();}\n};\n\nint main(){\n    return 0;\n}\n```\n\n\n\n### 派生列表中的访问说明符\n\n派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么印象，对基类成员的访问权限只与积累中的访问说明符有关\n\n派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限\n\n\n\n## 类型转化\n\n对于代码中的某个节点来说，如果积累的公有成员是可访问的，则派生类向基类的类型转化也是可访问的；反之则不行\n\n例如：\n\n1. 如果是私有继承，那么用户代码不能使用派生类向基类的转化\n2. 无论D以什么方式继承B，D的成员函数和友元都可以使用派生类向基类的转化\n3. 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的转换\n\n\n\n## 友元和继承\n\n友元关系不能传递，不能继承\n\n基类的友元在访问派生类成员时不具有特殊性；派生类的友元也不能随意访问基类的成员\n\n每个类负责控制自己的成员的访问权限，因此如果基类定义了友元，那么这个友元可以访问之类中的基类部分，即使这一部分之类都无法访问，例如：\n\n```c++\nclass Father{\nprivate:\n    int father;\nprotected:\n    friend class F;\n};\n\nclass Son:public Father{\nprivate:\n    int son;\npublic:\n    void f(Son s){}\n};\n\nclass F{\npublic:\n    // F是父类的友元，因此可以访问Son中的Father的私有部分\n    // 尽管这一部分是Son都不能访问的\n    void f(Son s){cout << s.father << endl;}\n};\n```\n\n\n\n## 继承中的类作用域\n\n如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找改名字的定义\n\n### 在编译时就进行名字查找\n\n一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的，我们能使用哪些成员仍然是由静态类型决定的\n\n\n\n### 名字冲突与继承\n\n派生类的成员将隐藏同名的基类成员（因为在当前作用域中就已经找到了名字，就不会再去基类找了）\n\n可以通过using来使用一个被隐藏的基类成员\n\n![image](https://s2.ax1x.com/2019/12/18/QTfG6J.png)\n\n\n\n### 查找顺序\n\n![image](https://s2.ax1x.com/2019/12/18/QTfDpD.png)\n\n\n\n### 名字查找优先于类型检查\n\n即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉\n\n一旦名字找到，编译基就不再继续查找了，因此如果之类中有同名（只是同名，参数不一定相同）函数，就会覆盖掉基类中的所有同名函数\n\n\n\n### 虚函数的调用\n\n![image](https://s2.ax1x.com/2019/12/18/QThauj.png)\n\n![image](https://s2.ax1x.com/2019/12/18/QThyCT.png)\n\n![image](https://s2.ax1x.com/2019/12/18/QThDU0.png)\n\n\n\n### 覆盖重载的函数\n\n如果子类中有了一个同名的函数，那么基类中的所有函数都会被覆盖\n\n如果想继承所有的函数，但是只是覆盖掉其中几个，可以用using语句\n\n```c++\nclass Father{\npublic:\n    void f(){cout << \"Father f()\" << endl;}\n    void f(int){cout << \"Father f(int)\" << endl;}\n};\n\nclass Son:public Father{\npublic:\n    using Father::f;\n    void f(){cout << \"Son f()\" << endl;}\n};\n\n\nint main(){\n    Son s;\n    s.f();\n    // 使用了using就可以继承父类的所有同名方法了\n    // 只会覆盖掉其中子类自定义的版本\n    s.f(1);\n    return 0;\n}\n```\n\n\n\n## 构造函数与拷贝控制以及析构函数\n\n无论是合成的默认构造函数，还是拷贝构造函数，还是赋值运算符，还是析构函数，它们除了负责自己的那一部分，还要负责直接基类中的那一部分的对应行为\n\n因此如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问的函数，则派生类中对应的成员是被删除的，因为编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或者销毁操作\n\n\n\n### 析构函数\n\n基类的析构函数一般要定义成虚函数，这样就可以动态调用到子类的析构函数，正确释放资源\n\n析构函数和其他不同，只要负责自己销毁，因为会自动调用父类的析构进行销毁，但是例如构造函数、拷贝控制，都要现式写明调用情况或是拷贝的情况。\n\n即子类的析构函数只要析构自己就行了，不用再写任何其他的代码\n\n```c++\nclass A{\npublic:\n    ~A(){cout << \"Father's ~\" << endl;}\n};\n\nclass B:public A{\npublic:\n    ~B(){cout << \"Son's ~\" << endl;}\n};\n\nint main(){\n    B b;\n    // 输出为\n    // Son's ~\n    // Father's ~\n    return 0;\n}\n```\n\n\n\n### 构造函数\n\n之前已经看到过了，如果要使用基类的特定构造函数，要显式写明\n\n下面是调用拷贝构造函数和其他构造函数的写法：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    int a;\n    A(){cout << \"A's A()\" <<endl;}\n    A(int a):a(a){cout << \"A's A(int)\" << endl;}\n    A(const A& a){cout<<\"A's copy constructor\"<<endl;}\n};\n\nclass B: public A{\npublic:\n    B(){}\n    // 指定调用父类的某个构造函数\n    B(int a):A(a){}\n};\n\nclass C:public A{\npublic:\n    C(){}\n    C(const C& c){ cout << \"C's copy constructor\"<<endl;}\n};\n\nclass D:public A{\npublic:\n    D(){}\n    D(const D& d):A(d){ \n        cout << \"D's copy constructor\"<<endl;\n    }\n};\n\nint main(){\n    // 如果子类没有指明调用父类的哪个构造函数\n    // 那么调用默认构造函数\n    B b0;\n    B b(100);\n    cout << endl;\n    // 如果子类没有自己定义拷贝构造函数\n    // 那么会自动调用父类的拷贝构造函数\n\n\n    // 使用子类合成拷贝构造函数\n    // 将调用父类的拷贝构造函数\n    B b2(b);\n    cout << endl;\n\n    // 如果子类自定义了拷贝构造函数\n    // 而没有指定基类部分如何拷贝\n    // 那么默认掉用父类的默认构造函数\n    C c;\n    C c2(c);\n    cout << endl;\n\n    // 如果在初始化列表中指明调用了基类的拷贝构造函数\n    // 那么会正确拷贝基类部分\n    D d0;\n    D d1(d0);\n    return 0;\n}\n```\n\n析构函数的执行顺序和构造函数相反：派生类的析构函数首先执行，然后是基类的析构函数；基类的构造函数先执行，然后是派生类的构造函数\n\n\n\n### 拷贝控制\n\n合成的拷贝控制成员负责本类的赋值操作，还要负责直接基类中对应的操作。即要负责直接基类部分的复制\n\n上面已经看了拷贝构造函数的写法，下面看赋值运算符的写法\n\n同样也要显式写出：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    A& operator=(A& a){ cout << \"A's =\" << endl;return *this;}\n};\n\nclass B:public A{\npublic:\n    B & operator=(B& a){ cout << \"B's =\" << endl;return *this;}\n};\n\nclass C:public A{\npublic:\n    C & operator=(C& a){ \n        // 注意写法\n        A::operator=(a);\n        cout << \"C's =\" << endl;return *this;\n    }\n};\n\nint main(){\n    // 默认不会调用基类的赋值操作\n    // 因此不会拷贝基类部分\n    B b1;\n    B b2;\n    b1 = b2;\n    cout << endl;\n\n    // 需要显式写出调用基类的赋值运算符\n    C c1;\n    C c2;\n    c1 = c2;\n    return 0;\n}\n```\n\n注意这里调用赋值运算符的特殊写法\n\n上面传递给基类的赋值运算符的时候，基类只会释放掉基类部分的空间，并且进行赋值，因此不会有问题\n\n无论基类的构造函数或赋值运算符是定义一的还是合成的，派生类的对应操作都能使用它们\n\n\n\n### 番外：在构造函数和析构函数中调用虚函数\n\n执行虚构的时候，部分已经被销毁\n\n执行构造的时候，还未完成对象创建\n\n为了能够正确处理这种未完成状态，编译器认为对西那个的类型在构造或析构的过程中反复发生了改变一样（即类型是不确定的，按照当前构造或是析构的程度来确定当前的状态）\n\n也就是说，当我们构建一个对象时，需要把对象的类和构造函数的类看作是同一个：对虚构函数的调用绑定真好符合这种把对象的类和构造函数的类看成同一个的要求，对析构函数也是同样的道理\n\n上述绑定不但对直接调用虚函数有效，对间接调用也是有效的\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    A(){f();}\n    virtual void f(){cout << \"A's f()\"<<endl;}\n    virtual ~A(){f();}\n};\n\nclass B:public A{\npublic:\n    void f(){cout << \"B's f()\"<<endl;}\n};\n\nint main(){\n    // 无论是构造过程还是析构过程\n    // 调用的都是A的f()\n    // 因为到A的时候\n    // 1. B还没有构造\n    // 2. B已经析构\n    // 因此调用的都是A的f\n    B b;\n    return 0;\n}\n```\n\n\n\n## \"继承\"构造函数\n\n类不能继承默认、拷贝和移动构造函数，因为编译器会为派生类合成默认的\n\n和\"继承\"别的函数一样，使用using即可，不过using完了之后，其他函数是直接照搬过来，但是对于构造函数，编译器会稍作修改\n\n![image](https://s2.ax1x.com/2019/12/18/QTqAUJ.png)\n\n还有一个区别就是，普通函数的using可以改变访问级别，例如我在private里面using，那么\"继承\"下来的函数就会是private的，但不是构造函数不一样，基类的私有构造函数在派生类中还是一个私有构造函数，而不管using出现在哪\n\n\n\n![image](https://s2.ax1x.com/2019/12/18/QTqBVg.png)\n\n![image](https://s2.ax1x.com/2019/12/18/QTqIIJ.png)\n\n\n\n## 容器与继承\n\n容器内要放同一个类型的对象\n\n不能放基类，否则会被切片\n\n因此要放指针\n\n\n\n当容器深拷贝时，不能直接push指针（否则就是浅拷贝），因此需要将一个clone函数处理成虚函数，这样就可以根据类型动态调用深拷贝\n\n对于数组来说，下标运算符其实是指针的偏移，而指针的偏移是按照静态类型来计算的，因此不要把数组看作是多态的\n\n![image](https://s2.ax1x.com/2019/12/18/QTXkVS.png)","tags":["c++"],"categories":["c++"]},{"title":"C++学习笔记（三）","url":"/2019/12/17/C-学习笔记（三）/","content":"\n# 拷贝赋值和销毁\n\n## 拷贝构造函数\n\n形式：\n\n![image](https://s2.ax1x.com/2019/12/17/QIVR9f.png)\n\n即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数\n\n合成的拷贝构造函数的默认行为：对于类类型的成员，会使用其拷贝构造函数来拷贝，内置类型直接拷贝，对于数组，一个一个拷贝数组类型的成员，如果数组类型是类类型，则使用元素的拷贝构造函数来进行拷贝。注意以上的拷贝为浅拷贝\n\n\n\n### 调用时机\n\n![image](https://s2.ax1x.com/2019/12/17/QIVXgU.png)\n\n\n\n## 拷贝赋值运算符\n\n形式：\n\n```c++\nclass Foo {\npublic:\n  Foo& operator=(const Foo&);\n}\n```\n\n通常应该返回一个指向其左侧对象的引用\n\n\n\n### 合成拷贝赋值运算符\n\n与拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为生成一个合成拷贝构造函数。行为和合成的拷贝构造函数一样\n\n\n\n## 析构函数\n\n与构造函数相反，销毁对象的非static数据成员\n\n\n\n### 形式\n\n```c++\nclass Foo {\npublic:\n  \t~Foo();\n}\n```\n\n\n\n### 合成析构函数\n\n如果没有定义自己的析构函数，那么会合成一个析构函数，默认函数体为空。析构函数体自身并不直接销毁成员。成员是在析构函数之后隐含的析构阶段中被销毁的，整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的\n\n\n\n## 三五法则\n\n![image](https://s2.ax1x.com/2019/12/17/QIe1oR.png)\n\n\n\n## =default\n\nhttps://stackoverflow.com/questions/6502828/what-does-default-mean-after-a-class-function-declaration\n\n```c++\nclass C {\n  C(const C&) = default;\n  C(C&&) = default;\n  C& operator=(const C&) & = default;\n  C& operator=(C&&) & = default;\n  virtual ~C() { }\n};\n```\n\n只能对具有合成版本的成员函数使用=default，来显式地要求编译器生成合成的版本\n\n\n\n## 阻止拷贝\n\n阻止拷贝行为，因为对于有些类来说拷贝没有意义，例如io\n\n\n\n### 定义删除的函数\n\n=delete关键字表明不希望定义这些成员\n\n但是注意析构函数不能是删除的成员，因为如果析构函数被喊出，就无法销毁此类型的对象了，但是可以动态分配这种类型的对象，只是无法释放\n\n\n\n### private\n\n通过将拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝\n\n\n\n## 自我赋值\n\n自我赋值处理不当可能会导致内存泄漏，正确的处理自我赋值的情况：\n\n![image](https://s2.ax1x.com/2019/12/17/QImrB4.png)\n\n![image](https://s2.ax1x.com/2019/12/17/QImfgK.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["c++"],"categories":["c++"]},{"title":"C++学习笔记（二）","url":"/2019/12/16/C-学习笔记（二）/","content":"\n# 模板\n\n两种：类属函数，类属类\n\n\n\n## 类属函数\n\n同一函数对不同类型的数据完成相同的操作\n\n宏实现的缺陷：\n\n1. 只能实现简单的功能\n2. 没有类型检查\n\n函数重载的缺陷：\n\n1. 需要定义的重载函数太多\n2. 定义不全\n\n函数指针：\n\n![image](https://s2.ax1x.com/2019/12/16/Q5Pwxs.png)\n\n\n\n1. 需要定义额外参数\n2. 大量指针运算\n3. 实现起来复杂\n4. 可读性差\n\n\n\n这就是template引入的目标：完全，清晰\n\n![image](https://s2.ax1x.com/2019/12/16/Q5Pfz9.png)\n\nT类型只要符合：重载>操作符，有=操作符（默认有），有拷贝构造函数（默认有）（尽量使用const &的方式，可以避免使用拷贝构造）。\n\n\n\n函数模版在编译的时候会根据传入的类型生成另一段代码，即编译系统自动实例化函数模板\n\n\n\n函数模板的参数可以是普通参数，不过调用的时候需要显式实例化，例如：\n\n![image](https://s2.ax1x.com/2019/12/16/Q5PvQA.png)\n\n\n\n调用顺序：\n\n1. 调用非模板函数\n2. 模板的显式化版本\n3. 调用模板\n\n\n\n其中模板的显式化版本的意思是 https://zh.cppreference.com/w/cpp/language/template_specialization\n\n对于某个模板，可以直接给定它的类型，将其实例化\n\n例如：\n\n显式特化必须出现在非特化模板声明后\n\n```c++\ntemplate<class T> class X { /*...*/ }; // 主模板\ntemplate<> class X<int> { /*...*/ }; // 同命名空间中的特化\ntemplate<class T> class Y { /*...*/ }; // 主模板\ntemplate<> class Y<double>; // 对 double 特化的前置声明\n```\n\n当特化函数模板时，若能从函数实参予以提供，则可忽略其实参：\n\n\n```c++\ntemplate<class T> class Array { /*...*/ };\ntemplate<class T> void sort(Array<T>& v); // 主模板\ntemplate<> void sort(Array<int>&); // 对 T = int 的特化\n// 不需要写为\n// template<> void sort<int>(Array<int>&);\n```\n\n\n\n## 类属类\n\n类属类必须显式实例化，因为类要做检查，例如push的时候就要保证每次push的都是同一个类型\n\n![image](https://s2.ax1x.com/2019/12/16/Q5FWuR.png)\n\n类模板中的静态成员属于实例化后的类而不是模板\n\n是否实例化模板的某个实例由使用点来决定；如果未使用到一个模板的某个实例，则编译系统不会生成相应实例的代码\n\n\n\nn如果在模块A中要使用模块B中定义的某模板的实例，而在模块B中未使用这个实例，则模块A无法使用这个实例（因为并没有生成对应代码）\n\n\n\n模板元编程\n\n![image](https://s2.ax1x.com/2019/12/16/Q5A201.png)\n\n\n\n# 异常处理\n\n常见处理方法：\n\n1. 函数参数（返回值或引用参数）\n2. 逐层返回\n\n缺点：程序结构不清楚\n\n\n\n## 类型转化\n\n*比重载严格，需要精确匹配*\n\n*只有三种情况可以转化：*\n\n*除了非**const**到**const*\n\n*从派生类到基类*\n\n*从数组或函数到指向数组或函数的指针*\n\n\n\n## 静态编译\n\n下面的代码的输出为\n\nderived f()\nBase\nbase f()\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass BaseException{\npublic:\n    int a;\n    BaseException():a(1){}\n    virtual void f(){cout << \"base f()\" << endl;}\n};\n\nclass DerivedException: public BaseException{\npublic:\n    int a;\n    DerivedException():a(100){}\n    void f(){cout << \"derived f()\" << endl;}\n};\n\nvoid f(){\n    DerivedException e;\n    throw e;\n};\n\nint main(){\n    try{\n        try{\n            f();\n            // 引用和切片的区别在于这个catch里面能否获得动态绑定的类型\n            // 抛出的时候都是基类（编译类型）\n        }catch(BaseException& a){\n            a.f();\n            throw a;\n        }\n    }catch(DerivedException a){\n        cout << \"Derived\" << endl;\n        a.f();\n    }\n    catch(BaseException a){\n        cout << \"Base\" << endl;\n        a.f();\n    }\n    return 0;\n}\n```\n\n\n\n# RAII\n\n资源获得即初始化，解决多出口、碎片问题\n\n例子：智能指针\n\n如下：\n\n![](https://s2.ax1x.com/2020/01/06/ly6hy8.png)\n\n\n\n# 非虚接口解决打印问题\n\n如果父类有打印的全局函数，想要子类也有自己的打印函数，可以再写一个，但是解决不了\n\n```c++\nFather &f = son;\ncout << f << endl;\n```\n\n因此需要用到非虚接口\n\n即在父类中写一个虚函数（子类有自己的版本），通过该虚函数可以调用到不同的版本的打印\n\n然后再重载操作符，非虚函数调用虚函数\n\n![](https://s2.ax1x.com/2020/01/06/lyc31P.png)\n\n\n\n# 原型模式解决复制问题\n\n用了一个父类的指针，又要具体的子类复制\n\n![](https://s2.ax1x.com/2020/01/06/lycD10.png)\n\n![](https://s2.ax1x.com/2020/01/06/lyc6nU.png)\n\n\n\n# 不要把数组处理成多态\n\n指针偏移会有问题，偏移量是静态编译计算好的，如果说子类的大小和父类一样，那么没有问题，否则不能正确偏移\n\n![](https://s2.ax1x.com/2020/01/06/lycWN9.png)\n\n","tags":["c++"],"categories":["c++"]},{"title":"C++学习笔记（一）","url":"/2019/12/06/C-学习笔记（一）/","content":"\n# 运算符重载\n\n## 条件\n\n不能重载内置类型的操作符，因此至少有一个运算分量是自定义类型\n\n\n\n## 分类\n\n从重载的形式来看：\n\n1. 作为成员函数重载\n2. 作为全局函数重载\n\n其中，如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的thi指针上\n\n\n\n从运算分量的数目来看：\n\n1. 单目\n2. 双目\n\n其中对于二元运算来说，左侧运算对象传递给第一个参数，而右侧对象传递给第二个参数\n\n\n\n## 不能被重载的操作符\n\n![image](https://s2.ax1x.com/2019/12/06/QYkIht.png)\n\n四个操作符不能被重载\n\n\n\n## 不推荐被重载的操作符\n\n逗号、取地址、逻辑与和逻辑或运算符\n\n因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。\n\n除此之外，&&和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值\n\n还有一个原因使得我们一般不重载逗号运算符和取地址运算符：C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应\n\n\n\n## 基本原则\n\n遵循原有的语法：单目/双目、优先级、结合性\n\n\n\n## 选择成员还是非成员重载\n\n![image](https://s2.ax1x.com/2019/12/06/QYAWvT.png)\n\n对于第一条：\n\n原因是：编译器如果遇到内置类型作为运算分量的操作符，那么无法识别，会先去类内找有无重载版本，然后再在全局找有无重载版本，这四个函数有内部合成的函数，例如=对应的是赋值操作，类内已有合成的默认行为，因此如果是全局重载，编译器根本不会找到，优先找类内部的重载版本\n\n\n\n一个错误的示例：\n\n![image](https://s2.ax1x.com/2019/12/06/QYEFRP.png)\n\n这里产生错误的原因是有一对矛盾冲突：即类内操作符重载要求第一个参数必须是本类本对象的this指针，而双目运算要求第一个参数是必须是双目操作符左边的运算分量\n\n同样的一个例子是<<操作符的重载版本只能是全局重载\n\n\n\n## 双目操作符重载\n\n### 重载形式\n\n两种形式：\n\n![image](https://s2.ax1x.com/2019/12/06/QYEuIs.png)\n\n![image](https://s2.ax1x.com/2019/12/06/QYENdJ.png)\n\n全局函数重载，写成友元函数friend\n\n双目运算符为了支持对称调用，一般做如下处理\n\n![image](https://s2.ax1x.com/2019/12/06/QYEbwQ.png)\n\n\n\n### 返回值\n\n一般来说双目运算返回的是一个临时变量（右值）\n\n而单目运算符如果需要改变自身状态的话，返回引用（左值）\n\n\n\n### 返回值的编译优化\n\n一个例子：\n\n![image](https://s2.ax1x.com/2019/12/06/QYViTJ.png)\n\n\n\n## 单目操作符重载\n\n### 重载形式\n\n![image](/Users/cengshaoxun/Library/Application Support/typora-user-images/image-20191209213530405.png)\n\n## 例子和特殊例子\n\n### 输出运算符<<\n\n```c++\nclass A{\nprivate:\n    int a;\npublic:\n    A(int a):a(a){}\n    friend ostream& operator<<(ostream &os, const A& a);\n};\n\nostream& operator<<(ostream &os, const A& a){\n    os << a.a;\n    return os;\n}\n```\n\n第一个形参四一个非常量ostream对象的引用，因为要修改它的值\n\n第二个形参为常量引用\n\n返回的是ostream的引用，这样可以链式调用\n\n必须是非成员函数\n\n一般声明成friend友元\n\n\n\n### 输入运算符>>\n\n```c++\nclass A{\npublic:\n    int a;\n    friend istream& operator>>(istream &is, A& a);\n};\n\nistream& operator>>(istream &is, A& a){\n    is >> a.a;\n    return is;\n}\n```\n\n和<<运算符不同的是第二个形参是非const的，因为要改变它的值\n\n\n\n### 算数和关系运算符\n\n一般定义成非成员函数，这样可以对类型进行转化\n\n形参一般都是const，因为不需要改变值\n\n结果常常位于一个局部变量之内，返回该局部变量的副本作为结果\n\n\n\n#### ==运算符\n\n返回的是bool值\n\n```c++\nclass A{   \npublic:\n    int a;\n    friend bool operator==(const A& a1, const A& a2);\n};\n\nbool operator==(const A& a1, const A& a2){\n    return a1.a==a2.a;\n}\n```\n\n\n\n#### <运算符\n\n形式和和==基本上一样\n\n```c++\nclass A{   \npublic:\n    int a;\n    friend bool operator<(const A& a1, const A& a2);\n};\n\nbool operator<(const A& a1, const A& a2){\n    return a1.a<a2.a;\n}\n```\n\n\n\n#### +运算符\n\n这里不采用全局重载的形式，而是类内重载\n\n```c++\nclass A{\npublic:\n    int a;\n    const A operator+(const A& a) const;\n};\n\nconst A A::operator+(const A& a) const{\n    A ta;\n    ta.a = this->a;\n    ta.a += a.a;\n    return ta;\n}\n```\n\n形参为const &，返回类型为const，不需要引用\n\n末尾加上const，这样即使是const对象也可以调用\n\n\n\n如果要和内置类型做加法，那么可以这样写\n\n```c++\nclass A{\npublic:\n    int a;\n    A(){}\n    // 可以定义包含一个参数的构造函数\n    // 这样int可以自动转化成A对象\n    // 然后+函数为全局重载\n    // 这样无论int在前还是在后\n    // 都可以自动转化成A，然后调用该运算符\n    A(int a):a(a){}\n    friend A const operator+(const A& a1, const A& a2);\n};\n\nA const operator+(const A& a1, const A& a2){\n    A ta;\n    ta.a = a1.a;\n    ta.a += a2.a;\n    return ta;\n}\n```\n\n构造函数只有一个int参数，这样int就会自动转化成A类型，无论是在+前还是后，都可以正确计算\n\n也可以使用()类型转化运算符进行转化，如果()和只有一个参数的构造函数共存的时候，有可能会产生冲突，见下面的()运算符\n\n\n\n### +=运算符\n\n不是一定要类内重载，也可以全局重载\n\n```c++\nclass A{\npublic:\n    int a;\n    A& operator+=(const A& a);\n};\n\nA& A::operator+=(const A& a){\n    this->a += a.a;\n    return *this;\n}\n```\n\n\n\n\n\n### 前缀++和后缀++\n\n主要区别在返回值和参数上\n\n![image](https://s2.ax1x.com/2019/12/09/Q08Wfs.png)\n\n### 赋值操作符\n\n默认是浅拷贝\n\n例如如果对象在heap上有分配空间，拷贝的时候会指向同一块内存空间，那么就会导致一个对象析构的时候另一个对象的指针飞了\n\n但是就算重载了赋值操作，例如下面这段代码，如果是自我赋值的话，仍然会出现问题，因此还要避免自我赋值\n\n![image](https://s2.ax1x.com/2019/12/09/Q0JQr6.png)\n\n可以自我赋值的版本：\n\n```c++\nclass MString{\npublic:\n    string *p;\n    // 可以自我赋值的一种写法\n    MString& operator=(const MString& s){\n        // 临时拷贝底层的指针\n        string *ts = new string(*(s.p));\n        // 释放内存\n        delete p;\n        // 拷贝到自己\n        this->p = ts;\n        // 返回自己\n        return *this;\n    }\n};\n```\n\n接受的参数为const &，返回的是&\n\n注意四个步骤的顺序不能打乱，否则自我赋值会有问题\n\n\n\n### 下标运算符\n\n[]运算符只能在类内重载，不能作为全局函数重载\n\n一般都要重载两个版本（const的和非const的）\n\n非const版本返回引用，可以作为左值被修改\n\nconst版本的返回值可以不是引用\n\n![image](https://s2.ax1x.com/2019/12/09/Q0YWfH.png)\n\n多维数组的情况：\n\n如果是二维的数组，那么其实只要返回指针，第二次的[]操作其实用的是指针的[]\n\n如果是多维的数组，那么可以嵌套一个内部类\n\n如下：\n\n![image](https://s2.ax1x.com/2019/12/09/Q0UUk8.png)\n\n这样就可以实现多个维度的嵌套\n\n\n\n### ( )运算符\n\n只能是成员函数\n\n既是函数调用，也是类型转化（也可以通过带有一个参数的构造函数重载，然后直接赋值，同样也可以达到隐式转化的目的；两个转化的方向不同，一个是将本类转为其他——（）运算符，一个是将其他转为本类—— 构造函数）\n\n#### 作为类型转化操作符\n\n可以减少混合计算中需要定义的操作符重载函数的数量（也可以通过写成构造函数的形式，将传入的参数转为本类型）\n\n如下：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Rational { \npublic:\n    Rational(int n1, int n2) { n = n1; d = n2; } \n    // 重载构造函数也可以达到隐式类型转化的目的\n    Rational(double d){cout << \"constructor\" << endl;}\n    operator double() { cout << \"operator ()\" << endl; return  (double)n/d; }\n    // 可以和()共存，最佳匹配，直接匹配到这个函数\n    double operator+(double d){cout << \"operator +\" << endl; return d + n/d;}\n    // 当调用的时候有Rational+double的时候不能和()共存\n    // 因为都要进行类型转化，无法确定是调用这个函数，将double转为Rational，还是调用()，将Rational转为都变了\n    // 两个都可以转化，产生歧义\n    // 但是如果调用的情况是double+Rational，那么则可以，因为只能是Rational通过()运算符转化为double\n    // double operator+(Rational d){cout << \"operator +\" << endl; return 0;} \nprivate:\n    int  n, d;\n};\n\nint main(){\n    Rational  rr = 1.1;\n    Rational  r(1,2);  \n    // 调用()进行类型转化\n    double x = r;  \n    // 如果参数和operator +匹配的话那么优先调用operater +\n    // 否则调用()\n    x = r + x; \n    cout << x << endl;\n    return 0;\n}\n```\n\n#### 其他类型转化二义性冲突汇总\n\n可以看到上面这个例子中有潜在的冲突（见注释）\n\n还有一种冲突如下：\n\n```c++\nstruct B;\nstruct A{\n  A() = default;\n  A(const B&);  // B转化成A\n};\nstruct B{\n  operator A() const;  // B转化成A\n};\nA f(const A&e);\nB b;\nA a = f(b);  // 冲突，有两种转化方式！！！\n```\n\n上面代码中有两种B转化成A的方式，因此就存在二义性，会冲突\n\n\n\n还有一种冲突如下：\n\n```c++\nstruct A{\n  A(int = 0);\n  A(double);\n  operator int() const;\n  operator double() const;\n}\n\nvoid f2(long double);\nA a;\nf2(a);\n\nlong lg;\nA a2(lg);\n```\n\n当参数无法精确匹配的时候，且int转化为long double和double转化为long double转化的优先级一致，因此产生了冲突\n\n同样，初始化a2的时候，long转化为double和long转化为int也是没有优先级的，因此产生了错误\n\n如果有优先级，那么其实是可以的：\n\n```c++\nshort s = 42;\nA a3(s);\n```\n\n因为short优先转化成int，所以没问题\n\n\n\n还有一种冲突如下：\n\n```c++\nstruct C{\n  C(int);\n};\nstruct D{\n  D(int);\n}\n\nvoid manip(const C&e);\nvoid manip(const D&e);\nmanip(10);\n```\n\n两个函数都可以匹配\n\n\n\n#### 作为函数调用重载\n\n可以实现函数对象，在标准库中广泛使用\n\n![image](https://s2.ax1x.com/2019/12/09/Q00B5V.png)\n\n![image](https://s2.ax1x.com/2019/12/09/Q00fV1.png)\n\n![image](https://s2.ax1x.com/2019/12/09/Q00456.png)\n\n![image](https://s2.ax1x.com/2019/12/09/Q00bKH.png)\n\n函数对象也有局限性，即如果定义的接口是指针，那么不能传入函数对象，因为类型不同\n\n![image](https://s2.ax1x.com/2019/12/09/Q00XVI.png)\n\n于是可以使用function类型，这个类型的接口可以传入所有可调用类型\n\n![image](https://s2.ax1x.com/2019/12/09/Q0BpRS.png)\n\n但是有个缺点就是重载函数不行，还得用函数指针或是lambda对象\n\n![image](https://s2.ax1x.com/2019/12/09/Q0BPMQ.png)\n\n### -> 操作符\n\n![image](https://s2.ax1x.com/2019/12/16/Q5CwB6.png)\n\n智能指针\n\n![image](https://s2.ax1x.com/2019/12/16/Q5C7CQ.png)\n\n![image](https://s2.ax1x.com/2019/12/16/Q5Cqvn.png)\n\nNew有两个作用：不确定数目的情况下，用new动态新建对象；跨越作用域，全生命周期\n\n问题就是**new**出来的对象会跨越作用域，但是如果是如果包装成一个对象，那么就会失去长生命周期\n\n\n\n### new、delete\n\n![](https://s2.ax1x.com/2020/01/06/lyD4UI.png)\n\n![](/Users/cengshaoxun/Library/Application Support/typora-user-images/image-20200106225006478.png)\n\n![](https://s2.ax1x.com/2020/01/06/lyrURf.png)\n\n定位new：除了size有其他的参数，特殊版本就是：传入地址，在制定地址分配空间\n\nhttps://blog.csdn.net/zhangxiangDavaid/article/details/43899351\n\n需要定义一个对应的delete\n\nhttps://www.cnblogs.com/lidan/archive/2012/02/19/2358706.html\n\n\n\n","tags":["c++"],"categories":["c++"]},{"title":"c++容器库（二）","url":"/2019/10/12/c-容器库（二）/","content":"\n# 顺序容器\n\n![image-20191013105905432](https://s2.ax1x.com/2019/10/13/uj7zmn.png)\n\n## 添加元素\n\n容器元素是拷贝。即容器中的元素与提供值的对象之间没有任何关联，修改容器的值不会影响到原始对象，反之亦然。\n\n1. push_back\n\n   追加元素到尾部。array和forward_list不支持此操作。（string支持此操作）\n\n2. push_front\n\n   在头部插入。\n\n   list, forward_list, deque支持此操作\n\n   vector不支持此操作。\n\n3. insert单一插入\n\n   任意位置插入\n\n   接受一个迭代器\n\n   在迭代器之前插入\n\n   vector不支持push_front，但是可以用insert来在前面插入\n\n4. insert范围插入\n\n   ![image-20191013104103186](https://s2.ax1x.com/2019/10/13/ujHMtK.png)\n\n   插入10个\"Anna\"\n\n   \n\n   ![image-20191013104147612](https://s2.ax1x.com/2019/10/13/ujHm01.png)\n\n   **注**：insert会返回指向第一个新加入元素的迭代器。\n\n   ![image-20191013104502458](https://s2.ax1x.com/2019/10/13/ujH1pD.png)\n\n5. emplace\n\n   emplace可以构造元素，而不单单是拷贝\n\n   参数必须与元素的构造参数相匹配\n\n\n\n## 访问元素\n\n包括array在内的每个顺序容器都有一个front函数，除了forward_list之外所有顺序容器都有一个back函数。分别返回首元素和尾元素的引用。\n\n访问容器内容还可以通过解引用迭代器来完成。\n\n![image-20191013110337127](https://s2.ax1x.com/2019/10/13/ujbSjH.png)\n\n注意这里的end迭代器要先递减，然后再解引用。\n\n![image](https://s2.ax1x.com/2019/10/13/ujOA4x.png)\n\n注意访问容器中的元素都是引用访问，因此可以更改值。\n\n如果容器是const的，那么返回的是const的引用。\n\n**注1**：如果用auto c = a.back()，那么返回引用，但是auto自动推断不是引用。要写成auto &c = a.back()\n\n**注2**：下标安全性问题。用下标运算符不会检查越界问题，可以使用at函数，会抛出异常。\n\n![image](https://s2.ax1x.com/2019/10/15/KCGoes.png)\n\n\n\n## 删除元素\n\n1. pop_front和pop_back\n\n   分别删除首元素和尾元素。\n\n   vector和string不支持push_front，也不支持pop_front。\n\n   forward_list不支持pop_back。\n\n   这两个函数的返回值都是void，因此如果需要弹出元素的值，那么需要提前取出。\n\n2. erase\n\n   允许从容器中的指定位置删除元素。","tags":["c++","容器","stl"],"categories":["c++"]},{"title":"c++容器库（一）","url":"/2019/10/06/c-容器库（一）/","content":"\n# 容器库操作层次\n\n- 所有容器类型都提供的\n- 仅针对三大容器类型中的一种：顺序容器、关联容器、无需容器\n- 仅适用于一小部分容器\n\n\n\n# 所有容器类型通用操作\n\n## 头文件\n\n容器一般在和容器同名的头文件中声明。\n\n\n\n## 类型\n\n所有的容器类型都是模版类，因此可以限定类型\n\n\n\n## 通用操作\n\n![image](https://s2.ax1x.com/2019/10/06/u62jyj.png)\n\n\n\n## 迭代器\n\n### 迭代器的范围\n\n[begin, end)\n\n\n\n### 迭代器大小\n\n只有能够随机访问的容器的迭代器才可以比较大小，例如vector；list因为不是随机的，因此只能比较是否相等：\n\nhttp://www.cplusplus.com/reference/iterator/\n\n![image](https://s2.ax1x.com/2019/10/06/u6RMtK.png)\n\n即这个写法是错的：\n\n![image](https://s2.ax1x.com/2019/10/06/u6RLAx.png)\n\n\n\n### 正向反向迭代器\n\niterator和reverse_iterator。\n\n反向迭代器的所有操作都会相反。\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n    vector<int> v;\n    v.push_back(1);\n    v.push_back(2);\n    vector<int>::reverse_iterator rit;\n    for(auto rit = v.rbegin(); rit != v.rend(); rit++) {  // rbegin和reverse_iterator是配套的\n        cout << *rit << endl;  // 注意这里要解引用\n    }\n\n    return 0;\n}\n```\n\n\n\n### const迭代器\n\n当使用begin的时候，会根据容器的内容来决定是否是一个const_iterator。\n\n![image](https://s2.ax1x.com/2019/10/06/u6fXlD.png)\n\n如果使用begin而且是一个const_iterator，那么就会报错：（报错）\n\n```c++\nconst vector<int> cv;\nvector<int>::iterator cvi = cv.begin();\n```\n\n\n\n## 其他容器类型\n\n容器定义了很多类型，这些类型和具体的容器类型以及他的模版类型都有关系，例如迭代器类型和size_type。\n\n元素类型：value_type\n\n元素类型的一个引用：reference或const_reference\n\n迭代器距离：difference_type\n\n\n\n## 容器初始化\n\n![image](https://s2.ax1x.com/2019/10/06/u64oPx.png)\n\narray并不适用于 C c(b,e) 这种初始化，这一点和数组比较像。\n\n如果提供的值小于容量，那么其余的都是0，例如：\n\n```c++\narray<int, 10> a = {42};  // 第一个元素为42，其余为0\n```\n\n不提供值，那么里面的值是不确定的。\n\n注意：\n\n```c++\narray<int, 10> a{};\n```\n\n这样会初始化为全0。\n\n\n\n### PS：数组初始化\n\n数组中如果：\n\n```c++\nint a[100] = {0};\n```\n\n是全0，如果改成非0的数就只有第一个数赋值了，剩余的都是0\n\n如果:\n\n```c++\nint a[100];\n```\n\n那么如果是全局或者静态变量，是0，否则是随机值。\n\n注意：\n\n```c++\nint a[100]{};\n```\n\n也会初始化为全0\n\n\n\n\n\n注意虽然array没有迭代器，但是仍然可以用指针来初始化，例如：\n\n```c++\nint arr[3];\narr[0] = 1;\narr[1] = 2;\narr[2] = 3;\nvector<int> v(arr, arr+3);\n```\n\n\n\n### 初始化和拷贝\n\n创建一个容器为另一个容器拷贝时，类型必须严格匹配；\n\n用迭代器参数来指定拷贝范围时，不需要严格匹配。\n\n例如：\n\n![image](https://s2.ax1x.com/2019/10/06/u65zm4.png)\n\n注：容器的拷贝不管是容器本身还是里面的元素，都是深度拷贝，不会影响原来的值。\n\n\n\n### array的初始化\n\narray不是数组，但是很像数组。也有固定大小，初始化必须指定array大小。\n\n数组可以直接赋值给array。\n\n\n\n## 交换和赋值\n\n![image](https://s2.ax1x.com/2019/10/06/uc3or9.png)\n\nassign的两种形式：\n\n```c++\nnames.assign(oldstyle.cbegin(), oldstyle.cend())\n```\n\n```c++\nslist1.assign(10, \"Hiya!\");\n```\n\n注意assign的参数类型不必严格匹配，但是用=赋值必须保证参数类型严格匹配。\n\nassign之后指向原来容器的所有指针都会失效，例如迭代器等。\n\n\n\nswap可以高效交换两个相同类型的容器，除了array外，只是交换和数据结构，而不是真实的内存，所有指针不会失效，但是仍然指向原来的元素。\n\narray特殊，真正交换了元素，交换时间与个数成正比，而且指针指向的内容也发生了变化。\n\n\n\n## 容器大小操作\n\nempty方法判断容器是否为空\n\nsize返回个数\n\nmax_size返回该容器所能容纳的最大元素个数\n\nforward_list不支持size方法\n\n\n\n## 容器比较大小\n\n容器要完全相同才能比较大小。\n\n比较的是容器里面的元素。\n\n具体规则如下：\n\n![image](https://s2.ax1x.com/2019/10/06/ucddPA.png)\n\n因为比较的是容器内的元素，所以要容器中的元素定义了比较，容器才可以比较。\n\n\n\n# 参考资料：\n\n1. 《Primer c++ 第五版》\n2. http://www.cplusplus.com/reference/iterator/","tags":["c++","容器","stl"],"categories":["c++"]},{"title":"tmux使用简易入门","url":"/2019/10/05/tmux使用简易入门/","content":"\n为了使得断开SSH也能继续运行命令，下次继续返回现场，可以使用tmux\n\n参考 [gist.github.com/MohamedAlaa/2961058](https://gist.github.com/MohamedAlaa/2961058)\n\n\n\n## 键入tmux即可进入tmux环境\n\n在tmux环境中 按住 control-b 然后松开 再按 ？即可查看所有快捷键\n\n\n\n## 如何查看当前tmux的窗口状态呢？\n\n键入tmux ls可以列出所有的windows\n\n输入c-b w可以看到所有的windows，可以看出一组window表示一个一个tmux环境（用于返回到某个工作环境中），里面有多个bash（一个工作环境同时有多个bash，一个bash就是一个window），而一个bash可以有多个面板panel（用于同时显示多个命令行界面，即分屏功能）\n\n\n\n## 如何退出tmux环境呢？\n\nc-b d即可退出tmux进入到正常的bash中\n\n\n\n## 如何新建tmux环境呢？\n\n退出再进入即可新建一个新的tmux环境，即一组bash\n\n\n\n## 如何在一个环境中新建bash呢？\n\nc-b c即可在当前环境中新建bash\n\n\n\n## 如何杀死一个tmux环境呢？即如何杀死一组bash\n\n再进入tmux然后查看所有windows即可发现之前的环境并没有杀死，而是还在后台继续，那么如何杀死windows呢\n\ntmux用session来标示一组windows或者bash，可以杀死一组windows来杀死它的所有bash，windows前面的数字就是他的session号\n\n命令 tmux kill-session -t 8 就可以杀死session号为8的windows组\n\n\n\n## 如何在一个tmux环境中删除某个bash呢？\n\n在某个bash的panel中键入 c-b x 即可删除掉当前panel\n\n注意删除的粒度是panel级别的，因此如果在一个bash里面有多个panel，那么只会删除掉当前的panel\n\n\n\n## 如何分屏？即如何新建panel\n\nc-b % 竖直分屏\n\nc-b “ 水平分屏\n\n\n\n## 如何在一个bash的多个panel之间切换？\n\nc-b o 即可按顺序在多个panel之间切换\n\n\n\n## 如何在多个bash之间切换\n\n1.\t可以用 c-b w 手动选择\n\n2.\t也可以直接 c-b 加上bash的数字即可","tags":["linux","tmux"],"categories":["linux"]},{"title":"建。。建站手册？🗝","url":"/2019/08/11/Hello-World/","content":"\n[TOC]\n\n# 修改历史\n\n| 时间      | 内容                       |\n| --------- | -------------------------- |\n| 2019-8-12 | 初稿                       |\n| 2019-8-29 | 完善图片显示和其他格式问题 |\n\n# 前言\n\n花了点时间捣鼓了个Hexo博客，顺便记录一下捣鼓过程，不想看过程的可以直接跳到[最后](#最后)\n\n**🕘 预计配置时间**： 3hours？Maybe fewer.\n\n**🖥 完成配之后将拥有：**\n\n1. 一个github仓库作为数据存储的静态博客\n\n2. 基本功能齐全，前端还算不错的个人博客，省得自己搭架子\n\n   ![blog](https://s2.ax1x.com/2019/08/29/mbAVyQ.png)\n\n3. 采用hexo博客框架，[Casper](https://github.com/xzhih/hexo-theme-casper)作为模板，自动渲染md，一键部署到github\n\n4. 模板自身支持发布文章，阅读文章，新建页面，分类，标签\n\n5. 自己添加了一些功能可以手动写md实现时间轴，增加了流量统计\n\n\n\n# 折腾过程实录\n\n**1. github page**\n\n​\t要部署到github的话，先搞一个github仓库，直接google一下[github page](https://www.google.com/search?q=github+page&oq=github+page&aqs=chrome..69i57j35i39j69i60l4.2108j0j4&sourceid=chrome&ie=UTF-8)咋整就行了，这一步注意仓库的名字有特殊的要求，不然后面会显示不出来东西。有手就行的东西就不展开了🙌\n\n**2. hexo**\n\n​\t同上，google一下[hexo](https://hexo.io/zh-cn/docs/)的安装过程，同有手就行🤞\n\n​\t这里可以稍微熟悉一下几个命令\n\n```shell\nhexo new post helloworld\nhexo clean  # 清空一下之前生成的文件，如果修改不生效可以试试这个命令，先清空一下\nhexo g      # generate，编译渲染\nhexo d      # deploy，自动部署\n```\n\n\n\n**3. hexo部署到github page上**\n\n​\tgoogle之[hexo整合github](https://hexo.io/zh-cn/docs/deployment)。。有手就行👀。。。\n\n​\t这里可以稍微注意一下，部署的分支和资源存储的分支是分开的，部署的分支github貌似要求是master，资源可以新建一个分支\n\n**4. pick一个主题**\n\n​\t这里我选了[Casper](https://github.com/xzhih/hexo-theme-casper)作为模板，另外有一个模板看起来也不错👉[icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/about/)。下面的内容都是根据我选择的Casper展开。\n\n​\t更换主题就是直接把Casper的github repo（具体地址在上面链接👆）clone到**themes**文件夹下。\n\n​\t稍微解释一下这些个文件夹都是干啥的，之后有用。\n\n```\n├── README.md\n├── _config.yml          # 配置文件，可以配置很多东西，之后会介绍\n├── languages            # 语言包，直接在配置文件里面设置zh-CN就是中文了\n│   ├── default.yml\n│   ├── fr.yml\n│   ├── nl.yml\n│   ├── no.yml\n│   ├── ru.yml\n│   ├── zh-CN.yml\n│   └── zh-TW.yml\n├── layout               # 布局文件，自定义一些布局基本都在这里修改\n│   ├── _layout.swig\n│   ├── _partials\n│   ├── archive.swig\n│   ├── category.swig\n│   ├── index.swig\n│   ├── page.swig\n│   ├── post.swig\n│   └── tag.swig\n├── scripts\n│   └── index.js\n└── source               # 源文件，配合布局一起修改\n    ├── css\n    ├── fonts\n    ├── img\n    └── js\n```\n\n**5. 配置主题**\n\n​\t这一步主要是修改**_config**这个文件，这里有俩config，一个是博客根目录的config，一个是**themes/hexo-casper**里的config，都可以配置，重点说一下主题里面的那个config\n\n![_config](https://s2.ax1x.com/2019/08/29/mbAtm9.png)\n\n参考我这个稍微配置一下就行了，另外[Casper](https://github.com/xzhih/hexo-theme-casper)里面写的很清楚了，照着改改就差不多了\n\n\n\n**6. 增加流量统计**\n\n​\t提了issue问怎么统计流量，回答说有个评论系统自带了流量统计功能，但是注册过程比较麻烦，就放弃了。这里采用[不蒜子](http://ibruce.info/2015/04/04/busuanzi/)，很是方便，而且速度很快，只要简单配置一下就可以了。\n\n配置之前先详细解释一下layout的结构：\n\n```shell\n├── _layout.swig            # 页面总体布局（修改基本没用到它）\n├── _partials               # 小组件，方便复用\n│   ├── about.swig            # 这个就是ABOUT界面上面的那些小东西，见下面图例\n│   ├── footer.swig           # 注脚，见下面图例\n│   ├── head.swig\n│   ├── header.swig\n│   ├── index.swig\n│   ├── javascript.swig\n│   ├── page.swig\n│   ├── post.swig\n│   ├── public\n│   │   ├── fload-header.swig\n│   │   ├── icons\n│   │   ├── json-ld.swig\n│   │   ├── nav.swig\n│   │   ├── social.swig\n│   │   └── toc.swig\n│   ├── search.swig\n│   ├── widget                # 这三个就是分类、tag和recent\n│   │   ├── category.swig\n│   │   ├── recent_posts.swig\n│   │   └── tagcloud.swig\n│   └── widget.swig\n├── archive.swig              # archive页面的布局\n├── category.swig\n├── index.swig\n├── page.swig\n├── post.swig\n└── tag.swig\n```\n\n_partials/about.swig:\n\n![about](https://s2.ax1x.com/2019/08/29/mbAUT1.png)\n\n_partials/foot.swig:\n\n![foot](https://s2.ax1x.com/2019/08/29/mbAdFx.png)\n\n**7. 将分类写到导航栏上面**\n\n```\nhexo new page xxx\n```\n\n这个命令可以新建一个导航页面，但是只是单独的一页文章。如果要把categories的每个分类放到导航栏上面，可以稍作修改。\n\n方法一：\n\n在**config**里面修改：\n\n```\nmenu:\n  ABOUT: /about\n  ARCHIVES: /archives\n  TEST: /categories/test/\n```\n\n这样手动可以把某个分类添加到导航栏上面。\n\n方法二：\n\n观察**layout/_partails/widget/categories**中的写法，发现只要添加一行代码就可以添加link到指定分类的链接。故只要在**layout/_partails/public/nav.swig**中修改如下：（绿色的注释）\n\n![nav](https://s2.ax1x.com/2019/08/29/mbVkrQ.png)\n\n**8. 给页面加上阴影**\n\n因为项目中将css全部整合到**allinonecss.min.css**中，因此要直接修改这个css文件，修改其他的css文件不生效！！！\n\n全局搜索\n\n```\n.post-full-content\n```\n\n添加css\n\n```\nbox-shadow:0px 16px 16px #E0E0E0;\nborder-radius: 8px;\n```\n\n即可添加shadow和圆角\n\n**8. 添加时间线**\n\n这个可以通过手写markdown来手动实现时间线\n\n首先在**scripts/index.js**最后添加如下代码：（来自<http://channingsun.bid/2016/05/10/20160510_%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Timeline/>）\n\n```js\n//timeline\nhexo.extend.tag.register('timeline', function(args, content){\n\tdate = args[0]\n\ttime = args[1]\n\tlogo = args[2]\n\tvar result = '';\n\tresult += '<blockquote>';\n\tlogo = '<span class=\"fa-stack fa-lg\"><i class=\"fa ' + logo + ' fa-stack-1x\"></i></span>';\n\tresult += hexo.render.renderSync({text: logo + content, engine: 'markdown'});\n\tfooter = '<span>' + date + ' ' + time + '</span>'\n\tresult += '<footer>' + footer + '</footer>';\n\tresult += '</blockquote>';\n\treturn result;\n}, {ends: true});\n```\n\n然后只要写\n\n```\n{% timeline 2015-01-23 18:38:26 fa-lg %} 第一篇博客 {% post_link hello-world hello-world %} {% endtimeline %}\n```\n\n即可跳转到对应的博客\n\n也可以适当调整一下js里面的内容，比如表情和time可以删掉\n\n# 最后\n\n最后就配置好了，嗯。想看配置过程的可以看[折腾过程实录](#%E6%8A%98%E8%85%BE%E8%BF%87%E7%A8%8B%E5%AE%9E%E5%BD%95)\n\n\n\n\n\n\n\n","tags":["Hello World"]}]