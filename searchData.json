[{"title":"最长有效括号","url":"/2019/10/06/最长有效括号/","content":"\n# 题目\n\n给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n\n示例 1:\n\n输入: \"(()\"\n输出: 2\n解释: 最长有效括号子串为 \"()\"\n示例 2:\n\n输入: \")()())\"\n输出: 4\n解释: 最长有效括号子串为 \"()()\"\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-valid-parentheses\n\n\n\n# 思路\n\n最开始想到用栈模拟。\n\n题解里面用的是动态规划感觉还是比较容易些。\n\n\n\n# 题解\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/\n来源：力扣（LeetCode）\n\n\n\n定义一个dp数组。第i个位置为以i结尾的最长括号的长度。\n\n那么可以得到递推关系：\n\n![image](https://s2.ax1x.com/2019/10/12/uXqRC8.png)\n\n```java\npublic class Solution {\n    public int longestValidParentheses(String s) {\n        int maxans = 0;\n        int dp[] = new int[s.length()];\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) == ')') {\n                if (s.charAt(i - 1) == '(') {\n                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {\n                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                }\n                maxans = Math.max(maxans, dp[i]);\n            }\n        }\n        return maxans;\n    }\n}\n```\n\n\n\n用栈模拟\n\n注意一下整个栈清空时候能正确计算。即()()可以算出4。\n\n这样就要保留一下前一个位置的信息，且用下标直接减，不要用pop出来的数字+1。\n\n![image](https://s2.ax1x.com/2019/10/12/uXL8xg.png)\n\n```java\npublic class Solution {\n    public int longestValidParentheses(String s) {\n        int maxans = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();  // 直接舍弃\n                if (stack.empty()) {\n                    stack.push(i);  // 处理的就是)()()这种情况\n                } else {  // 计算舍弃之后的前一位到目前的距离\n                    maxans = Math.max(maxans, i - stack.peek());\n                }\n            }\n        }\n        return maxans;\n    }\n}\n\n```\n\n","tags":["动态规划","刷题","栈"],"categories":["算法"]},{"title":"不同路径","url":"/2019/10/06/不同路径/","content":"\n# 题目\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/unique-paths\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n\n# 思路\n\n一开始想用DFS，写起来容易，就是超时了。\n\nDFS重复计算了很多，即经过一个格子的时候其实早就经过了，当然可以用记忆化搜索来优化，用一个二维数组来存储一下即可。\n\n考虑用动态规划，用一个二维数组来表示某位置到终点的情况数，(x,y)位置的次数等于(x+1,y) + (x, y+1)，这样就有递推关系了，然后原始条件就是右下角的那几个。\n\n其实二维数组套两层循环，一次也只是用到了一维数组，因此可以稍微优化一下。这里稍微画一个图看着写就行了。\n\n\n\n# 题解\n\n优化前：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Solution {\nprivate:\n    int ans;\n    int m;\n    int n;\npublic:\n    int uniquePaths(int m, int n) {\n        int dp[m+1][n+1];\n        for(int i=1;i<=n;i++) dp[m][i] = 1;\n        for(int j=1;j<=m;j++) dp[j][n] = 1;\n        for(int i=m-1;i>=1;i--){\n            for(int j=n-1;j>=1;j--){\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\n            }\n        }\n        return dp[1][1];\n    }\n}\n```\n\n\n\n优化后：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Solution {\nprivate:\n    int ans;\n    int m;\n    int n;\npublic:\n    int uniquePaths(int m, int n) {\n        int dp[m+1];\n        for(int j=1;j<=m;j++) dp[j] = 1;\n        for(int i=n-1;i>=1;i--){\n            for(int j=m-1;j>=1;j--){\n                dp[j] = dp[j] + dp[j+1];\n            }\n        }\n        return dp[1];\n    }\n}   \n```\n\n","tags":["动态规划","刷题","暴搜"],"categories":["算法"]},{"title":"括号生成","url":"/2019/10/06/括号生成/","content":"\n# 题目\n\n给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\n\n例如，给出 n = 3，生成结果为：\n\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/generate-parentheses\n\n\n\n# 思路\n\nDFS，每次考虑一个位置放左括号还是右括号。为了防止垃圾情况过多，预先剪枝，即只有合理的时候才会继续，那么只要是能到最后（所有括号都被用完），就可以得到一个解。\n\n\n\n具体来说就是：\n\n用一个栈（一个整数就够了）来维护当前栈中的左括号数量，来实时判断是否可以放右括号；还需要左右括号的数量；还需要当前的字符串\n\n\n\n对于每一个位置，左括号可以随便放，右括号要考虑一下，如果栈中有左括号，那么可以放，否则不行。这样预先剪枝，到最后如果左右括号都用完，自然就形成一个解，而不用最后判断。\n\n\n\n# 题解\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<string> ans;    \npublic:\n    vector<string> generateParenthesis(int n) {\n      int left = n, right = n;\n      int stack = 0;\n      string s = \"\";\n      DFS(stack, left, right, s);\n      return ans;\n    }\n\n    /*\n    stack表示栈中左括号的数量\n    left表示剩余的左括号数量\n    right表示剩余的右括号数量\n    s表示当前的字符串情况\n     */    \n    void DFS(int stack, int left, int right, string s){\n      if(left == right && left == 0){  // 括号全都用上了表示得到一个结果\n        ans.push_back(s);\n        return;\n      }\n      if(left != 0){  // 左括号随便放\n        DFS(stack+1, left-1, right, s+\"(\");\n      }\n      if(stack != 0 && right != 0){  // 右括号有条件地放\n        DFS(stack-1, left, right-1, s+\")\");\n      }\n      return ;\n    }\n};\n```\n\n","tags":["刷题","暴搜"],"categories":["算法"]},{"title":"全排列","url":"/2019/10/06/全排列/","content":"\n# 题目\n\n给定一个没有重复数字的序列，返回其所有可能的全排列。\n\n示例:\n\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/permutations\n\n\n\n# 思路\n\n回溯即可。\n\n注意一下vector的引用问题。\n\n\n\n# 题解\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<vector<int>> ans;\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<int> left(nums.size(), 0);  // 初始化为全0\n        vector<int> now;\n        DFS(nums, now, left);\n        return ans;\n    }\n\n    /*\n    now表示现在加到结果中的vector\n    left表示还可以加入的位置。1表示已经加入，0表示还可以加入\n    */\n    void DFS(vector<int>& nums, vector<int> now, vector<int> left){  // 这里的now不能是引用\n        int full = true;\n        for(int i=0; i<left.size(); i++){  // 遍历left，如果还有0，那么表示还可以加入\n            if(left[i] != 1){\n                full = false;\n                now.push_back(nums[i]);  // 加入\n                left[i] = 1;\n                DFS(nums, now, left);  // 回溯\n                now.erase(now.end()-1);\n                left[i] = 0;\n            }\n        }\n        if(full){  // 不可以再加入，就加入答案集合中\n            ans.push_back(now);\n        }\n        return ;\n    }\n};\n```\n\n\n\n","tags":["刷题，暴搜"],"categories":["算法"]},{"title":"c++容器库（一）","url":"/2019/10/06/c-容器库（一）/","content":"\n# 容器库操作层次\n\n- 所有容器类型都提供的\n- 仅针对三大容器类型中的一种：顺序容器、关联容器、无需容器\n- 仅适用于一小部分容器\n\n\n\n# 所有容器类型通用操作\n\n## 头文件\n\n容器一般在和容器同名的头文件中声明。\n\n\n\n## 类型\n\n所有的容器类型都是模版类，因此可以限定类型\n\n\n\n## 通用操作\n\n![image](https://s2.ax1x.com/2019/10/06/u62jyj.png)\n\n\n\n## 迭代器\n\n### 迭代器的范围\n\n[begin, end)\n\n\n\n### 迭代器大小\n\n只有能够随机访问的容器的迭代器才可以比较大小，例如vector；list因为不是随机的，因此只能比较是否相等：\n\nhttp://www.cplusplus.com/reference/iterator/\n\n![image](https://s2.ax1x.com/2019/10/06/u6RMtK.png)\n\n即这个写法是错的：\n\n![image](https://s2.ax1x.com/2019/10/06/u6RLAx.png)\n\n\n\n### 正向反向迭代器\n\niterator和reverse_iterator。\n\n反向迭代器的所有操作都会相反。\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n    vector<int> v;\n    v.push_back(1);\n    v.push_back(2);\n    vector<int>::reverse_iterator rit;\n    for(auto rit = v.rbegin(); rit != v.rend(); rit++) {  // rbegin和reverse_iterator是配套的\n        cout << *rit << endl;  // 注意这里要解引用\n    }\n\n    return 0;\n}\n```\n\n\n\n### const迭代器\n\n当使用begin的时候，会根据容器的内容来决定是否是一个const_iterator。\n\n![image](https://s2.ax1x.com/2019/10/06/u6fXlD.png)\n\n如果使用begin而且是一个const_iterator，那么就会报错：（报错）\n\n```c++\nconst vector<int> cv;\nvector<int>::iterator cvi = cv.begin();\n```\n\n\n\n## 其他容器类型\n\n容器定义了很多类型，这些类型和具体的容器类型以及他的模版类型都有关系，例如迭代器类型和size_type。\n\n元素类型：value_type\n\n元素类型的一个引用：reference或const_reference\n\n迭代器距离：difference_type\n\n\n\n## 容器初始化\n\n![image](https://s2.ax1x.com/2019/10/06/u64oPx.png)\n\narray并不适用于 C c(b,e) 这种初始化，这一点和数组比较像。\n\n如果提供的值小于容量，那么其余的都是0，例如：\n\n```c++\narray<int, 10> a = {42};  // 第一个元素为42，其余为0\n```\n\n不提供值，那么里面的值是不确定的。\n\n注意：\n\n```c++\narray<int, 10> a{};\n```\n\n这样会初始化为全0。\n\n\n\n### PS：数组初始化\n\n数组中如果：\n\n```c++\nint a[100] = {0};\n```\n\n是全0，如果改成非0的数就只有第一个数赋值了，剩余的都是0\n\n如果:\n\n```c++\nint a[100];\n```\n\n那么如果是全局或者静态变量，是0，否则是随机值。\n\n注意：\n\n```c++\nint a[100]{};\n```\n\n也会初始化为全0\n\n\n\n\n\n注意虽然array没有迭代器，但是仍然可以用指针来初始化，例如：\n\n```c++\nint arr[3];\narr[0] = 1;\narr[1] = 2;\narr[2] = 3;\nvector<int> v(arr, arr+3);\n```\n\n\n\n### 初始化和拷贝\n\n创建一个容器为另一个容器拷贝时，类型必须严格匹配；\n\n用迭代器参数来指定拷贝范围时，不需要严格匹配。\n\n例如：\n\n![image](https://s2.ax1x.com/2019/10/06/u65zm4.png)\n\n注：容器的拷贝不管是容器本身还是里面的元素，都是深度拷贝，不会影响原来的值。\n\n\n\n### array的初始化\n\narray不是数组，但是很像数组。也有固定大小，初始化必须指定array大小。\n\n数组可以直接赋值给array。\n\n\n\n## 交换和赋值\n\n![image](https://s2.ax1x.com/2019/10/06/uc3or9.png)\n\nassign的两种形式：\n\n```c++\nnames.assign(oldstyle.cbegin(), oldstyle.cend())\n```\n\n```c++\nslist1.assign(10, \"Hiya!\");\n```\n\n注意assign的参数类型不必严格匹配，但是用=赋值必须保证参数类型严格匹配。\n\nassign之后指向原来容器的所有指针都会失效，例如迭代器等。\n\n\n\nswap可以高效交换两个相同类型的容器，除了array外，只是交换和数据结构，而不是真实的内存，所有指针不会失效，但是仍然指向原来的元素。\n\narray特殊，真正交换了元素，交换时间与个数成正比，而且指针指向的内容也发生了变化。\n\n\n\n## 容器大小操作\n\nempty方法判断容器是否为空\n\nsize返回个数\n\nmax_size返回该容器所能容纳的最大元素个数\n\nforward_list不支持size方法\n\n\n\n## 容器比较大小\n\n容器要完全相同才能比较大小。\n\n比较的是容器里面的元素。\n\n具体规则如下：\n\n![image](https://s2.ax1x.com/2019/10/06/ucddPA.png)\n\n因为比较的是容器内的元素，所以要容器中的元素定义了比较，容器才可以比较。\n\n\n\n# 参考资料：\n\n1. 《Primer c++ 第五版》\n2. http://www.cplusplus.com/reference/iterator/","tags":["c++","容器","stl"],"categories":["c++"]},{"title":"按递增顺序显示卡牌","url":"/2019/10/05/按递增顺序显示卡牌/","content":"\n# 题目\n\n牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。\n\n最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。\n\n现在，重复执行以下步骤，直到显示所有卡牌为止：\n\n从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。\n如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。\n如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。\n返回能以递增顺序显示卡牌的牌组顺序。\n\n答案中的第一张牌被认为处于牌堆顶部。\n\n \n\n示例：\n\n输入：[17,13,11,2,3,5,7]\n输出：[2,13,3,11,5,17,7]\n解释：\n我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。\n重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。\n我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。\n我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。\n我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。\n我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。\n我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。\n我们展示 13，然后将 17 移到底部。牌组现在是 [17]。\n我们显示 17。\n由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/reveal-cards-in-increasing-order\n\n\n\n# 思路\n\n直接模拟即可\n\n先对于数组排序，得到排序好的，然后按照位置安插进去即可\n\n重要的是得到位置和次序的对应关系。可以用一个队列来模拟这个过程，自然就可以得到关系\n\n\n\n## 题解\n\n```c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> deckRevealedIncreasing(vector<int>& deck) {\n        int len = deck.size();\n        int order[1001];\n        queue<int> q;\n        for(int i=0;i<len;i++){\n            q.push(i);\n        }\n        int now = 0;\n        while(!q.empty()){\n            int front = q.front();\n            q.pop();\n            order[now] = front;\n            if(!q.empty()){\n                front = q.front();\n                q.pop();\n                q.push(front);\n            }\n            now++;\n        }\n        sort(deck.begin(), deck.end());\n        int ans[1001];\n        for(int i=0;i<len;i++){\n            ans[order[i]] = deck[i];\n        }\n        vector<int> ret(ans, ans+len);\n        return ret;\n    }\n};\n\n```\n\n","tags":["刷题","队列"],"categories":["算法"]},{"title":"tmux使用简易入门","url":"/2019/10/05/tmux使用简易入门/","content":"\n为了使得断开SSH也能继续运行命令，下次继续返回现场，可以使用tmux\n\n参考 [gist.github.com/MohamedAlaa/2961058](https://gist.github.com/MohamedAlaa/2961058)\n\n\n\n## 键入tmux即可进入tmux环境\n\n在tmux环境中 按住 control-b 然后松开 再按 ？即可查看所有快捷键\n\n\n\n## 如何查看当前tmux的窗口状态呢？\n\n键入tmux ls可以列出所有的windows\n\n输入c-b w可以看到所有的windows，可以看出一组window表示一个一个tmux环境（用于返回到某个工作环境中），里面有多个bash（一个工作环境同时有多个bash，一个bash就是一个window），而一个bash可以有多个面板panel（用于同时显示多个命令行界面，即分屏功能）\n\n\n\n## 如何退出tmux环境呢？\n\nc-b d即可退出tmux进入到正常的bash中\n\n\n\n## 如何新建tmux环境呢？\n\n退出再进入即可新建一个新的tmux环境，即一组bash\n\n\n\n## 如何在一个环境中新建bash呢？\n\nc-b c即可在当前环境中新建bash\n\n\n\n## 如何杀死一个tmux环境呢？即如何杀死一组bash\n\n再进入tmux然后查看所有windows即可发现之前的环境并没有杀死，而是还在后台继续，那么如何杀死windows呢\n\ntmux用session来标示一组windows或者bash，可以杀死一组windows来杀死它的所有bash，windows前面的数字就是他的session号\n\n命令 tmux kill-session -t 8 就可以杀死session号为8的windows组\n\n\n\n## 如何在一个tmux环境中删除某个bash呢？\n\n在某个bash的panel中键入 c-b x 即可删除掉当前panel\n\n注意删除的粒度是panel级别的，因此如果在一个bash里面有多个panel，那么只会删除掉当前的panel\n\n\n\n## 如何分屏？即如何新建panel\n\nc-b % 竖直分屏\n\nc-b “ 水平分屏\n\n\n\n## 如何在一个bash的多个panel之间切换？\n\nc-b o 即可按顺序在多个panel之间切换\n\n\n\n## 如何在多个bash之间切换\n\n1.\t可以用 c-b w 手动选择\n\n2.\t也可以直接 c-b 加上bash的数字即可","tags":["linux","tmux"],"categories":["linux"]},{"title":"二叉搜索树的迭代器","url":"/2019/10/05/二叉搜索树的迭代器/","content":"\n# 题目\n\n实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。\n\n调用 next() 将返回二叉搜索树中的下一个最小的数。\n\n \n\n示例：\n\n\n\nBSTIterator iterator = new BSTIterator(root);\niterator.next();    // 返回 3\niterator.next();    // 返回 7\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 9\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 15\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 20\niterator.hasNext(); // 返回 false\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/binary-search-tree-iterator\n\n\n\n# 思路\n\n初始化的时候中序遍历一次，然后每次取下一个即可\n\n\n\n# 题解\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n };\n\nclass BSTIterator {\nprivate:\n    vector<int> v;\n    int index;\npublic:\n    BSTIterator(TreeNode* root) {\n        inOrder(root);\n        index = 0;\n    }\n\n    void inOrder(TreeNode* root){\n        if(root == NULL) return;\n        preOrder(root -> left);\n        v.push_back(root -> val);\n        preOrder(root -> right);\n        return;\n    }\n    \n    /** @return the next smallest number */\n    int next() {\n        int ans = v[index];\n        index += 1;\n        return ans;\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return index!=v.size();\n    }\n};\n```\n\n\n\n题解中还有一种比较巧妙，用了栈来做中序遍历，可以容易控制进度。\n\n每一次先找到最小值，寻找路上经过的节点依次压栈，栈顶保留当前最小值。然后每次取出最小值的时候，弹栈，并且压入下一个最小值。如何找最小值？如果当前节点的右子节点为空，那么最小值已经在栈中；如果不为空，那么压入右子节点，并且一路在它的左子树寻找下去。\n\n作者：offercomeon-2\n链接：https://leetcode-cn.com/problems/binary-search-tree-iterator/solution/zhong-xu-bian-li-de-die-dai-fen-jie-jie-ti-by-offe/\n\n```c++\nclass BSTIterator {\n    stack<TreeNode*> tree_stack;\npublic:\n    BSTIterator(TreeNode* root) {\n        while(root){\n            tree_stack.push(root);\n            root = root->left;\n        }\n    }\n    \n    /** @return the next smallest number */\n    int next() {\n        TreeNode* cur = tree_stack.top();\n        tree_stack.pop();\n        int res = cur->val;\n        cur = cur->right;\n        while(cur){\n            tree_stack.push(cur);\n            cur = cur->left;\n        }\n        return res;\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return !tree_stack.empty();\n    }\n};\n```\n\n\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"N叉树的前序遍历","url":"/2019/10/05/N叉树的前序遍历/","content":"\n# 题目\n\n给定一个 N 叉树，返回其节点值的前序遍历。\n\n例如，给定一个 3叉树 :\n\n![image](https://s2.ax1x.com/2019/10/05/us9c4S.png)\n\n返回其前序遍历: [1,3,5,6,2,4]。\n\n \n\n说明: 递归法很简单，你可以使用迭代法完成此题吗?\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal\n\n\n\n# 思路\n\n1. 递归\n2. 迭代\n\n\n\n递归因为只需要处理一下当前节点即可，所以返回void即可；不需要全局数据，只要传入一个引用参数，修改引用参数即可。\n\n迭代要用栈，注意压栈顺序是从右往左。\n\n\n\n# 题解\n\n```c++\n#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> preorder(Node* root) {\n        vector<int> ans;\n        if(root == NULL) return ans;\n        stack<Node*> n;\n        n.push(root);\n        while(!n.empty()){\n            root = n.top();\n            n.pop();\n            ans.push_back(root -> val);\n            vector<Node*> c = root -> children;\n            for(int i=c.size()-1;i>=0;i--)\n                n.push(c[i]);\n        }\n        return ans;\n    }\n};\n```\n\n\n\n```c++\n#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> preorder(Node* root) {\n        vector<int> ans;\n        DFS(ans, root);\n        return ans;\n    }\n\n    void DFS(vector<int>& ans, Node* node){\n         if(node == NULL) return;\n         ans.push_back(node -> val);\n         for(auto n: node -> children){\n             DFS(ans, n);\n         }\n    }\n};\n```\n\n\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"二叉树的最大深度","url":"/2019/10/05/二叉树的最大深度/","content":"\n# 题目\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n   3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回它的最大深度 3 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree\n\n\n\n# 思路\n\n必然是DFS。\n\n如果将深度放在参数列表里面，统计的是总的深度，而不是最深。\n\n放在返回值里面，即每层递归返回自身深度，等于下一层深度+1，下一层深度有两个，取大的那个。\n\n\n\n# 题解\n\n```c++\n#include <vector>\nusing namespace std;\n\nstruct TreeNode { \n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        return 1 + max(maxDepth(root -> left), maxDepth(root -> right));\n    }\n};\n```\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"二叉树剪枝","url":"/2019/10/05/二叉树剪枝/","content":"\n# 题目\n\n给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。\n\n返回移除了所有不包含 1 的子树的原二叉树。\n\n( 节点 X 的子树为 X 本身，以及所有 X 的后代。)\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/binary-tree-pruning\n\n\n\n# 思路\n\nDFS即可。\n\n不修改放在参数列表中的参数，而是直接返回节点，然后在DFS中组装一下左右子树\n\n这一题仔细分类讨论一下即可\n\n\n\n# 题解\n\n```c++\n#include <vector>\nusing namespace std;\n\nstruct TreeNode { \n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        if(root == NULL) return NULL;\n        if(root -> val == 0 && root -> left == NULL && root -> right == NULL) return NULL;\n        TreeNode* leftChild = pruneTree(root -> left);\n        TreeNode* rightChild = pruneTree(root -> right);\n        if(root -> val == 0 && leftChild == NULL && rightChild == NULL) return NULL;\n        root -> left = leftChild;\n        root -> right = rightChild;\n        return root;\n    }\n};\n```\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"先序遍历构造二叉树","url":"/2019/10/04/先序遍历构造二叉树/","content":"\n# 题目\n\n返回与给定先序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。\n\n(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 < node.val，而 node.right 的任何后代，值总 > node.val。此外，先序遍历首先显示节点的值，然后遍历 node.left，接着遍历 node.right。）\n\n \n\n示例：\n\n输入：[8,5,1,7,10,12]\n输出：[8,5,10,1,7,null,12]\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal\n\n\n\n# 思路\n\n因为是先序遍历，且是二叉搜索树\n\n所以第一个节点必然是根节点，然后找到第一个大于根节点的树，划分左右子树，递归建树\n\n\n\n# 题解\n\n```c++\n#include <vector>\nusing namespace std;\n\nstruct TreeNode { \n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\n        return buildTree(preorder, 0, preorder.size()-1);\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, int left, int right){\n        if(left > right) return NULL;\n        if(left == right) return new TreeNode(preorder[left]);\n        TreeNode* root = new TreeNode(preorder[left]);\n        int border = findBorder(preorder, left, right);\n        TreeNode* leftChild = buildTree(preorder, left+1, border-1);\n        TreeNode* rightChild = buildTree(preorder, border, right);\n        root -> left = leftChild;\n        root -> right = rightChild;\n        return root;\n    }\n\n    int findBorder(vector<int>& preorder, int left, int right){\n        int num = preorder[left];\n        for(int i=left+1; i<=right; i++){\n            if(preorder[i] > num) return i;\n        }\n        return right+1;\n    }\n};\n```\n\n特别注意一下findBorder方法里面，如果没有找到大于根节点的数，那么返回right+1，递归到下一层会自动返回一个NULL节点","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"翻转二叉树","url":"/2019/10/04/翻转二叉树/","content":"\n# 题目\n\n翻转一棵二叉树。\n\n示例：\n\n输入：\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n输出：\n\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/invert-binary-tree\n\n# 思路\n\nDFS递归处理即可\n\n\n\n# 题解\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n };\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root == NULL) return NULL;\n        TreeNode* temp = root -> left;\n        root -> left = root -> right;\n        root -> right = temp;\n        invertTree(root -> left);\n        invertTree(root -> right);\n        return root;\n    }\n};\n```\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"二叉搜索树的范围和","url":"/2019/10/04/二叉搜索树的范围和/","content":"\n# 题目\n\n给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。\n\n二叉搜索树保证具有唯一的值。\n\n \n\n示例 1：\n\n输入：root = [10,5,15,3,7,null,18], L = 7, R = 15\n输出：32\n示例 2：\n\n输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10\n输出：23\n\n\n提示：\n\n树中的结点数量最多为 10000 个。\n最终的答案保证小于 2^31。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/range-sum-of-bst\n\n# 思路\n\n分三种情况DFS\n\n当前节点比最小值还小，那么只考虑右子树\n\n当前节点比最大值还大，那么只考虑左子树\n\n介于两者之间，那么加上当前节点，且考虑左右子树\n\n\n\n# 题解\n\n```c++\n#include <vector>\nusing namespace std;\n\nstruct TreeNode { \n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int L, int R) {\n        int sum = 0;\n        DFS(sum, root, L, R);\n        return sum;\n    }\n\n    void DFS(int &sum, TreeNode* node, int L, int R){\n        if(node == NULL) return;\n        if(node -> val<L) DFS(sum, node->right, L, R);\n        else if(node -> val>R) DFS(sum, node->left, L, R);\n        else {\n            sum += (node -> val);\n            DFS(sum, node->right, L, R);\n            DFS(sum, node->left, L, R);\n        }\n    }\n};\n```\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"最大二叉树","url":"/2019/10/04/最大二叉树/","content":"\n# 题目\n\n给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：\n\n二叉树的根是数组中的最大元素。\n左子树是通过数组中最大值左边部分构造出的最大二叉树。\n右子树是通过数组中最大值右边部分构造出的最大二叉树。\n通过给定的数组构建最大二叉树，并且输出这个树的根节点。\n\n \n\n示例 ：\n\n输入：[3,2,1,6,0,5]\n输出：返回下面这棵树的根节点：\n\n      6\n    /   \\\n   3     5\n    \\    / \n     2  0   \n       \\\n        1\n\n\n提示：\n\n给定的数组的大小在 [1, 1000] 之间。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximum-binary-tree\n\n# 思路\n\n直接暴力搜索即可\n\n找出最大节点，DFS左右递归建树，然后拼起来，返回即可\n\n\n\n# 题解\n\nc++如下\n\n```c++\n#include <vector>\nusing namespace std;\n\nstruct TreeNode { \n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        return DFS(nums, 0, nums.size()-1);\n    }\n\n    TreeNode* DFS(vector<int>& nums, int left, int right){\n        if(left>right) return NULL;\n        if(left == right) return new TreeNode(nums[left]);\n        int maxIndex = findMaxPosition(nums, left, right);\n        TreeNode* leftChild = DFS(nums, left, maxIndex-1);\n        TreeNode* rightChild = DFS(nums, maxIndex+1, right);\n        TreeNode* root = new TreeNode(nums[maxIndex]);\n        root -> left = leftChild;\n        root -> right = rightChild;\n        return root;\n    }\n\n    int findMaxPosition(vector<int>& nums, int left, int right){\n        int max = nums[left];\n        int index = left;\n        for(int i=left+1; i<=right; i++){\n            if(nums[i]>max){\n                max = nums[i];\n                index = i;\n            }\n        }\n        return index;\n    }\n};\n```\n\n\n\n题解中有一个正向遍历一次的方法思路蛮巧妙的：\n\n遍历一次数组并随时将新的节点插入树的相应位置，如果当前遍历的值大于树的根节点，则将当前节点作为新的根节点，将原来的树当作新根节点的左子树，否则的话，将其递归的交给根节点的右子树处理（因为从左向右遍历，新的节点一定在右边）。\n\n作者：ruo-shui-qing-ying\n链接：https://leetcode-cn.com/problems/maximum-binary-tree/solution/czi-xia-er-shang-by-ruo-shui-qing-ying/\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"买卖股票的最佳时机含手续费","url":"/2019/10/04/买卖股票的最佳时机含手续费/","content":"\n# 题目\n\n给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。\n\n你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n\n返回获得利润的最大值。\n\n示例 1:\n\n输入: prices = [1, 3, 2, 8, 4, 9], fee = 2\n输出: 8\n解释: 能够达到的最大利润:  \n在此处买入 prices[0] = 1\n在此处卖出 prices[3] = 8\n在此处买入 prices[4] = 4\n在此处卖出 prices[5] = 9\n总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n注意:\n\n0 < prices.length <= 50000.\n0 < prices[i] < 50000.\n0 <= fee < 50000.\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee\n\n\n\n# 思路\n\n回想一下没有手续费的情况。只要每次比上次多，就可以卖出，比上次少，就忽略。其实隐含着比上次少，更新最小值，比上次多，那么加上股票价格，并且更新最小值为当前值。\n\n因此有手续费的情况下，维护一个最小值，当有值比最小值小，更新最小值；若大，差值超过手续费，则加上，并且更新当前最小值为当前值减去手续费，否则不做任何处理。更新当前最小值为当前值减去手续费可以保证连续递增的情况下正确计算，且当作最小值也是正确的，因为如果值比这个最小值大且没有大得超过手续费，那么说明不值得更新。\n\n\n\n# 题解\n\n参考：\n\n作者：rancho628\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/ti-hao-122mei-you-shou-xu-fei-jia-yi-dian-dong-xi-/\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int profit = 0;\n        int inhand = prices[0];\n        for(int i=1;i<prices.size();i++){\n            if(prices[i]-inhand>fee) {\n                profit += (prices[i]-inhand-fee);\n                inhand = prices[i]-fee;\n            }\n            else if(prices[i]<inhand){\n                inhand = prices[i];\n            }\n        }\n        return profit;\n    }\n};\n```\n\n另外评论区有其他解法也值得参考：\n\n\n作者：labuladong\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-2/\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"回文子串","url":"/2019/10/04/回文子串/","content":"\n# 题目\n\n给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。\n\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。\n\n示例 1:\n\n输入: \"abc\"\n输出: 3\n解释: 三个回文子串: \"a\", \"b\", \"c\".\n示例 2:\n\n输入: \"aaa\"\n输出: 6\n说明: 6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/palindromic-substrings\n\n# 思路\n\n动态规划好像有点难想，就放弃了\n\n朴素的想法是用中心扩展来判断是否是回文串，在中心扩展时顺便可以计算出所有回文串的数量，因此复杂度可以低一点（边判断边累加求和）\n\n遍历每个字符，作为中心点中心扩展，省去了确定范围的麻烦，以及在判断的时候就可以顺便求和\n\n\n\n# 题解\n\n```c++\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        int num=0;\n        for(int i=0;i<s.size();i++){\n            num += count(s, i, i);\n            num += count(s, i, i+1);\n        }\n        return num;\n    }\n\n    int count(string s, int left, int right){\n        int num = 0;\n        while(left>=0 && right<s.size() && s[left]==s[right]){\n            num++;\n            left--;\n            right++;\n        }\n        return num;\n    }\n};\n```\n\n","tags":["刷题","字符串"],"categories":["算法"]},{"title":"两个字符串的最小ASCII删除和","url":"/2019/10/04/两个字符串的最小ASCII删除和/","content":"\n# 题目\n\n给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。\n\n示例 1:\n\n输入: s1 = \"sea\", s2 = \"eat\"\n输出: 231\n解释: 在 \"sea\" 中删除 \"s\" 并将 \"s\" 的值(115)加入总和。\n在 \"eat\" 中删除 \"t\" 并将 116 加入总和。\n结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。\n示例 2:\n\n输入: s1 = \"delete\", s2 = \"leet\"\n输出: 403\n解释: 在 \"delete\" 中删除 \"dee\" 字符串变成 \"let\"，\n将 100[d]+101[e]+101[e] 加入总和。在 \"leet\" 中删除 \"e\" 将 101[e] 加入总和。\n结束时，两个字符串都等于 \"let\"，结果即为 100+101+101+101 = 403 。\n如果改为将两个字符串转换为 \"lee\" 或 \"eet\"，我们会得到 433 或 417 的结果，比答案更大。\n注意:\n\n0 < s1.length, s2.length <= 1000。\n所有字符串中的字符ASCII值在[97, 122]之间。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings\n\n# 思路\n\n1. 思路的转化\n\n2. dp数组含义的确定\n\n\n\n将减法转为加法：因为两个字符串是固定的，因此其实求的是最大的公共子串。\n\ndp数组是一个二维数组，dp\\[i][j]表示s1[0…i]和s2[0…j]的最大公共子串的ASCII和\n\n因此递推关系如下\n\n如果s1[i] == s2[j]，那么dp\\[i][j] = dp\\[i-1][j-1] + ASCII(s1[i])\n\n否则，因为最后两个字符不相等，可以随意去掉一个（同时出现并不会影响到最大子串）即 dp\\[i][j] = max(dp\\[i-1][j], dp\\[i][j-1])\n\n初始条件：可以容易看出初始条件为dp\\[0][0…s2.length()]和dp\\[0…s1.length()][0]\n\n\n\n# 题解\n\n```c++\nclass Solution {\npublic:\n    int minimumDeleteSum(string s1, string s2) {\n        int dp[1001][1001];\n        int N1 = s1.size(), N2 = s2.size();\n        int totalSum = 0;\n        for(int i=0;i<N1;i++) totalSum += s1[i];\n        for(int j=0;j<N2;j++) totalSum += s2[j];\n        for(int i=0;i<N1;i++) for(int j=0;j<N2;j++) dp[i][j]=0;\n        for(int j=0;j<N2;j++){\n            if(s1[0]==s2[j]){\n                while(j<N2){\n                    dp[0][j] = s1[0];\n                    j++;\n                }\n                break;\n            }\n        }\n        for(int i=0;i<N1;i++){\n            if(s1[i]==s2[0]){\n                while(i<N1){\n                    dp[i][0] = s2[0];\n                    i++;\n                }\n                break;\n            }\n        }\n        for(int i=1;i<N1;i++) \n            for(int j=1;j<N2;j++) {\n                if(s1[i]==s2[j]) dp[i][j] = dp[i-1][j-1] + s1[i];\n                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n\n        return totalSum - dp[N1-1][N2-1]*2;    \n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"不同的二叉搜索树II","url":"/2019/10/04/不同的二叉搜索树II/","content":"\n# 题目\n\n给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。\n\n示例:\n\n输入: 3\n输出:\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n解释:\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii\n\n# 思路\n\n这一题和 不同的二叉搜索树 第一题不同，要求全部列出来，用DFS比较简单。\n\n因为是二叉搜索树，所以在start到end范围内，选择每一个点作为root，然后分别构造左右子树的所有情况的vector，然后再遍历组合，返回即可。\n\n注意start>end的时候加入NULL。\n\n以及C++里面一些特殊写法，例如：\n\n用auto自动推断变量类型\n\n用new来声明结构体，这样分配在堆上，不会在函数结束时销毁\n\n->运算符用来解引用去除成员变量\n\n\n\n# 题解\n\nc++实现如下\n\n```c++\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n };\n\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        vector<TreeNode*> ans;\n        if(n==0) return ans;\n        ans = dfs(1, n);\n        return ans;\n    }\n\n    vector<TreeNode*> dfs(int start, int end){\n        vector<TreeNode*> ans;\n        if(start > end){ \n            ans.push_back(NULL);\n            return ans;\n        }\n        for(int i=start; i<=end; i++){\n            vector<TreeNode*> left = dfs(start, i-1);\n            vector<TreeNode*> right = dfs(i+1, end);\n            for(auto l: left){\n                for(auto r: right){\n                    TreeNode* root = new TreeNode(i);\n                    root -> left = l;\n                    root -> right = r;\n                    ans.push_back(root);\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n","tags":["刷题","暴搜"],"categories":["算法"]},{"title":"不同的二叉搜索树","url":"/2019/10/04/不同的二叉搜索树/","content":"\n# 题目\n\n给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n\n示例:\n\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/unique-binary-search-trees\n\n# 思路\n\n可以依次选择1，2，3…n为根节点建树\n\n选出i为根时，分成两边，1，2，3…i-1和i+1,i+2,i+3…n\n\n分别建子树\n\n因为是二叉搜索树，所以和具体元素无关，只需要考虑节点个数。即节点个数相同，构造出来的树的情况数也相同\n\n\n\n因此dp[i]表示i个节点的二叉树数目\n\n递推为一个乘积的求和式子\n\n注意dp[0]=dp[1]=1，否则若dp[0]=0，则乘法会全部变成0\n\n\n\n## 题解\n\nc++实现如下\n\n```c++\nclass Solution {\npublic:\n    int numTrees(int n) {\n        int dp[1000];\n        for(int i=0;i<=n;i++) dp[i] = 0;\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i=2;i<=n;i++){\n            for(int j=0;j<i;j++){\n                dp[i] += dp[j]*dp[i-j-1];\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"石子游戏","url":"/2019/10/04/石子游戏/","content":"\n# 题目\n\n亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。\n\n游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。\n\n亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。\n\n假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/stone-game\n\n# 思路\n\n有个题解写的蛮好，就直接参考了他的思路\n\n\n\n1. 先找方程\n\n   需要起始位置，还有能区别两个人的first和second\n\n   ![image](https://s2.ax1x.com/2019/10/04/uBc72q.png)\n\n2. 再找递推关系\n\n   ![image](https://s2.ax1x.com/2019/10/04/uBcqMV.png)\n\n   就是先收后手的转化以及比较\n\n3. 找原始递推条件\n\n   一路递推下去起始就是i=j的时候\n\n   ![image](https://s2.ax1x.com/2019/10/04/uBgZIH.png)\n\n4. 画出矩阵图\n\n   ![image](https://s2.ax1x.com/2019/10/04/uBgGdg.png)\n\n   这一步主要是为了写起来更直观\n\n   \n\n# 题解\n\n参考题解：\n\n作者：labuladong\n链接：https://leetcode-cn.com/problems/stone-game/solution/jie-jue-bo-yi-wen-ti-de-dong-tai-gui-hua-tong-yong/\n来源：力扣（LeetCode）\n\n\n\nc++代码如下\n\n```c++ \nclass Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        int N = piles.size();\n        pair<int, int> dp[1000][1000];\n        for (int i = 0; i < N; i++) \n            for (int j = i; j < N; j++){\n            dp[i][j].first = 0;\n            dp[i][j].second = 0;\n        }\n        for(int i=0;i<N;i++){\n            dp[i][i].first = piles[i];\n            dp[i][i].second = 0;\n        }\n        for(int i=0;i<N;i++){\n            for(int j=1;j<N;j++){\n                if(i+j<N) {\n                    int left = piles[i] + dp[i+1][i+j].second;\n                    int right = piles[j] + dp[i][i+j-1].second;\n                    dp[i][i+j].first = max(left, right);\n                    if(left > right){\n                        dp[i][i+j].second = dp[i+1][i+j].first;\n                    } else\n                        dp[i][i+j].second = dp[i][i+j-1].second;\n                }\n            }\n        }\n        return dp[0][N-1].first > dp[0][N-1].second;\n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"软件架构实践翻译&&笔记（三）--可修改性","url":"/2019/10/04/软件架构实践翻译&&笔记（三）--可修改性/","content":"\n### 可修改性\n\n#### Tactics\n\n##### 1. Reduce the Size of a Module\n\n- Split module：如果一个被修改的模块包含了大量职责，那么修改的代价就会很高。将大的模块细化成许多小的模块可以减少未来修改的平均代价。\n\n##### 2. Increase Cohesion\n\n增加内聚。将职责移交给另一个模块的目的是减少修改原模块职责的副作用 —— 使其不会影响到其他模块。\n\n- Increase semantic coherence：如果A和B的职责不是为了**服务同一个目的而存在**，那么它们应该被放在不同的模块中。可以新建一个模块或是移入一个已经存在的模块。识别需要迁移的职责的一个方法是假设可能发生的变化是如何影响模块的。如果一些职责不会被这些变化影响，那么这些职责应该被迁移。\n\n##### 3. Reduce Coupling\n\n- Encapsulate：封装赋予一个模块显式的接口。**此接口包括了应用编程接口API和它有关的职责**，例如\"对于输入的参数进行语法转化，使之转化成内部的表示\"。封装是最常见的一种可修改性策略，减少了修改一个模块而影响其他模块的可能性。耦合的强度现在转移到了接口上。这些强度大大减少了，因为接口限制了外部职责和内部模块的交互。外部的职责现在只要直接访问外部的接口就可以和模块交互（间接交互，但是，有些情况是不会改变的，例如依赖服务本身是不会改变的）。接口被设计来增加可修改性，它们应该是抽象的，屏蔽了模块可能改变的细节 —— 隐藏了这些细节。\n- Use an intermediary：**使用一个中介打破了依赖**。假设职责A和B之间有依赖关系（例如执行A之前要求先执行B），但是这种依赖关系可以由引入一个中介而被打破。中介的类型取决于依赖的类型。例如，发布订阅中介将会移除数据生产者对于消费者所必要的认知。数据仓库也是同样如此，它分离了数据的读取者和写入者。在面向服务的架构中，服务在一个动态的查找中互相发现，服务的目录就是一个中介。\n- Restrict dependencies：**限制一个模块依赖其他的模块。实践中是限制模块的可见性**（当开发者不能看见一个接口的时候，他们不能使用这些接口）**以及权限**。（限制权限，只供有权限的模块使用）这种策略被用于分层的架构中，每层只被允许调用下面的层。（有时仅仅是相邻的下一层）；以及用于包裹器中，外部的实体尽能见到（因此智能依赖）包裹器而不能见到它内部的功能。\n- Refactor：如果受到同一个变化影响的两个模块是相同的（至少部分相同），那么就要进行重构。代码重构是敏捷软件开发的一个重要支撑。**作为一个对于多余代码或者过度复杂的代码的清理**，这一思想也被用于软件架构中。常见的职责（以及实现它们的代码）被重构到模块之外并且分配到一个适当的位置。将相同职责的放在一起 —— 也就是让他们成为一个父模块的子模块 —— 可以减少耦合。\n- Abstract common services：**两个模块提供的不是相同的服务，但是是相似的服务，那么一个经济的方法是将它们实现一次**，实现成一个抽象的方式。任何一个对于此服务的修改只需要出现在一个地方，减少了修改的代价。一个引入抽象的方法是将描述（和实现）变成模块行为的参数。这种参数是足够简单的（例如关键变量的值），或复杂的（特定语言的复杂语句）。","tags":["读书笔记","架构","翻译"],"categories":["读书笔记","翻译"]},{"title":"素数筛法","url":"/2019/09/26/素数筛法/","content":"\n1. 判断单个数字n是否是素数，只需要依次从2判断到根号n即可\n\n2. 判断小于n有几个素数，就可以用筛法\n\n3. 判断[a, b]之间有几个素数，也可以转化成问题2\n\n\n\n![image-20190926200125757](/Users/cengshaoxun/Library/Application Support/typora-user-images/image-20190926200125757.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint prime[1000000];\nbool is_prime[1000000];\n\nint sieve(int n){\n    int p = 0;\n    for(int i = 0; i <= n; i++) is_prime[i] = true;\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i <= n; i++){\n        if(is_prime[i]){\n            prime[p++] = i;\n            for(int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n        }\n    }\n    return p;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    cout << sieve(n);\n    return 0;\n}\n```\n\n","tags":["数学问题"],"categories":["算法"]},{"title":"c++默认实参和重载","url":"/2019/09/24/c-默认实参和重载/","content":"\nc++函数的默认实参和重载混合之后的一些情况\n\n编程环境：\n\nApple clang version 11.0.0 (clang-1100.0.20.17)\n\n\n\n## 重复定义\n\n``` c++\n#include <iostream>\nusing namespace std;\n\nint func(int a,int b, int c = 1);\n\nint main()\n{\n    cout << \"func(1,2): \" << func(1,2) << endl;\n\n    return 0;\n}\n\nint func(int a,int b,int c = 1)  // 这种是错误的，重复定义了默认参数\n{\n    return a*b*c;\n}\n```\n\n函数声明中定义了c的默认实参，这时候如果在定义中又给了c默认实参，即使值相等，编译器也是会报错\n\n\n\n##无效重载\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint func(int a,int b, int c);\n\nint main()\n{\n    cout << \"func(1,2): \" << func(1,2,3) << endl;\n\n    return 0;\n}\n\nint func(int a,int b,int c = 0)  // 这种是无效的，因为声明是三个，所以参数必须是三个，默认参数不会用上\n{\n    return a*b*c;\n}\n```\n\n这种写法虽然不会报错，但是因为函数的使用要严格按照函数声明，所以实际上默认参数永远不会被用到\n\n\n\n## 头文件\n\n``` c++\n#include <iostream>\n#include \"c.h\"\nusing namespace std;\n\nint func(int a,int b=1, int c);\n\nint main()\n{\n    cout << \"func(1,2): \" << func(1) << endl;\n\n    return 0;\n}\n\nint func(int a,int b,int c)  // 这种是可以的，因为头文件中c是默认参数\n{\n    return a*b*c;\n}\n\n```\n\nc.h:\n\n```c++\nint func(int a,int b, int c = 3);\n```\n\n这种写法可以，在头文件中给c默认实参，cpp文件中给b默认实参，可以正确调用和赋值\n\n\n\n## 顺序颠倒\n\n```c++\n#include <iostream>\nusing namespace std;\n\n\nint func(int a,int b=1, int c);\nint func(int a,int b, int c=0);\n\nint main()\n{\n    cout << \"func(1,2): \" << func(1) << endl;\n\n    return 0;\n}\n\nint func(int a,int b,int c)  // 这种是不行的，因为放在最开头的那一个函数声明最右边是没有值的；调换顺序之后才可以\n{\n    return a*b*c;\n}\n```\n\n考虑到头文件其实是拷贝到文件的开头替换掉 #include，因此实际上第三个例子中c的默认实参是在b之前就给出了，如果颠倒了顺序，就报错\n\n\n\n## 总结\n\n1. 默认实参是要从右往左定义的，即右边的一定是默认实参\n2. 可以多次声明函数，多次声明的时候，不能再此定义同一个默认实参，即使值相同\n3. 多次声明的函数可以增加新的实参，但是也是遵循靠右原则，不能重复，顺序也不能颠倒\n4. 函数的定义中不需要写默认实参，写了也没用（会被声明覆盖）","tags":["c++","语法"],"categories":["c++"]},{"title":"软件架构实践翻译&&笔记（一）--可用性","url":"/2019/09/19/软件架构实践翻译&&笔记（一）可用性/","content":"\n### 可用性\n\n系统的可用时间占总时间的百分比\n\n#### Tactics\n\n##### 1. Detect Faults（检测错误）\n\n- Ping/echo：指的是一对节点之间异步的请求/相应信息，用来检测在相关联的网络路径上的的**可达性**和**延迟。**也用来决定被ping的组件（component）存活并且正确响应。ping通常是由一个系统监控器（monitor）发出。Ping/echo 要求设置一个**时间期限**(threshold)；这个时限告诉发出ping信号的组件要等待echo信号多久，否则就认为被ping的组件失效（超时）。一个ping/echo的标准实现是通过IP的节点互连。\n\n- Monitor：一个监视器（monitor）是一个用于**监视系统其他部分**（例如处理器，进程，IO，内存等）健康状态的组件。系统监视器可以**检测错误**或者**网络拥塞**，或者**其他共享资源**，例如拒绝服务攻击等。它使用这个分类中的**其他方法**检测故障组件，保证整个系统的协调运行。例如，系统监视器可以初始化自检测（self-tests），或者检测错误的时间戳、失常的心跳（heartbeats）。\n\n- Heartbeat：通过**在系统监视器（monitor）和被监视进程之间周期性的信息交换**来实现的一个错误检测机制。心跳的一个特殊例子是被监视进程周期性地重置系统监视器上的监视定时器（watchdog timer）来防止自身被认为失效（引发错误）。当一个系统的可扩展性是一个关注点的时候，传送和提前处理（心跳信息）可以通过如下方式来减少：**将心跳信息放在其他控制信息中**，在被监视进程和分布式系统控制器之间交换。心跳和ping/echo的一个极大的不同点是：谁来发起初始化心跳检测，是系统监视器还是组件自身（如果是monitor发起，那么是ping/echo；反之则是heartbeat）。\n\n  > watchdog：当一个检测机制是采用周期性地重制一个计数器或者计时器时，这个特殊的系统监视器就被称为watchdog。在一个流程中，被监视进程会周期性地重置此计数器或计时器来说明它正常工作，这有时被称作petting the watchdog。\n\n- Time stamp：这个策略（tactic）被用来**测检不正确的时间序列**，主要用在分布式的消息传送系统中。事件的时间戳可以用如下方式来建立：在事件发生后，立即设置一个**本地时钟的状态**给该事件。一串简单的**顺序数字**也可以被用作这个目的（如果时间信息不重要的话）。\n\n- Sanity checking：检查一个组件特定操作或者输出的**合理性和正确性**。这个策略基于内部设计—**系统的状态**或者**正常情况下的信息特性**。主要用于接口检测特定的信息流。\n\n- Condition monitoring：检查一个设备或者进程的**状态**，或者**验证**设计过程中的猜想。通过检测状态（condition），此策略防止系统产生出错误的行为。计算检验和（checksums）是一个典型的例子。但是，监视器（monitor）本身必须是足够**简单的（形式完美的（ideally），可被证明的（provable））**来确保它不会引发新的错误。（*PS（译者注）*：例如检验和的算法必须是数学上证明正确的）。\n\n- Voting：这个策略最普遍的实现是三模块冗余（TMR）——用三个模块来做相同的事情，每一个模块接收相同的输入，并将他们产生的结果输入投票逻辑（logic），用来检测三个输出是否一致。如果不一致，那么投票机制会**报告一个错误**，而且它也必须**决定采取哪一个输出**。采用多数原则，或者计算不同输出的平均值。这个策略严重依赖于具体的投票逻辑，这个逻辑通常是简单的，被严格检验和测试过的，以确保发生错误的概率尽量低。\n\n- Replication：投票（voting）机制的简单形式。**组件互相复制**（clones）。有多个组件的拷贝可以有效地**防止硬件的随机错误**，但是这**不能保证软件或者硬件中设计或者实现的错误**，因为这个策略没有多样性。（*PS（译者注）*：其实是同一个组件，不过有好几份，所以如果组件本身逻辑有错误，那么错误依然会发生；投票机制中多个组件可以是不同实现的，只不过期望的功能相同。）\n\n- Functional redundancy：投票策略的一个形式，用来解决软件或者硬件中**设计或者实现的错误**。基于相同的输入，组件必须给出相同的输出，但是他们设计和实现上是不同的。（*PS（译者注）*：这个就是上面那种情况的升级版，即几个组件只是**功能上的冗余**，实现并不相同）。\n\n- Analytic redundancy：不仅允许设计和实现的不同，还**允许组件输入输出不同**。这个策略容忍规格上的的错误——通过使用不同的需求规格（？？？）。在嵌入式系统中，分析冗余（analytic redundancy）用于**输入资源不可获得**的情况下。例如航空程序有多种方法可以计算飞机海拔，例如气压方法，雷达方法或者通过直线距离和仰角等来计算。这种使用分析冗余的投票机制相比于多数原则或计算平均值需要考虑得更多。它可能需要理解哪一个传感器是可靠的，而且有可能需要给出一个**比任何组件具有更高可信度**的值 —— 通过分析和综合各个不同的结果。\n\n- Exception detection：检测系统中改变正常执行流程的状态，可被进一步细分：\n\n  1. System exceptions：处理器硬件架构，除0错误，总线错误，地址错误，非法程序指令等。\n  2. Parameter fence：采用一个预先确定好的数据格式来替换一个对象的可变长参数。这允许运行时检查重写对象可变长参数的内存分配的错误。\n  3. Parameter typing：用一个基础的类型来定义一些功能和数据长度、格式等。派生的类型用基础类型的功能来实现其他功能。用强类型来传递信息有更高的可用性——相比于弱类型看待任何类型都是字节流。当然任何设计都有权衡，当使用强类型时，获得了更高的可用性，但是丧失了部分演化（evolution）的便捷。 \n  4. Timeout：当一个组件检测到它或者其他组件超过规定的**时间期限**时，抛出一个异常。例如，当一个组件等待另一个组件响应的时候，当等待时间超过一个确定的值时，抛出一个异常。\n\n- Self-test：组件（或者整个子系统）可以运行一个程序来检测自身是否执行正确的操作。自测程序可以由**组件自己发起**，或者时不时地由一个**系统监视器发起**。它们可能会用一些条件监控中的策略，例如检验和等。\n\n##### 2. Recover from Faults（从错误状态恢复）\n\n**2.1 Preparation-and-repaire**\n\n这种策略包含了大量重试以及冗余策略。\n\n- Active redundancy(hot spare)：在一个保护组（见注解）所有节点（主节点或者冗余节点）**同时接收并且处理相同的输入**，这保证了冗余节点和主节点保持同步状态。由于冗余备份和主节点有着相同的状态，所以在主节点失效时，它可以很快地接替主节点。一个简单的情况是一个主节点配备一个冗余节点 —— 这被称为1+1冗余。Active redundancy也可以被用作设备保护，主要的网络连接和备用的网络连接一同确保网络连接的高可用性。\n\n  注：protection group指的是一群工作节点，这些节点中有一个或者多个节点是\"active\"（主节点），剩下的节点是冗余备份。\n\n- Passive redundancy(warm spare)：在一个保护组中，**只有主节点处理输入**，它们周期性地给冗余节点提供更新。因为冗余节点的状态和主节点的状态并**不是完全同步**（loosely coupled），这种冗余节点也被叫做warm spares。取决于系统的可用性需求程度，**被动的冗余提供了一个折衷方案**，即在高可用但是计算更加密集的active redundancy和低可用但是更简单的cold spare中做权衡。\n\n- Spare(cold spare)：Cold sparing指的是在一个保护组中，冗余节点完全不工作，直到一个错误发生。这时，**在冗余节点能提供服务之前，必须要执行一个启动程序**。由于恢复的性能低下，cold sparing更适用于只有高可靠的需求而不适用于有高可用的需求的系统。\n\n- Exception handling：一旦检测到一个异常，系统必须以某种方式来处理异常。**最简单的情况是崩溃，但是从可用性，易用性，可测试性和直觉上考虑，这是一个糟糕的主意**。处理异常的机制很大程度上取决于所使用的**编程环境**，从简单地返回错误码到复杂的异常类。软件可以用异常类包含的各种信息来检查错误。\n\n- Rollback：**这个策略允许系统返回到前一个已知的正确状态**，在检测到错误的时候进行时间的回滚。一旦达到了正确状态，那么程序就可以继续运行。**这个策略常常和active或者passive redundancy一起使用，这样的话，当回滚发生的时候，备用版本就可以替换主版本**。回滚依赖于前一个正确状态的**备份（检查点）是可获得的**。检查点可以存储在一个**固定的位置并且被定期更新，或者在一些方便或者重要的时候更新**，例如一个复杂操作完成的时候。\n\n- Software upgrade：**在系统运行的时候更新可执行代码而不影响正常的服务**。实现方式可以是一个函数的补丁，或者类的补丁，或者无中断运行中软件更新（ISSU）。函数补丁用于结构化编程中，使用一个增加的linker或者loader来将更新后的函数装载到预先分配好的目标内存位置中。**新版本的函数会使用弃用函数的入口和出口**。而且，装载新函数的时候，符号表必须被更新，并且之前的指令缓存也要被认为是非法的。**类补丁用于面向对象设计中**。类的定义中包含了一个后门，这可以用来在运行中加入新的成员函数和函数。（PS*译者注：*例如java中的反射）ISSU利用了active或者passive redundancy策略来达到更新但是不影响软件正常提供服务。在实践中，函数补丁和类补丁用于修复bug，而ISSU用于提供新功能。\n\n- Retry：重试策略假设引起失效的错误是**瞬时**的，并且**重试这个操作可能可以成功**。这个策略用于网络和服务器，在这些地方失效被认为是常态。应该**限制重试的次数**，超过这个次数就认为永久失效。\n\n- Ignore faulty behavior：这个策略**忽略特定来源**的信息，这些信息被认为是伪造的。例如，我们会忽略来自引发拒绝服务访问的外部组件的信息，这可以通过建立访问控制列表来完成。\n\n- Degradation：此策略在系统失效的时候，只维持**最为重要的系统功能**，而放弃次要的功能。当某个组件的失效**只是降低了系统的功能而不是导致整个系统失效**的时候，我们可以采用此功能。\n\n- Reconfiguration：此策略通过给仍在发挥作用的资源（很可能是受限的）**重新分配职责**，尝试从组件的错误中恢复。以此来维持尽可能多的功能可用。（PS*译者注：例如windows的安全模式*）\n\n**2.2 Reintroduction**\n\n这种策略用于失效组件在被修正后重新引入。\n\n- Shadow：这个策略指的是运行一个**先前失效**的或是**服务中更新(in-service upgraded)**的组件在一个\"影子模式\"中，持续一段预先定好的时间后，让组件重新回到正常的工作状态。在这段持续时间中，组件的行为会被监视，并且它可以重新恢复它的状态。\n- State resynchronization：此策略适用于active redundancy和passive redundancy这两种preparation-and-repair策略的重引入。当使用active redundancy策略的时候，状态重同步有组织地发生，因为主组件和备用组件同时各自接收和处理相同的输入。**在实践中，主组件和备用组件周期性地互相比较来确保同步**。这种比较可能是基于循环冗余校验或者系统提供的安全服务，例如一种信息摘要计算(message digest calculation)。当使用passive redundancy策略时，**状态的重同步只是基于主组件周期性地给备用组件传递信息，通常是通过检查点的方式**。这种策略的一个特殊例子是无状态服务，任何一种资源可以响应一个已经失效的资源的请求。\n- Escalating restart：此策略允许系统**调整组件重启的粒度**，**减小受影响的服务范围**来从一个失效中恢复过来。例如，假设一个系统支持4个等级的重启。最低等级的重启（等级0），对服务有最小的影响，使用passive redundancy，错误组件的所有子线程被杀死和重新创建。通过这种方法，只有关联于子线程的数据会被释放和重新初始化。下一个等级（等级1）的重启会释放和初始化所有不受保护的内存（保护中的内容不受影响）。再下一个等级（等级2）释放和重新初始化所有的内存，包括所有受保护和不受保护的部分，强迫所有的应用重新加载并重新初始化。最后一个等级（等级3）完全重新加载和重新初始化可执行映像和所有有关的数据段。**支持范围重启策略对降级(graceful degradation)特别有用**。系统能够减少它提供的服务，并且维持一些重要的任务和安全相关的应用。\n- Non-stop forwarding(NSF)：这个概念来源于路由器设计。在这个设计中，功能被分为两个部分：**监视，或控制通路（管理着连通性和路由信息），和数据通路（在发送者和接收者之间交换包）**如果路由的监控部分失效，那么它仍然可以在已知的路由器（邻居路由器）中继续传输包；当控制通路被重启时——有时被称为是\"graceful restart\" —— 增量重建路由协议数据库，此时数据通路仍然在继续工作。\n\n##### 3. Prevent Faults（预防错误）\n\n- Removal from service：次策略指的是**暂时将一个系统组件从工作状态切换成非工作状态，为了减轻潜在的系统失效**。一个例子是终止和重启一个组件，使得潜在的错误（例如内存泄漏，碎片化，或在不受保护的缓存中的软错误（soft errors））不会累积从而影响正常服务。此策略的另一个名称是软件再生（software rejuvenation）。\n- Transactions：高可用的系统服务降低事务的语义来保证在分布式的组件中传递的同步信息是**原子的(atomic)、一致的(consistent)、分离(isolated)的和可持久(durable)的**。这四个属性被称为ACID属性。最常见的实现是\"two-phase commit\"协议。这个策略阻止了竞争情况，这种情况是由两个进程同时试图更新相同的数据引起的。\n- Predictive model：一个预测模型，和一个监视器结合，用来监视系统进程的健康状态，**确保系统的操作是基于预定的操作参数，并且当预测到发生错误的可能性时，可以采取正确的措施**。被监视的操作性能指标用来预测错误的发生，这样的例子包括session建立的频率（在一个HTTP server中），跨越阈值（对一些约束检测预警线的高低），或是维持进程状态的数据（服务中，不在服务中，维修中，等待中），消息队列长度数据等等。\n- Exception prevention：此策略预防系统发生异常。**异常类的使用**，允许系统从异常状态恢复而不被用户感知，这之前已经讨论过了。另一个阻止异常的例子包括**一些抽象数据类型**，例如智能指针，以及用包裹器来预防错误，例如野指针和信号量反问违规。智能指针通过指针边界检查和确保资源被正确回收来预防错误发生。\n- Increase competence set：**一个程序的功能集合指的是状态的集合，这种状态是它能够进行操作的**。例如，分母为0的情况超出了大部分除法程序的功能范围。当一个组件抛出一个异常时，表明它发现情况超出了它的功能范围；本质上，它并不知道如何解决，因此抛出了异常。**增加一个组件的功能集合意味着将它设计地能处理更多情况 —— 错误 —— 也成为了正常操作的一部分**。例如，一个组件假设它有权限访问共享资源，当它发现它的权限被阻止的时候，它可能会抛出一个异常；另一个组件可能只是会一直等待授予权限，或者立即返回，并带有一个提示 —— 下次它有权限的时候，它将完成此操作。在这个例子中，第二个组件相比第一个有着更大的功能集合。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["读书笔记","架构","翻译"],"categories":["读书笔记","翻译"]},{"title":"乘积最大子序列","url":"/2019/09/10/乘积最大子序列/","content":"\n# 题目\n\n给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。\n\n示例 1:\n\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n示例 2:\n\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximum-product-subarray\n\n# 思路\n\n连续最大的乘积序列，可以考虑什么时候连乘会变小—有时候是0，有时候是负数\n\n对于负数而言，他会让之前正数连乘的积变成最小；同时也会让之前的负数连乘变成最大。因此我们要保留两个值：之前连乘的最大和最小值\n\n对于可能出现0的情况，其实不用考虑，因为此时连乘的最大最小值都是0\n\n为了保证每次都可以得到连乘的max和min，在每次计算乘积的时候，都要取计算的结果和当前位置的max或者min。例如，计算连乘max的时候，MAX = max(MAX*nums[i], nums[i])\n\n遇到负数，交换最大最小，再计算\n\n\n\n# 题解\n\n参考：https://leetcode-cn.com/problems/maximum-product-subarray/solution/hua-jie-suan-fa-152-cheng-ji-zui-da-zi-xu-lie-by-g/\n\n\n``` c++\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int result = -100000;\n        int Max = 1;\n        int Min = 1;\n        for(int i=0; i<nums.size(); i++){\n            if(nums[i]<0) {\n                int temp = Max;\n                Max = Min;\n                Min = temp;\n            }\n            Max = max(Max*nums[i], nums[i]);\n            Min = min(Min*nums[i], nums[i]);\n            \n            result = max(result, Max);\n        }\n        return result;\n    }\n};\n```\n\n\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"单词拆分","url":"/2019/09/06/单词拆分/","content":"\n# 题目\n\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n说明：\n\n拆分时可以重复使用字典中的单词。\n你可以假设字典中没有重复的单词。\n示例 1：\n\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n示例 2：\n\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。\n     注意你可以重复使用字典中的单词。\n示例 3：\n\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/word-break\n\n# 思路\n\n刚开始只想到了暴力搜索\n\n可以用DFS、BFS还有剪枝之后的DFS\n\n\n\n如果用动态规划的话，可以这样考虑：\n\n首先令dp数组的第i项表示从0开始到位置i的串可以被拆分，这样只要取出最后一个位置就是题解\n\n其次为了利用前面的dp数组位置，可以将串拆分为两部分，一部分必然被前面的情况包含，另一部分再判断即可\n\n\n\n# 题解\n\n参考了官方题解\n\n这个方法的想法是对于给定的字符串（s）可以被拆分成子问题 s1 和 s2。如果这些子问题都可以独立地被拆分成符合要求的子问题，那么整个问题 s 也可以满足。也就是，如果 \"\ncatsanddog\" 可以拆分成两个子字符串 \"catsand\" 和 “dog\" 。子问题 \"catsand\" 可以进一步拆分成 \"cats\" 和 \"and\" ，这两个独立的部分都是字典的一部分，所以 \"catsand\" 满足题意条件，再往前， \"catsand\" 和 ”dog\" 也分别满足条件，所以整个字符串 \"catsanddog\" 也满足条件。\n\n现在，我们考虑 dp 数组求解的过程。我们使用 n+1 大小数组的 dp ，其中 n 是给定字符串的长度。我们也使用 2 个下标指针 i 和 j ，其中 i 是当前字符串从头开始的子字符串（s ′ ）的长度， j 是当前子字符串（s ′ ）的拆分位置，拆分成 s ′ (0,j) 和 s′(j+1,i)。为了求出 dp 数组，我们初始化 dp[0] 为 true ，这是因为空字符串总是字典的一部分。 dp 数组剩余的元素都初始化为 false 。我们用下标 i 来考虑所有从当前字符串开始的可能的子字符串。对于每一个子字符串，我们通过下标 j 将它拆分成 s1 ′ 和 s2 ′（注意 i 现在指向 s2 ′  的结尾）。为了将dp[i] 数组求出来，我们依次检查每个 dp[j] 是否为 true ，也就是子字符串 s1 ′ 是否满足题目要求。如果满足，我们接下来检查 s2 ′ 是否在字典中。如果包含，我们接下来检查 s2 ′ 是否在字典中，如果两个字符串都满足要求，我们让 dp[i] 为 true ，否则令其为 \nfalse 。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode/\n来源：力扣（LeetCode）\n\n\n\nc++代码如下\n\n``` c++ \nclass Solution {\nprivate:\n    bool contain(string s, vector<string> v){\n        for(string ss: v){\n            if(ss == s){\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        bool dp[s.size()+1];\n        dp[0] = true;\n        for(int i=1; i<=s.size(); i++){\n            for(int j=0; j<i; j++){\n                dp[i] = false;\n                if(dp[j] && contain(s.substr(j, i-j), wordDict)){\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.size()];\n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"三角形最小路径和","url":"/2019/09/05/三角形最小路径和/","content":"\n# 题目\n\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n\n例如，给定三角形：\n\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/triangle\n\n# 思路\n\n注意两点：\n\n1. 不能从上往下的贪婪，而是要从下往上的贪婪\n2. 从下而上的贪婪可以保证当前位置到最低点的路径和是最大的。自然到了最高点，就可以求出最大值\n\n这是因为，基于当前的最优并不是全局最优，而从后往前则可以考虑全局\n\n\n\n用一位数组存储即可，边计算边保存，恰好不会被覆盖\n\n```\ndp[j] = min(dp[j], dp[j+1]) + triangle[i][j]\n```\n\n\n\n# 解法\n\n``` c++\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int dp[triangle.size()];\n        for(int k=0; k<triangle.size(); k++){\n            dp[k] = triangle[triangle.size()-1][k];\n        }\n        for(int i=triangle.size()-2; i>=0; i--){\n            for(int j=0; j<triangle[i].size(); j++){\n                dp[j] = min(dp[j], dp[j+1]) + triangle[i][j];\n            }\n        }\n        return dp[0];\n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"解码方法","url":"/2019/09/05/解码方法/","content":"\n# 题目\n\n一条包含字母 A-Z 的消息通过以下方式进行了编码：\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n给定一个只包含数字的非空字符串，请计算解码方法的总数。\n\n示例 1:\n\n输入: \"12\"\n输出: 2\n解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。\n示例 2:\n\n输入: \"226\"\n输出: 3\n解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/decode-ways\n\n# 思路\n\n这个和走楼梯的那题很像\n\n一段楼梯，一次可以走一个台阶，或者两个台阶，一共有多少种走法\n\n```\ndp[i] = dp[i-1] + dp[i-2]\n```\n\n这一题多了一个判断，即不是每个dp[i-1]和dp[i-2]都可以累加到dp[i]中，因为有可能有以下两种情况：\n\n1. 对于两个字符的情况\n\n   超过26的不行\n\n   04这种0开头的不行\n\n2. 对于一个字符的情况\n\n   0不行\n\n因此可以容易写出解\n\n\n\n# 解法\n\n``` c++\nclass Solution {\nprivate:\n    bool judge(string s){\n        return stoi(s)>0 && stoi(s)<27 && s[0] != '0';\n    }\npublic:\n    int dp[10000];\n    int numDecodings(string s) {\n        if(s.size()==1) return judge(s);\n        dp[0] = judge(s.substr(0, 1));\n        dp[1] = judge(s.substr(0, 2)) + (judge(s.substr(1, 1)) && judge(s.substr(0, 1)));\n        for(int i=2; i<s.size(); i++){\n            if(judge(s.substr(i, 1)) && s[i]!='0') dp[i] += dp[i-1];\n            if(judge(s.substr(i-1, 2))) dp[i] += dp[i-2];\n        }\n        return dp[s.size()-1];\n    }\n};\n```\n\n\n\n简化的写法来自网上：\n\n``` python\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        pp, p = 1, int(s[0] != '0')\n        for i in range(1, len(s)):\n            pp, p = p, pp * (9 < int(s[i-1:i+1]) <= 26) + p * (int(s[i]) > 0)\n        return p\n```\n\n\ni 从索引 1 开始逐渐遍历 s，当前位置对应结果 = 上上次结果(如果 i 位置字符和 i-1 位置字符的组合满足条件；即满足在9-27之间) + 上次结果(如果 s[i] 不为 0)\n\n作者：QQqun902025048\n链接：https://leetcode-cn.com/problems/decode-ways/solution/4-xing-python-dp-onshi-jian-o1kong-jian-by-qqqun90/\n来源：力扣（LeetCode）\n\n\n\n\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"最小路径和","url":"/2019/09/05/最小路径和/","content":"\n# 题目\n\n给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n示例:\n\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-path-sum\n\n# 思路\n\n思路和https://leetcode-cn.com/problems/min-cost-climbing-stairs一致\n\n```c++\ndp[i][j] = min(dp[i-1][j], dp[i][j-1]) + arr[i][j]\n```\n\n # 解法\n\n``` c++\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int a = grid.size();\n        int b = grid[0].size();\n        int dp[a][b];\n        dp[0][0] = grid[0][0];\n        for(int i=0; i<a; i++){\n            for(int j=0; j<b; j++){\n                if(i>0 && j>0) dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n                else if(j>0) dp[i][j] = dp[i][j-1] + grid[i][j];\n                else if(i>0) dp[i][j] = dp[i-1][j] + grid[i][j];\n            }\n        }\n        return dp[a-1][b-1];\n    }\n};\n```\n\n还可以用一维数组优化一下，只需要用到上面一行和前一个位置即可","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"最长回文子串","url":"/2019/09/04/最长回文子串/","content":"\n# 题目\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n示例 1：\n\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n示例 2：\n\n输入: \"cbbd\"\n输出: \"bb\"\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring\n\n# 思路\n\n首先能想到的一个思路是获得所有子串，判断是否是回文，再取最长的\n\n稍微优化一下就是，遍历每一个字符，作为中心点，向两边扩展，这样可以直接判断是否是回文，然后长度也可以直接求出\n\n注意这里中心点可以是一个，例如aba；也可以是两个，例如abba\n\n\n\n# 解法\n\n这里因为两种情况的扩展是相似的，所以可以抽象成一个函数，不同的是传入的参数来控制中心点是一个还是两个\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/\n来源：力扣（LeetCode）\n\n``` java\npublic String longestPalindrome(String s) {\n    if (s == null || s.length() < 1) return \"\";\n    int start = 0, end = 0;\n    for (int i = 0; i < s.length(); i++) {\n        int len1 = expandAroundCenter(s, i, i);\n        int len2 = expandAroundCenter(s, i, i + 1);\n        int len = Math.max(len1, len2);\n        if (len > end - start) {\n            start = i - (len - 1) / 2;\n            end = i + len / 2;\n        }\n    }\n    return s.substring(start, end + 1);\n}\n\nprivate int expandAroundCenter(String s, int left, int right) {\n    int L = left, R = right;\n    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {\n        L--;\n        R++;\n    }\n    return R - L - 1;\n}\n```\n\n\n\n评论下面还有两个方法可以优化\n\n1. 字符中间插入特殊字符，来同一个两种中心点\n\n2. 马拉车算法\n\n   https://segmentfault.com/a/1190000008484167","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"最大正方形","url":"/2019/09/04/最大正方形/","content":"\n# 题目\n\n在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。\n\n示例:\n\n输入: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\n输出: 4\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximal-square\n\n# 思路\n\n只想到一个暴力的思路就是先对每行遍历，找到连续的1就开始向每一列搜索，看看是否组成正方形，如果确实组成正方形，就更新最大边长\n\n\n\n# 解法\n\n参考leetcode官方题解：\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode/\n来源：力扣（LeetCode）\n\n![image](https://s2.ax1x.com/2019/09/04/nZ53Of.png)\n\n对照着写的代码：\n\n``` c++\nclass Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if(matrix.size()==0) return 0;\n        int max = 0;\n        int dp[matrix.size()][matrix[0].size()];\n        for(int i=0; i<matrix.size(); i++){\n            for(int j=0; j<matrix[0].size(); j++){\n                if(i>0 && j>0 && matrix[i][j]=='1'){\n                    dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1;\n                    max = dp[i][j]>max?dp[i][j]:max;\n                } else if(matrix[i][j]=='1') {\n                    dp[i][j] = 1;\n                    max = dp[i][j]>max?dp[i][j]:max;\n                }\n                else dp[i][j] = 0;\n            }\n        }\n        return max*max;\n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"使用最小花费爬楼梯","url":"/2019/09/04/使用最小花费爬楼梯/","content":"\n# 题目\n\n数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。\n\n每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。\n\n您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。\n\n示例 1:\n\n输入: cost = [10, 15, 20]\n输出: 15\n解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。\n 示例 2:\n\n输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n输出: 6\n解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。\n注意：\n\ncost 的长度将会在 [2, 1000]。\n每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs\n\n# 思路\n\n如果便利所有情况的话显然过于复杂，具体的情况数应该是斐波那契数列的某一项，复杂度太高。\n\n如果考虑用贪婪的话也不太对，因为存在一种情况是首选一个花费较大的，但是之后可能存在一个花费更小的，例如 [0, 1, 2, 2]，如果是贪婪的话选择0-1-2，但是最小的花费应该是0-2\n\n用贪婪的问题是，这实际上是一个累加的问题，不是基于当前情况就能判断的问题，必须要是前面所有的积累\n\n故而就想到遍历所有情况，因为若是不知道之后的情况，似乎也是没法确定是否选择当前的走法\n\n这时候就要转化一下思路，想一想dp的解法\n\ndp的解法是：\n\ndp[i] = min(dp[i-1],dp[i-2]) + cost[i] （第0和第1个位置是dp的初始值）\n\n即要走到第i个台阶，考虑它之前的两个台阶，取小的那个加上当前台阶的花费即可。这样当我们求出最后两个台阶的dp时，就可以取小的那个，然后走完全部台阶\n\n\n\n# 解法\n\n按照上面的想法翻译一下代码即可，需要注意的是最后还要判断一下dp的最后两个位置，取小的值作为结果返回\n\n``` c++\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        // dp[i] = min(dp[i-1],dp[i-2]) + cost[i]\n        int a = cost[0], b = cost[1];\n        int c = 0;\n        for(int i=2; i<cost.size(); i++){\n            c = a>b?b:a;\n            c += cost[i];\n            a = b;\n            b = c;\n        }\n        return a>c?c:a;\n    }\n};\n```\n\n\n\n# 总结\n\n写出状态转移方程就会清晰很多","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"判断子序列","url":"/2019/09/03/判断子序列/","content":"\n# 题目\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。\n\n示例 1:\ns = \"abc\", t = \"ahbgdc\"\n\n返回 true.\n\n示例 2:\ns = \"axc\", t = \"ahbgdc\"\n\n返回 false.\n\n后续挑战 :\n\n如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/is-subsequence\n\n# 思路\n\n原题没什么好说的，直接一个循坏找出来就行了\n\n``` c++\nclass Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        int i=0;\n        if(s.size()==0) return true;\n        bool flag = false;\n        for(char c: t){\n            if(c==s[i]){\n                i++;\n            }\n            if(i==s.size()){\n                flag = true;\n                break;\n            }\n        }\n        return flag;\n    }\n};\n```\n\n扩展部分没什么好的思路，就直接看题解了\n\n\n\n# 题解\n\n作者：zzzzzz-5\n链接：https://leetcode-cn.com/problems/is-subsequence/solution/cpan-duan-zi-xu-lie-hou-xu-tiao-zhan-by-zzzzzz-5/\n\n后续挑战，输入量大，小写字母创建25的二维数组，存储t的坐标，这样就可以把s的判断直接转为坐标的判断，\ndp[0]代表了存储了a出现在t的所有的位置,逐个字符判断s的字符顺序是否在t内，直接返回结果。\n时间复杂度O(t.size()+2000)：分别为创建数组需要O(t.size()),\n索引是递增的使用二分查找s的单个字符20次之内就可找到需要O(100*20)。\n适用大量的输入判断子序列。\n\n``` c++\nbool isSubsequence(string s, string t) {      \n  vector<vector<int>>dp(26);\n  int tag=-1;\n  for(int i=0;i<t.size();i++)\n    dp[t[i]-'a'].push_back(i);\n  for(int i=0;i<s.size();i++){\n    int now=s[i]-'a';\n    int left=0,right=dp[now].size()-1;            \n    if(right<0) return false;\n    while(left<right){\n      int mid=(left+right)/2;\n      if(dp[now][mid]>tag)\n        right=mid;\n      else\n        left=mid+1;\n    }\n    if(right<left || dp[now][left]<tag)return false;\n    tag=dp[now][left];\n  }\n  return true;\n}\n```\n\n不需要存储所有的字串，而是存下长字符串的坐标，然后对每个短的字串再判断\n对于每个短的串，一个小循环：对每个字符，先找到比前一个字符的坐标（tag）大的最小坐标（更新为下一个tag）；第一个字符只要初始化tag=-1即可找到第一个字符的最小坐标\n用二分查找，right对应的数设置为比mid大的数，这样如果存在比tag大的数，left最终会等于right，且那个位置一定是要找的那个数；如果不存在，那么最后left和right都会等于原来的right，最后判断一下dp[now][left]和tag的大小即可\n注意二分查找退出的时候，其实是不会出现right<left的情况的，只有可能是找到那个数或者dp[now][left]<tag，这时候即找不到比前一个tag大的位置，故而返回false","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"Emacs Org-mode 笔记","url":"/2019/08/12/emacs笔记/","content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">\n<head>\n<!-- 2019-08-12 Mon 11:24 -->\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Emacs Org-mode 笔记</title>\n<meta name=\"generator\" content=\"Org mode\" />\n<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/\n  .title  { text-align: center;\n             margin-bottom: .2em; }\n  .subtitle { text-align: center;\n              font-size: medium;\n              font-weight: bold;\n              margin-top:0; }\n  .todo   { font-family: monospace; color: red; }\n  .done   { font-family: monospace; color: green; }\n  .priority { font-family: monospace; color: orange; }\n  .tag    { background-color: #eee; font-family: monospace;\n            padding: 2px; font-size: 80%; font-weight: normal; }\n  .timestamp { color: #bebebe; }\n  .timestamp-kwd { color: #5f9ea0; }\n  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }\n  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }\n  .org-center { margin-left: auto; margin-right: auto; text-align: center; }\n  .underline { text-decoration: underline; }\n  #postamble p, #preamble p { font-size: 90%; margin: .2em; }\n  p.verse { margin-left: 3%; }\n  pre {\n    border: 1px solid #ccc;\n    box-shadow: 3px 3px 3px #eee;\n    padding: 8pt;\n    font-family: monospace;\n    overflow: auto;\n    margin: 1.2em;\n  }\n  pre.src {\n    position: relative;\n    overflow: visible;\n    padding-top: 1.2em;\n  }\n  pre.src:before {\n    display: none;\n    position: absolute;\n    background-color: white;\n    top: -10px;\n    right: 10px;\n    padding: 3px;\n    border: 1px solid black;\n  }\n  pre.src:hover:before { display: inline;}\n  /* Languages per Org manual */\n  pre.src-asymptote:before { content: 'Asymptote'; }\n  pre.src-awk:before { content: 'Awk'; }\n  pre.src-C:before { content: 'C'; }\n  /* pre.src-C++ doesn't work in CSS */\n  pre.src-clojure:before { content: 'Clojure'; }\n  pre.src-css:before { content: 'CSS'; }\n  pre.src-D:before { content: 'D'; }\n  pre.src-ditaa:before { content: 'ditaa'; }\n  pre.src-dot:before { content: 'Graphviz'; }\n  pre.src-calc:before { content: 'Emacs Calc'; }\n  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }\n  pre.src-fortran:before { content: 'Fortran'; }\n  pre.src-gnuplot:before { content: 'gnuplot'; }\n  pre.src-haskell:before { content: 'Haskell'; }\n  pre.src-hledger:before { content: 'hledger'; }\n  pre.src-java:before { content: 'Java'; }\n  pre.src-js:before { content: 'Javascript'; }\n  pre.src-latex:before { content: 'LaTeX'; }\n  pre.src-ledger:before { content: 'Ledger'; }\n  pre.src-lisp:before { content: 'Lisp'; }\n  pre.src-lilypond:before { content: 'Lilypond'; }\n  pre.src-lua:before { content: 'Lua'; }\n  pre.src-matlab:before { content: 'MATLAB'; }\n  pre.src-mscgen:before { content: 'Mscgen'; }\n  pre.src-ocaml:before { content: 'Objective Caml'; }\n  pre.src-octave:before { content: 'Octave'; }\n  pre.src-org:before { content: 'Org mode'; }\n  pre.src-oz:before { content: 'OZ'; }\n  pre.src-plantuml:before { content: 'Plantuml'; }\n  pre.src-processing:before { content: 'Processing.js'; }\n  pre.src-python:before { content: 'Python'; }\n  pre.src-R:before { content: 'R'; }\n  pre.src-ruby:before { content: 'Ruby'; }\n  pre.src-sass:before { content: 'Sass'; }\n  pre.src-scheme:before { content: 'Scheme'; }\n  pre.src-screen:before { content: 'Gnu Screen'; }\n  pre.src-sed:before { content: 'Sed'; }\n  pre.src-sh:before { content: 'shell'; }\n  pre.src-sql:before { content: 'SQL'; }\n  pre.src-sqlite:before { content: 'SQLite'; }\n  /* additional languages in org.el's org-babel-load-languages alist */\n  pre.src-forth:before { content: 'Forth'; }\n  pre.src-io:before { content: 'IO'; }\n  pre.src-J:before { content: 'J'; }\n  pre.src-makefile:before { content: 'Makefile'; }\n  pre.src-maxima:before { content: 'Maxima'; }\n  pre.src-perl:before { content: 'Perl'; }\n  pre.src-picolisp:before { content: 'Pico Lisp'; }\n  pre.src-scala:before { content: 'Scala'; }\n  pre.src-shell:before { content: 'Shell Script'; }\n  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }\n  /* additional language identifiers per \"defun org-babel-execute\"\n       in ob-*.el */\n  pre.src-cpp:before  { content: 'C++'; }\n  pre.src-abc:before  { content: 'ABC'; }\n  pre.src-coq:before  { content: 'Coq'; }\n  pre.src-groovy:before  { content: 'Groovy'; }\n  /* additional language identifiers from org-babel-shell-names in\n     ob-shell.el: ob-shell is the only babel language using a lambda to put\n     the execution function name together. */\n  pre.src-bash:before  { content: 'bash'; }\n  pre.src-csh:before  { content: 'csh'; }\n  pre.src-ash:before  { content: 'ash'; }\n  pre.src-dash:before  { content: 'dash'; }\n  pre.src-ksh:before  { content: 'ksh'; }\n  pre.src-mksh:before  { content: 'mksh'; }\n  pre.src-posh:before  { content: 'posh'; }\n  /* Additional Emacs modes also supported by the LaTeX listings package */\n  pre.src-ada:before { content: 'Ada'; }\n  pre.src-asm:before { content: 'Assembler'; }\n  pre.src-caml:before { content: 'Caml'; }\n  pre.src-delphi:before { content: 'Delphi'; }\n  pre.src-html:before { content: 'HTML'; }\n  pre.src-idl:before { content: 'IDL'; }\n  pre.src-mercury:before { content: 'Mercury'; }\n  pre.src-metapost:before { content: 'MetaPost'; }\n  pre.src-modula-2:before { content: 'Modula-2'; }\n  pre.src-pascal:before { content: 'Pascal'; }\n  pre.src-ps:before { content: 'PostScript'; }\n  pre.src-prolog:before { content: 'Prolog'; }\n  pre.src-simula:before { content: 'Simula'; }\n  pre.src-tcl:before { content: 'tcl'; }\n  pre.src-tex:before { content: 'TeX'; }\n  pre.src-plain-tex:before { content: 'Plain TeX'; }\n  pre.src-verilog:before { content: 'Verilog'; }\n  pre.src-vhdl:before { content: 'VHDL'; }\n  pre.src-xml:before { content: 'XML'; }\n  pre.src-nxml:before { content: 'XML'; }\n  /* add a generic configuration mode; LaTeX export needs an additional\n     (add-to-list 'org-latex-listings-langs '(conf \" \")) in .emacs */\n  pre.src-conf:before { content: 'Configuration File'; }\n\n  table { border-collapse:collapse; }\n  caption.t-above { caption-side: top; }\n  caption.t-bottom { caption-side: bottom; }\n  td, th { vertical-align:top;  }\n  th.org-right  { text-align: center;  }\n  th.org-left   { text-align: center;   }\n  th.org-center { text-align: center; }\n  td.org-right  { text-align: right;  }\n  td.org-left   { text-align: left;   }\n  td.org-center { text-align: center; }\n  dt { font-weight: bold; }\n  .footpara { display: inline; }\n  .footdef  { margin-bottom: 1em; }\n  .figure { padding: 1em; }\n  .figure p { text-align: center; }\n  .equation-container {\n    display: table;\n    text-align: center;\n    width: 100%;\n  }\n  .equation {\n    vertical-align: middle;\n  }\n  .equation-label {\n    display: table-cell;\n    text-align: right;\n    vertical-align: middle;\n  }\n  .inlinetask {\n    padding: 10px;\n    border: 2px solid gray;\n    margin: 10px;\n    background: #ffffcc;\n  }\n  #org-div-home-and-up\n   { text-align: right; font-size: 70%; white-space: nowrap; }\n  textarea { overflow-x: auto; }\n  .linenr { font-size: smaller }\n  .code-highlighted { background-color: #ffff00; }\n  .org-info-js_info-navigation { border-style: none; }\n  #org-info-js_console-label\n    { font-size: 10px; font-weight: bold; white-space: nowrap; }\n  .org-info-js_search-highlight\n    { background-color: #ffff00; color: #000000; font-weight: bold; }\n  .org-svg { width: 90%; }\n\n</style>\n<script type=\"text/javascript\">\n\nfunction CodeHighlightOn(elem, id)\n {\n   var target = document.getElementById(id);\n   if(null != target) {\n     elem.cacheClassElem = elem.className;\n     elem.cacheClassTarget = target.className;\n     target.className = \"code-highlighted\";\n     elem.className   = \"code-highlighted\";\n   }\n }\n function CodeHighlightOff(elem, id)\n {\n   var target = document.getElementById(id);\n   if(elem.cacheClassElem)\n     elem.className = elem.cacheClassElem;\n   if(elem.cacheClassTarget)\n     target.className = elem.cacheClassTarget;\n }\n\n</script>\n</head>\n<body>\n<div id=\"content\">\n<div id=\"table-of-contents\">\n<h2>Table of Contents</h2>\n<div id=\"text-table-of-contents\">\n<ul>\n<li><a href=\"#org6a7ea47\">1. Emacs 笔记</a>\n<ul>\n<li><a href=\"#orga44e949\">1.1. core 核心键位</a></li>\n<li><a href=\"#org7566de2\">1.2. buffer管理</a></li>\n<li><a href=\"#org6da97c2\">1.3. 在org大纲中移动 创建org大纲</a></li>\n<li><a href=\"#orgcd62c20\">1.4. style 样式</a>\n<ul>\n<li><a href=\"#orgf13ff98\">1.4.1. 各种格式</a></li>\n<li><a href=\"#orgdec8264\">1.4.2. ordered-list unordered-list description  各种列表（有序/无序/描述）</a></li>\n<li><a href=\"#orgcf79d1c\">1.4.3. checkbox 检查点</a></li>\n<li><a href=\"#org600f97f\">1.4.4. link 链接</a></li>\n<li><a href=\"#org96b580a\">1.4.5. 换行</a></li>\n</ul>\n</li>\n<li><a href=\"#org095b1fb\">1.5. codes 代码块和其他block</a>\n<ul>\n<li><a href=\"#orgfd6dd0f\">1.5.1. 普通代码块</a></li>\n</ul>\n</li>\n<li><a href=\"#orgac957b1\">1.6. table 表格</a>\n<ul>\n<li><a href=\"#org816a0e3\">1.6.1. 创建表格</a></li>\n<li><a href=\"#org92b3d0b\">1.6.2. 增加行列</a></li>\n<li><a href=\"#orgd96d6de\">1.6.3. 删除行列</a></li>\n<li><a href=\"#orge654cbc\">1.6.4. 移动行列</a></li>\n</ul>\n</li>\n<li><a href=\"#org28d2028\">1.7. calendar 日历</a>\n<ul>\n<li><a href=\"#org40cc6f0\">1.7.1. 进入日历</a></li>\n<li><a href=\"#org2a3d4f5\">1.7.2. 基本操作</a></li>\n<li><a href=\"#org92c4454\">1.7.3. 日记</a></li>\n</ul>\n</li>\n<li><a href=\"#orgbd7c803\">1.8. windows 窗口调整</a>\n<ul>\n<li><a href=\"#orgd99906b\">1.8.1. 新建窗口</a></li>\n<li><a href=\"#org0a8668e\">1.8.2. 移动窗口</a></li>\n<li><a href=\"#org0ceed61\">1.8.3. 调整窗口大小</a></li>\n<li><a href=\"#org44a1444\">1.8.4. 调整窗口位置</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-org6a7ea47\" class=\"outline-2\">\n<h2 id=\"org6a7ea47\"><span class=\"section-number-2\">1</span> Emacs 笔记</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\n修订历史\n</p>\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col  class=\"org-right\" />\n\n<col  class=\"org-left\" />\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"org-right\">时间</th>\n<th scope=\"col\" class=\"org-left\">内容                               ;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"org-right\">2019-07-15</td>\n<td class=\"org-left\">init，增加了一些基本样式和移动的说明</td>\n</tr>\n</tbody>\n<tbody>\n<tr>\n<td class=\"org-right\">2019-07-16</td>\n<td class=\"org-left\">增加了对日历使用说明</td>\n</tr>\n</tbody>\n</table>\n</div>\n\n\n<div id=\"outline-container-orga44e949\" class=\"outline-3\">\n<h3 id=\"orga44e949\"><span class=\"section-number-3\">1.1</span> core 核心键位</h3>\n<div class=\"outline-text-3\" id=\"text-1-1\">\n<ul class=\"org-ul\">\n<li><code>M-m</code> unlock the infinite power !!!</li>\n<li><code>C-x</code> some useful shortcuts !!!</li>\n<li><code>M-x</code> all functions and packages !!!</li>\n<li><code>M-x h d f</code> help to describe a function !!!</li>\n\n<li><code>C-f</code> 删除当前的命令（打错命令可以用这个来删除重新敲）</li>\n<li><code>C-c</code> org模式下面的prefix快捷键，可以查看常用的操作</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org7566de2\" class=\"outline-3\">\n<h3 id=\"org7566de2\"><span class=\"section-number-3\">1.2</span> buffer管理</h3>\n<div class=\"outline-text-3\" id=\"text-1-2\">\n<p>\n基本上有两种途径可以实现\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-org6da97c2\" class=\"outline-3\">\n<h3 id=\"org6da97c2\"><span class=\"section-number-3\">1.3</span> 在org大纲中移动 创建org大纲</h3>\n<div class=\"outline-text-3\" id=\"text-1-3\">\n<ul class=\"org-ul\">\n<li><code>C-c C-n</code> 移动到下一个标题</li>\n<li><code>C-c C-p</code> 移动到上一个标题</li>\n\n<li><code>M-RET</code> 新建标题\n<code>注意</code> 如果是在： \n<b>之前</b> 那么会在之前新建\n<b>之中</b> 那么会切分成两半\n<b>之后</b> 那么会在之后新建</li>\n<li><code>C-RET</code> 在下面新建标题（跳过所有的子节点）</li>\n<li><code>M-up</code> 向上移动标题（同等级的移动）</li>\n<li><code>M-down</code> 向下移动标题（同等级的移动）</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orgcd62c20\" class=\"outline-3\">\n<h3 id=\"orgcd62c20\"><span class=\"section-number-3\">1.4</span> style 样式</h3>\n<div class=\"outline-text-3\" id=\"text-1-4\">\n</div>\n<div id=\"outline-container-orgf13ff98\" class=\"outline-4\">\n<h4 id=\"orgf13ff98\"><span class=\"section-number-4\">1.4.1</span> 各种格式</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-1\">\n<dl class=\"org-dl\">\n<dt>bold 粗体 </dt><dd><b>粗体</b></dd>\n<dt>Italy 斜体</dt><dd><i>斜体</i></dd>\n<dt>delete 删除线</dt><dd><del>delete</del></dd>\n<dt>underline 下划线</dt><dd><span class=\"underline\">下划线</span></dd>\n<dt>subscript 下标</dt><dd>H<sub>2</sub> O</dd>\n<dt>superscript 上标</dt><dd>E = mc<sup>2</sup></dd>\n<dt>monospace 等宽</dt><dd><code>git</code> 或者 <code>git</code> (btw, I love this color!!)</dd>\n</dl>\n</div>\n</div>\n\n<div id=\"outline-container-orgdec8264\" class=\"outline-4\">\n<h4 id=\"orgdec8264\"><span class=\"section-number-4\">1.4.2</span> ordered-list unordered-list description  各种列表（有序/无序/描述）</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-2\">\n<p>\n官网：<a href=\"https://orgmode.org/manual/Plain-lists.html\">https://orgmode.org/manual/Plain-lists.html</a>\n</p>\n<ol class=\"org-ol\">\n<li>有序列表\n直接标注 1. 或者 1) <code>注意</code> 要使用英文输入</li>\n<li>无序列表\n用 - + 或 *</li>\n<li>描述（类似于定义之类的）\n空格加上两冒号，例如：\nterm :: definition\n注意，如果此时是加载无序列表前面，还会自动加粗\n<ol class=\"org-ol\">\n<li>无序列表 :: definition</li>\n<li>无序列表 :: definition</li>\n<li>无序列表 :: definition</li>\n</ol></li>\n</ol>\n<p>\n<code>注意，所有层级关系都可以用以下快捷键</code>\n</p>\n<ul class=\"org-ul\">\n<li><code>M-RET</code> 来插入一个新行（可以自动增加序号）</li>\n\n<li><code>M-up</code> 向上移动标题（同等级的移动）</li>\n<li><code>M-down</code> 向下移动标题（同等级的移动）</li>\n\n<li><code>M-left</code> 不带子节点，让当前标示升级 <b>标题或者列表</b> 列表可以是无序列表，下同</li>\n<li><code>M-right</code> 不带子节点，让当前标示降级 <b>标题或者列表</b></li>\n<li><code>M-S-left</code>  带子节点，让当前标示升级 <b>标题或者列表</b></li>\n<li><code>M-S-right</code> 带子节点，让当前标示升级 <b>标题或者列表</b></li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orgcf79d1c\" class=\"outline-4\">\n<h4 id=\"orgcf79d1c\"><span class=\"section-number-4\">1.4.3</span> checkbox 检查点</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-3\">\n<ul class=\"org-ul\">\n<li><code>M-S-RET</code> 创建一个检查点（仅限于org模式）\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> 待办事项</li>\n</ul></li>\n<li><code>C-c C-c</code> 改变box的状态\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> 未完成</li>\n<li class=\"on\"><code>[X]</code> 已完成</li>\n</ul></li>\n<li><code>S-right</code> 用在标题上: 加上 TODO 或者 DONE 字样;\n用在列表上：改变列表样式（无序改为有序等）</li>\n<li><code>S-right</code> 同上</li>\n\n<li><code>[/]</code> 用来标记完成情况\n使用方法：先写成上面这样，然后创建检查点 <code>M-S-RET</code> ，然后用 <code>M-right</code> 或 <code>M-left</code>  缩进即可\n任务进度<code>[0/3]</code>\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n\n<li>[ ]<code>[0/2]</code>\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n</ul></li>\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n</ul></li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org600f97f\" class=\"outline-4\">\n<h4 id=\"org600f97f\"><span class=\"section-number-4\">1.4.4</span> link 链接</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-4\">\n<p>\n官网：<a href=\"https://orgmode.org/manual/Internal-links.html\">https://orgmode.org/manual/Internal-links.html</a>\n</p>\n\n\n<p>\n[[月亮宝石[英]威尔基·柯林斯.徐汝椿等译.上海译文出版社(1980).pdf][d]]\ncontrol x\ncontrol f\ncontrol b\n窗口调整\n全屏\n安装layers\n查看所有layers\noption m\noption x \n</p>\n</div>\n</div>\n\n<div id=\"outline-container-org96b580a\" class=\"outline-4\">\n<h4 id=\"org96b580a\"><span class=\"section-number-4\">1.4.5</span> 换行</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-5\">\n<ul class=\"org-ul\">\n<li><code>M-m t l</code> 自动换行 toggle - truncate line</li>\n</ul>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-org095b1fb\" class=\"outline-3\">\n<h3 id=\"org095b1fb\"><span class=\"section-number-3\">1.5</span> codes 代码块和其他block</h3>\n<div class=\"outline-text-3\" id=\"text-1-5\">\n</div>\n<div id=\"outline-container-orgfd6dd0f\" class=\"outline-4\">\n<h4 id=\"orgfd6dd0f\"><span class=\"section-number-4\">1.5.1</span> 普通代码块</h4>\n<div class=\"outline-text-4\" id=\"text-1-5-1\">\n<p>\n例如c：\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-c\">int add(int a, int b){\n    return a + b;\n}\n</pre>\n</div>\n\n<p>\n例如java：\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">public static int add(int a, int b){\n    System.out.println()\n    return a + b;\n}\n</pre>\n</div>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-orgac957b1\" class=\"outline-3\">\n<h3 id=\"orgac957b1\"><span class=\"section-number-3\">1.6</span> table 表格</h3>\n<div class=\"outline-text-3\" id=\"text-1-6\">\n<p>\n<code>表格对中文支持很差，不建议在表格中使用中文</code>\n</p>\n</div>\n<div id=\"outline-container-org816a0e3\" class=\"outline-4\">\n<h4 id=\"org816a0e3\"><span class=\"section-number-4\">1.6.1</span> 创建表格</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-1\">\n<p>\norg模式下\n</p>\n<ul class=\"org-ul\">\n<li><code>| | |</code> 然后 <code>tab</code> ，可以新建对齐的列</li>\n</ul>\n<p>\n在第一步的基础上，可以用\n</p>\n<ul class=\"org-ul\">\n<li><code>|-</code> 然后 <code>tab</code> ，可以新建带横线的边框</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org92b3d0b\" class=\"outline-4\">\n<h4 id=\"org92b3d0b\"><span class=\"section-number-4\">1.6.2</span> 增加行列</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-2\">\n<ul class=\"org-ul\">\n<li><code>|-</code> 然后 <code>tab</code> 可以新建带横线的边框（新增一行）</li>\n<li><code>|</code> 然后 <code>tab</code> 可以新建一列</li>\n\n<li><code>M-S right</code> 新建一列</li>\n<li><code>M-S down</code> 新建一行</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orgd96d6de\" class=\"outline-4\">\n<h4 id=\"orgd96d6de\"><span class=\"section-number-4\">1.6.3</span> 删除行列</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-3\">\n<ul class=\"org-ul\">\n<li><code>M-S left</code> 删除一列</li>\n<li><code>M-S up</code> 删除一行</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orge654cbc\" class=\"outline-4\">\n<h4 id=\"orge654cbc\"><span class=\"section-number-4\">1.6.4</span> 移动行列</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-4\">\n<ul class=\"org-ul\">\n<li><code>M-left</code> 向左移动</li>\n<li><code>M-right</code> 向右移动</li>\n<li><code>M-up</code> 向上移动</li>\n<li><code>M-down</code> 向下移动</li>\n</ul>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-org28d2028\" class=\"outline-3\">\n<h3 id=\"org28d2028\"><span class=\"section-number-3\">1.7</span> calendar 日历</h3>\n<div class=\"outline-text-3\" id=\"text-1-7\">\n</div>\n<div id=\"outline-container-org40cc6f0\" class=\"outline-4\">\n<h4 id=\"org40cc6f0\"><span class=\"section-number-4\">1.7.1</span> 进入日历</h4>\n<div class=\"outline-text-4\" id=\"text-1-7-1\">\n<p>\n好多种方法可以打开日历\n</p>\n<ul class=\"org-ul\">\n<li><code>C-c &gt;</code> 直接进入</li>\n<li><code>M-x calendar</code> 搜索进入</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org2a3d4f5\" class=\"outline-4\">\n<h4 id=\"org2a3d4f5\"><span class=\"section-number-4\">1.7.2</span> 基本操作</h4>\n<div class=\"outline-text-4\" id=\"text-1-7-2\">\n<p>\n进入之后下面就有说明\n</p>\n<ul class=\"org-ul\">\n<li><code>?</code> 查看帮助手册</li>\n<li><code>.</code> 定位到当前日期</li>\n<li><code>o</code> 快速定位到其他日期</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org92c4454\" class=\"outline-4\">\n<h4 id=\"org92c4454\"><span class=\"section-number-4\">1.7.3</span> 日记</h4>\n<div class=\"outline-text-4\" id=\"text-1-7-3\">\n<p>\n<code>基本操作</code>\n</p>\n<ol class=\"org-ol\">\n<li>日记需要遵循一定的格式</li>\n<li>支持鼠标操作（右键日期）</li>\n</ol>\n\n<p>\n<code>查看操作</code>\n通过日历查看\n<code>M-x calendar</code> 进入日历\n</p>\n<ol class=\"org-ol\">\n<li><code>d</code> display 查看日记（不能编辑）</li>\n<li><code>s</code> 直接进入日记文件（可以编辑）</li>\n<li><code>m</code> mark所有有日记的日期</li>\n<li><code>u</code> unmark之前的标记</li>\n</ol>\n\n<p>\n直接查看diary\n</p>\n<ol class=\"org-ol\">\n<li><code>M-x diary</code> 直接查看diary</li>\n</ol>\n\n\n<p>\n<code>新建操作</code>\n</p>\n<ol class=\"org-ol\">\n<li><code>i d</code> 在选择的日期上添加一个日记入口（精确到日）</li>\n<li><code>i w</code> 在选择的星期上添加一个日记入口（精确到周）</li>\n<li><code>i m</code> 在选择的月份上添加一个日记入口（精确到月）</li>\n<li><code>i y</code> 在选择的年份上添加一个日记入口（精确到年）</li>\n<li><code>i u</code> 创建一个在指定日期之后的每年的纪念日（例如节日，生日等等）\n<code>注意是在指定日期之后</code></li>\n<li><code>i b</code> 创建一个指定范围内所有日期的日记入口（范围时间）</li>\n<li><code>i c</code> 创建循环的日记入口</li>\n</ol>\n\n<p>\n<code>消息通知</code>\n</p>\n<ol class=\"org-ol\">\n<li></li>\n\n<li></li>\n</ol>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-orgbd7c803\" class=\"outline-3\">\n<h3 id=\"orgbd7c803\"><span class=\"section-number-3\">1.8</span> windows 窗口调整</h3>\n<div class=\"outline-text-3\" id=\"text-1-8\">\n</div>\n<div id=\"outline-container-orgd99906b\" class=\"outline-4\">\n<h4 id=\"orgd99906b\"><span class=\"section-number-4\">1.8.1</span> 新建窗口</h4>\n</div>\n<div id=\"outline-container-org0a8668e\" class=\"outline-4\">\n<h4 id=\"org0a8668e\"><span class=\"section-number-4\">1.8.2</span> 移动窗口</h4>\n</div>\n<div id=\"outline-container-org0ceed61\" class=\"outline-4\">\n<h4 id=\"org0ceed61\"><span class=\"section-number-4\">1.8.3</span> 调整窗口大小</h4>\n</div>\n<div id=\"outline-container-org44a1444\" class=\"outline-4\">\n<h4 id=\"org44a1444\"><span class=\"section-number-4\">1.8.4</span> 调整窗口位置</h4>\n<div class=\"outline-text-4\" id=\"text-1-8-4\">\n<ul class=\"org-ul\">\n<li><code>M-x w .</code> 进入主控面板，可以做一切事情\n拥有对面板控制的最高权限\n包括调整窗口大小，位置，恢复，删除等</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div id=\"postamble\" class=\"status\">\n<p class=\"validation\"><a href=\"http://validator.w3.org/check?uri=referer\">Validate</a></p>\n</div>\n</body>\n</html>\n","tags":["Emacs","org-mode"],"categories":["Emacs"]},{"title":"建。。建站手册？🗝","url":"/2019/08/11/Hello-World/","content":"\n[TOC]\n\n# 修改历史\n\n| 时间      | 内容                       |\n| --------- | -------------------------- |\n| 2019-8-12 | 初稿                       |\n| 2019-8-29 | 完善图片显示和其他格式问题 |\n\n# 前言\n\n花了点时间捣鼓了个Hexo博客，顺便记录一下捣鼓过程，不想看过程的可以直接跳到[最后](#最后)\n\n**🕘 预计配置时间**： 3hours？Maybe fewer.\n\n**🖥 完成配之后将拥有：**\n\n1. 一个github仓库作为数据存储的静态博客\n\n2. 基本功能齐全，前端还算不错的个人博客，省得自己搭架子\n\n   ![blog](https://s2.ax1x.com/2019/08/29/mbAVyQ.png)\n\n3. 采用hexo博客框架，[Casper](https://github.com/xzhih/hexo-theme-casper)作为模板，自动渲染md，一键部署到github\n\n4. 模板自身支持发布文章，阅读文章，新建页面，分类，标签\n\n5. 自己添加了一些功能可以手动写md实现时间轴，增加了流量统计\n\n\n\n# 折腾过程实录\n\n**1. github page**\n\n​\t要部署到github的话，先搞一个github仓库，直接google一下[github page](https://www.google.com/search?q=github+page&oq=github+page&aqs=chrome..69i57j35i39j69i60l4.2108j0j4&sourceid=chrome&ie=UTF-8)咋整就行了，这一步注意仓库的名字有特殊的要求，不然后面会显示不出来东西。有手就行的东西就不展开了🙌\n\n**2. hexo**\n\n​\t同上，google一下[hexo](https://hexo.io/zh-cn/docs/)的安装过程，同有手就行🤞\n\n​\t这里可以稍微熟悉一下几个命令\n\n```shell\nhexo new post helloworld\nhexo clean  # 清空一下之前生成的文件，如果修改不生效可以试试这个命令，先清空一下\nhexo g      # generate，编译渲染\nhexo d      # deploy，自动部署\n```\n\n\n\n**3. hexo部署到github page上**\n\n​\tgoogle之[hexo整合github](https://hexo.io/zh-cn/docs/deployment)。。有手就行👀。。。\n\n​\t这里可以稍微注意一下，部署的分支和资源存储的分支是分开的，部署的分支github貌似要求是master，资源可以新建一个分支\n\n**4. pick一个主题**\n\n​\t这里我选了[Casper](https://github.com/xzhih/hexo-theme-casper)作为模板，另外有一个模板看起来也不错👉[icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/about/)。下面的内容都是根据我选择的Casper展开。\n\n​\t更换主题就是直接把Casper的github repo（具体地址在上面链接👆）clone到**themes**文件夹下。\n\n​\t稍微解释一下这些个文件夹都是干啥的，之后有用。\n\n```\n├── README.md\n├── _config.yml          # 配置文件，可以配置很多东西，之后会介绍\n├── languages            # 语言包，直接在配置文件里面设置zh-CN就是中文了\n│   ├── default.yml\n│   ├── fr.yml\n│   ├── nl.yml\n│   ├── no.yml\n│   ├── ru.yml\n│   ├── zh-CN.yml\n│   └── zh-TW.yml\n├── layout               # 布局文件，自定义一些布局基本都在这里修改\n│   ├── _layout.swig\n│   ├── _partials\n│   ├── archive.swig\n│   ├── category.swig\n│   ├── index.swig\n│   ├── page.swig\n│   ├── post.swig\n│   └── tag.swig\n├── scripts\n│   └── index.js\n└── source               # 源文件，配合布局一起修改\n    ├── css\n    ├── fonts\n    ├── img\n    └── js\n```\n\n**5. 配置主题**\n\n​\t这一步主要是修改**_config**这个文件，这里有俩config，一个是博客根目录的config，一个是**themes/hexo-casper**里的config，都可以配置，重点说一下主题里面的那个config\n\n![_config](https://s2.ax1x.com/2019/08/29/mbAtm9.png)\n\n参考我这个稍微配置一下就行了，另外[Casper](https://github.com/xzhih/hexo-theme-casper)里面写的很清楚了，照着改改就差不多了\n\n\n\n**6. 增加流量统计**\n\n​\t提了issue问怎么统计流量，回答说有个评论系统自带了流量统计功能，但是注册过程比较麻烦，就放弃了。这里采用[不蒜子](http://ibruce.info/2015/04/04/busuanzi/)，很是方便，而且速度很快，只要简单配置一下就可以了。\n\n配置之前先详细解释一下layout的结构：\n\n```shell\n├── _layout.swig            # 页面总体布局（修改基本没用到它）\n├── _partials               # 小组件，方便复用\n│   ├── about.swig            # 这个就是ABOUT界面上面的那些小东西，见下面图例\n│   ├── footer.swig           # 注脚，见下面图例\n│   ├── head.swig\n│   ├── header.swig\n│   ├── index.swig\n│   ├── javascript.swig\n│   ├── page.swig\n│   ├── post.swig\n│   ├── public\n│   │   ├── fload-header.swig\n│   │   ├── icons\n│   │   ├── json-ld.swig\n│   │   ├── nav.swig\n│   │   ├── social.swig\n│   │   └── toc.swig\n│   ├── search.swig\n│   ├── widget                # 这三个就是分类、tag和recent\n│   │   ├── category.swig\n│   │   ├── recent_posts.swig\n│   │   └── tagcloud.swig\n│   └── widget.swig\n├── archive.swig              # archive页面的布局\n├── category.swig\n├── index.swig\n├── page.swig\n├── post.swig\n└── tag.swig\n```\n\n_partials/about.swig:\n\n![about](https://s2.ax1x.com/2019/08/29/mbAUT1.png)\n\n_partials/foot.swig:\n\n![foot](https://s2.ax1x.com/2019/08/29/mbAdFx.png)\n\n**7. 将分类写到导航栏上面**\n\n```\nhexo new page xxx\n```\n\n这个命令可以新建一个导航页面，但是只是单独的一页文章。如果要把categories的每个分类放到导航栏上面，可以稍作修改。\n\n方法一：\n\n在**config**里面修改：\n\n```\nmenu:\n  ABOUT: /about\n  ARCHIVES: /archives\n  TEST: /categories/test/\n```\n\n这样手动可以把某个分类添加到导航栏上面。\n\n方法二：\n\n观察**layout/_partails/widget/categories**中的写法，发现只要添加一行代码就可以添加link到指定分类的链接。故只要在**layout/_partails/public/nav.swig**中修改如下：（绿色的注释）\n\n![nav](https://s2.ax1x.com/2019/08/29/mbVkrQ.png)\n\n**8. 给页面加上阴影**\n\n因为项目中将css全部整合到**allinonecss.min.css**中，因此要直接修改这个css文件，修改其他的css文件不生效！！！\n\n全局搜索\n\n```\n.post-full-content\n```\n\n添加css\n\n```\nbox-shadow:0px 16px 16px #E0E0E0;\nborder-radius: 8px;\n```\n\n即可添加shadow和圆角\n\n**8. 添加时间线**\n\n这个可以通过手写markdown来手动实现时间线\n\n首先在**scripts/index.js**最后添加如下代码：（来自<http://channingsun.bid/2016/05/10/20160510_%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Timeline/>）\n\n```js\n//timeline\nhexo.extend.tag.register('timeline', function(args, content){\n\tdate = args[0]\n\ttime = args[1]\n\tlogo = args[2]\n\tvar result = '';\n\tresult += '<blockquote>';\n\tlogo = '<span class=\"fa-stack fa-lg\"><i class=\"fa ' + logo + ' fa-stack-1x\"></i></span>';\n\tresult += hexo.render.renderSync({text: logo + content, engine: 'markdown'});\n\tfooter = '<span>' + date + ' ' + time + '</span>'\n\tresult += '<footer>' + footer + '</footer>';\n\tresult += '</blockquote>';\n\treturn result;\n}, {ends: true});\n```\n\n然后只要写\n\n```\n{% timeline 2015-01-23 18:38:26 fa-lg %} 第一篇博客 {% post_link hello-world hello-world %} {% endtimeline %}\n```\n\n即可跳转到对应的博客\n\n也可以适当调整一下js里面的内容，比如表情和time可以删掉\n\n# 最后\n\n最后就配置好了，嗯。想看配置过程的可以看[折腾过程实录](#%E6%8A%98%E8%85%BE%E8%BF%87%E7%A8%8B%E5%AE%9E%E5%BD%95)\n\n\n\n\n\n\n\n","tags":["Hello World"]},{"title":"hello-world","url":"/2019/08/10/hello-world/","content":"\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment]("}]