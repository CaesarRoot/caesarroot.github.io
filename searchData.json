[{"title":"乘积最大子序列","url":"/2019/09/10/乘积最大子序列/","content":"\n# 题目\n\n给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。\n\n示例 1:\n\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n示例 2:\n\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximum-product-subarray\n\n# 思路\n\n连续最大的乘积序列，可以考虑什么时候连乘会变小—有时候是0，有时候是负数\n\n对于负数而言，他会让之前正数连乘的积变成最小；同时也会让之前的负数连乘变成最大。因此我们要保留两个值：之前连乘的最大和最小值\n\n对于可能出现0的情况，其实不用考虑，因为此时连乘的最大最小值都是0\n\n为了保证每次都可以得到连乘的max和min，在每次计算乘积的时候，都要取计算的结果和当前位置的max或者min。例如，计算连乘max的时候，MAX = max(MAX*nums[i], nums[i])\n\n遇到负数，交换最大最小，再计算\n\n\n\n# 题解\n\n参考：https://leetcode-cn.com/problems/maximum-product-subarray/solution/hua-jie-suan-fa-152-cheng-ji-zui-da-zi-xu-lie-by-g/\n\n\n``` c++\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int result = -100000;\n        int Max = 1;\n        int Min = 1;\n        for(int i=0; i<nums.size(); i++){\n            if(nums[i]<0) {\n                int temp = Max;\n                Max = Min;\n                Min = temp;\n            }\n            Max = max(Max*nums[i], nums[i]);\n            Min = min(Min*nums[i], nums[i]);\n            \n            result = max(result, Max);\n        }\n        return result;\n    }\n};\n```\n\n\n\n","tags":["刷题","动态规划"],"categories":["leetcode"]},{"title":"单词拆分","url":"/2019/09/06/单词拆分/","content":"\n# 题目\n\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n说明：\n\n拆分时可以重复使用字典中的单词。\n你可以假设字典中没有重复的单词。\n示例 1：\n\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n示例 2：\n\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。\n     注意你可以重复使用字典中的单词。\n示例 3：\n\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/word-break\n\n# 思路\n\n刚开始只想到了暴力搜索\n\n可以用DFS、BFS还有剪枝之后的DFS\n\n\n\n如果用动态规划的话，可以这样考虑：\n\n首先令dp数组的第i项表示从0开始到位置i的串可以被拆分，这样只要取出最后一个位置就是题解\n\n其次为了利用前面的dp数组位置，可以将串拆分为两部分，一部分必然被前面的情况包含，另一部分再判断即可\n\n\n\n# 题解\n\n参考了官方题解\n\n这个方法的想法是对于给定的字符串（s）可以被拆分成子问题 s1 和 s2。如果这些子问题都可以独立地被拆分成符合要求的子问题，那么整个问题 s 也可以满足。也就是，如果 \"\ncatsanddog\" 可以拆分成两个子字符串 \"catsand\" 和 “dog\" 。子问题 \"catsand\" 可以进一步拆分成 \"cats\" 和 \"and\" ，这两个独立的部分都是字典的一部分，所以 \"catsand\" 满足题意条件，再往前， \"catsand\" 和 ”dog\" 也分别满足条件，所以整个字符串 \"catsanddog\" 也满足条件。\n\n现在，我们考虑 dp 数组求解的过程。我们使用 n+1 大小数组的 dp ，其中 n 是给定字符串的长度。我们也使用 2 个下标指针 i 和 j ，其中 i 是当前字符串从头开始的子字符串（s ′ ）的长度， j 是当前子字符串（s ′ ）的拆分位置，拆分成 s ′ (0,j) 和 s′(j+1,i)。为了求出 dp 数组，我们初始化 dp[0] 为 true ，这是因为空字符串总是字典的一部分。 dp 数组剩余的元素都初始化为 false 。我们用下标 i 来考虑所有从当前字符串开始的可能的子字符串。对于每一个子字符串，我们通过下标 j 将它拆分成 s1 ′ 和 s2 ′（注意 i 现在指向 s2 ′  的结尾）。为了将dp[i] 数组求出来，我们依次检查每个 dp[j] 是否为 true ，也就是子字符串 s1 ′ 是否满足题目要求。如果满足，我们接下来检查 s2 ′ 是否在字典中。如果包含，我们接下来检查 s2 ′ 是否在字典中，如果两个字符串都满足要求，我们让 dp[i] 为 true ，否则令其为 \nfalse 。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode/\n来源：力扣（LeetCode）\n\n\n\nc++代码如下\n\n``` c++ \nclass Solution {\nprivate:\n    bool contain(string s, vector<string> v){\n        for(string ss: v){\n            if(ss == s){\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        bool dp[s.size()+1];\n        dp[0] = true;\n        for(int i=1; i<=s.size(); i++){\n            for(int j=0; j<i; j++){\n                dp[i] = false;\n                if(dp[j] && contain(s.substr(j, i-j), wordDict)){\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.size()];\n    }\n};\n```\n\n","tags":["刷题","动态规划"],"categories":["leetcode"]},{"title":"三角形最小路径和","url":"/2019/09/05/三角形最小路径和/","content":"\n# 题目\n\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n\n例如，给定三角形：\n\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/triangle\n\n# 思路\n\n注意两点：\n\n1. 不能从上往下的贪婪，而是要从下往上的贪婪\n2. 从下而上的贪婪可以保证当前位置到最低点的路径和是最大的。自然到了最高点，就可以求出最大值\n\n这是因为，基于当前的最优并不是全局最优，而从后往前则可以考虑全局\n\n\n\n用一位数组存储即可，边计算边保存，恰好不会被覆盖\n\n```\ndp[j] = min(dp[j], dp[j+1]) + triangle[i][j]\n```\n\n\n\n# 解法\n\n``` c++\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int dp[triangle.size()];\n        for(int k=0; k<triangle.size(); k++){\n            dp[k] = triangle[triangle.size()-1][k];\n        }\n        for(int i=triangle.size()-2; i>=0; i--){\n            for(int j=0; j<triangle[i].size(); j++){\n                dp[j] = min(dp[j], dp[j+1]) + triangle[i][j];\n            }\n        }\n        return dp[0];\n    }\n};\n```\n\n","tags":["刷题","动态规划"],"categories":["leetcode"]},{"title":"解码方法","url":"/2019/09/05/解码方法/","content":"\n# 题目\n\n一条包含字母 A-Z 的消息通过以下方式进行了编码：\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n给定一个只包含数字的非空字符串，请计算解码方法的总数。\n\n示例 1:\n\n输入: \"12\"\n输出: 2\n解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。\n示例 2:\n\n输入: \"226\"\n输出: 3\n解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/decode-ways\n\n# 思路\n\n这个和走楼梯的那题很像\n\n一段楼梯，一次可以走一个台阶，或者两个台阶，一共有多少种走法\n\n```\ndp[i] = dp[i-1] + dp[i-2]\n```\n\n这一题多了一个判断，即不是每个dp[i-1]和dp[i-2]都可以累加到dp[i]中，因为有可能有以下两种情况：\n\n1. 对于两个字符的情况\n\n   超过26的不行\n\n   04这种0开头的不行\n\n2. 对于一个字符的情况\n\n   0不行\n\n因此可以容易写出解\n\n\n\n# 解法\n\n``` c++\nclass Solution {\nprivate:\n    bool judge(string s){\n        return stoi(s)>0 && stoi(s)<27 && s[0] != '0';\n    }\npublic:\n    int dp[10000];\n    int numDecodings(string s) {\n        if(s.size()==1) return judge(s);\n        dp[0] = judge(s.substr(0, 1));\n        dp[1] = judge(s.substr(0, 2)) + (judge(s.substr(1, 1)) && judge(s.substr(0, 1)));\n        for(int i=2; i<s.size(); i++){\n            if(judge(s.substr(i, 1)) && s[i]!='0') dp[i] += dp[i-1];\n            if(judge(s.substr(i-1, 2))) dp[i] += dp[i-2];\n        }\n        return dp[s.size()-1];\n    }\n};\n```\n\n\n\n简化的写法来自网上：\n\n``` python\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        pp, p = 1, int(s[0] != '0')\n        for i in range(1, len(s)):\n            pp, p = p, pp * (9 < int(s[i-1:i+1]) <= 26) + p * (int(s[i]) > 0)\n        return p\n```\n\n\ni 从索引 1 开始逐渐遍历 s，当前位置对应结果 = 上上次结果(如果 i 位置字符和 i-1 位置字符的组合满足条件；即满足在9-27之间) + 上次结果(如果 s[i] 不为 0)\n\n作者：QQqun902025048\n链接：https://leetcode-cn.com/problems/decode-ways/solution/4-xing-python-dp-onshi-jian-o1kong-jian-by-qqqun90/\n来源：力扣（LeetCode）\n\n\n\n\n\n","tags":["刷题","动态规划"],"categories":["leetcode"]},{"title":"最小路径和","url":"/2019/09/05/最小路径和/","content":"\n# 题目\n\n给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n示例:\n\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-path-sum\n\n# 思路\n\n思路和https://leetcode-cn.com/problems/min-cost-climbing-stairs一致\n\n```c++\ndp[i][j] = min(dp[i-1][j], dp[i][j-1]) + arr[i][j]\n```\n\n # 解法\n\n``` c++\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int a = grid.size();\n        int b = grid[0].size();\n        int dp[a][b];\n        dp[0][0] = grid[0][0];\n        for(int i=0; i<a; i++){\n            for(int j=0; j<b; j++){\n                if(i>0 && j>0) dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n                else if(j>0) dp[i][j] = dp[i][j-1] + grid[i][j];\n                else if(i>0) dp[i][j] = dp[i-1][j] + grid[i][j];\n            }\n        }\n        return dp[a-1][b-1];\n    }\n};\n```\n\n还可以用一维数组优化一下，只需要用到上面一行和前一个位置即可","tags":["刷题","动态规划"],"categories":["leetcode"]},{"title":"最长回文子串","url":"/2019/09/04/最长回文子串/","content":"\n# 题目\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n示例 1：\n\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n示例 2：\n\n输入: \"cbbd\"\n输出: \"bb\"\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring\n\n# 思路\n\n首先能想到的一个思路是获得所有子串，判断是否是回文，再取最长的\n\n稍微优化一下就是，遍历每一个字符，作为中心点，向两边扩展，这样可以直接判断是否是回文，然后长度也可以直接求出\n\n注意这里中心点可以是一个，例如aba；也可以是两个，例如abba\n\n\n\n# 解法\n\n这里因为两种情况的扩展是相似的，所以可以抽象成一个函数，不同的是传入的参数来控制中心点是一个还是两个\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/\n来源：力扣（LeetCode）\n\n``` java\npublic String longestPalindrome(String s) {\n    if (s == null || s.length() < 1) return \"\";\n    int start = 0, end = 0;\n    for (int i = 0; i < s.length(); i++) {\n        int len1 = expandAroundCenter(s, i, i);\n        int len2 = expandAroundCenter(s, i, i + 1);\n        int len = Math.max(len1, len2);\n        if (len > end - start) {\n            start = i - (len - 1) / 2;\n            end = i + len / 2;\n        }\n    }\n    return s.substring(start, end + 1);\n}\n\nprivate int expandAroundCenter(String s, int left, int right) {\n    int L = left, R = right;\n    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {\n        L--;\n        R++;\n    }\n    return R - L - 1;\n}\n```\n\n\n\n评论下面还有两个方法可以优化\n\n1. 字符中间插入特殊字符，来同一个两种中心点\n\n2. 马拉车算法\n\n   https://segmentfault.com/a/1190000008484167","tags":["刷题","动态规划"],"categories":["leetcode"]},{"title":"最大正方形","url":"/2019/09/04/最大正方形/","content":"\n# 题目\n\n在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。\n\n示例:\n\n输入: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\n输出: 4\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximal-square\n\n# 思路\n\n只想到一个暴力的思路就是先对每行遍历，找到连续的1就开始向每一列搜索，看看是否组成正方形，如果确实组成正方形，就更新最大边长\n\n\n\n# 解法\n\n参考leetcode官方题解：\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode/\n来源：力扣（LeetCode）\n\n![image](https://s2.ax1x.com/2019/09/04/nZ53Of.png)\n\n对照着写的代码：\n\n``` c++\nclass Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if(matrix.size()==0) return 0;\n        int max = 0;\n        int dp[matrix.size()][matrix[0].size()];\n        for(int i=0; i<matrix.size(); i++){\n            for(int j=0; j<matrix[0].size(); j++){\n                if(i>0 && j>0 && matrix[i][j]=='1'){\n                    dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1;\n                    max = dp[i][j]>max?dp[i][j]:max;\n                } else if(matrix[i][j]=='1') {\n                    dp[i][j] = 1;\n                    max = dp[i][j]>max?dp[i][j]:max;\n                }\n                else dp[i][j] = 0;\n            }\n        }\n        return max*max;\n    }\n};\n```\n\n","tags":["刷题","动态规划"],"categories":["leetcode"]},{"title":"使用最小花费爬楼梯","url":"/2019/09/04/使用最小花费爬楼梯/","content":"\n# 题目\n\n数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。\n\n每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。\n\n您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。\n\n示例 1:\n\n输入: cost = [10, 15, 20]\n输出: 15\n解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。\n 示例 2:\n\n输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n输出: 6\n解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。\n注意：\n\ncost 的长度将会在 [2, 1000]。\n每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs\n\n# 思路\n\n如果便利所有情况的话显然过于复杂，具体的情况数应该是斐波那契数列的某一项，复杂度太高。\n\n如果考虑用贪婪的话也不太对，因为存在一种情况是首选一个花费较大的，但是之后可能存在一个花费更小的，例如 [0, 1, 2, 2]，如果是贪婪的话选择0-1-2，但是最小的花费应该是0-2\n\n用贪婪的问题是，这实际上是一个累加的问题，不是基于当前情况就能判断的问题，必须要是前面所有的积累\n\n故而就想到遍历所有情况，因为若是不知道之后的情况，似乎也是没法确定是否选择当前的走法\n\n这时候就要转化一下思路，想一想dp的解法\n\ndp的解法是：\n\ndp[i] = min(dp[i-1],dp[i-2]) + cost[i] （第0和第1个位置是dp的初始值）\n\n即要走到第i个台阶，考虑它之前的两个台阶，取小的那个加上当前台阶的花费即可。这样当我们求出最后两个台阶的dp时，就可以取小的那个，然后走完全部台阶\n\n\n\n# 解法\n\n按照上面的想法翻译一下代码即可，需要注意的是最后还要判断一下dp的最后两个位置，取小的值作为结果返回\n\n``` c++\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        // dp[i] = min(dp[i-1],dp[i-2]) + cost[i]\n        int a = cost[0], b = cost[1];\n        int c = 0;\n        for(int i=2; i<cost.size(); i++){\n            c = a>b?b:a;\n            c += cost[i];\n            a = b;\n            b = c;\n        }\n        return a>c?c:a;\n    }\n};\n```\n\n\n\n# 总结\n\n写出状态转移方程就会清晰很多","tags":["刷题","动态规划"],"categories":["leetcode"]},{"title":"判断子序列","url":"/2019/09/03/判断子序列/","content":"\n# 题目\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。\n\n示例 1:\ns = \"abc\", t = \"ahbgdc\"\n\n返回 true.\n\n示例 2:\ns = \"axc\", t = \"ahbgdc\"\n\n返回 false.\n\n后续挑战 :\n\n如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/is-subsequence\n\n# 思路\n\n原题没什么好说的，直接一个循坏找出来就行了\n\n``` c++\nclass Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        int i=0;\n        if(s.size()==0) return true;\n        bool flag = false;\n        for(char c: t){\n            if(c==s[i]){\n                i++;\n            }\n            if(i==s.size()){\n                flag = true;\n                break;\n            }\n        }\n        return flag;\n    }\n};\n```\n\n扩展部分没什么好的思路，就直接看题解了\n\n\n\n# 题解\n\n作者：zzzzzz-5\n链接：https://leetcode-cn.com/problems/is-subsequence/solution/cpan-duan-zi-xu-lie-hou-xu-tiao-zhan-by-zzzzzz-5/\n\n后续挑战，输入量大，小写字母创建25的二维数组，存储t的坐标，这样就可以把s的判断直接转为坐标的判断，\ndp[0]代表了存储了a出现在t的所有的位置,逐个字符判断s的字符顺序是否在t内，直接返回结果。\n时间复杂度O(t.size()+2000)：分别为创建数组需要O(t.size()),\n索引是递增的使用二分查找s的单个字符20次之内就可找到需要O(100*20)。\n适用大量的输入判断子序列。\n\n``` c++\nbool isSubsequence(string s, string t) {      \n  vector<vector<int>>dp(26);\n  int tag=-1;\n  for(int i=0;i<t.size();i++)\n    dp[t[i]-'a'].push_back(i);\n  for(int i=0;i<s.size();i++){\n    int now=s[i]-'a';\n    int left=0,right=dp[now].size()-1;            \n    if(right<0) return false;\n    while(left<right){\n      int mid=(left+right)/2;\n      if(dp[now][mid]>tag)\n        right=mid;\n      else\n        left=mid+1;\n    }\n    if(right<left || dp[now][left]<tag)return false;\n    tag=dp[now][left];\n  }\n  return true;\n}\n```\n\n不需要存储所有的字串，而是存下长字符串的坐标，然后对每个短的字串再判断\n对于每个短的串，一个小循环：对每个字符，先找到比前一个字符的坐标（tag）大的最小坐标（更新为下一个tag）；第一个字符只要初始化tag=-1即可找到第一个字符的最小坐标\n用二分查找，right对应的数设置为比mid大的数，这样如果存在比tag大的数，left最终会等于right，且那个位置一定是要找的那个数；如果不存在，那么最后left和right都会等于原来的right，最后判断一下dp[now][left]和tag的大小即可\n注意二分查找退出的时候，其实是不会出现right<left的情况的，只有可能是找到那个数或者dp[now][left]<tag，这时候即找不到比前一个tag大的位置，故而返回false","tags":["刷题","动态规划"],"categories":["leetcode"]},{"title":"Emacs Org-mode 笔记","url":"/2019/08/12/emacs笔记/","content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">\n<head>\n<!-- 2019-08-12 Mon 11:24 -->\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Emacs Org-mode 笔记</title>\n<meta name=\"generator\" content=\"Org mode\" />\n<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/\n  .title  { text-align: center;\n             margin-bottom: .2em; }\n  .subtitle { text-align: center;\n              font-size: medium;\n              font-weight: bold;\n              margin-top:0; }\n  .todo   { font-family: monospace; color: red; }\n  .done   { font-family: monospace; color: green; }\n  .priority { font-family: monospace; color: orange; }\n  .tag    { background-color: #eee; font-family: monospace;\n            padding: 2px; font-size: 80%; font-weight: normal; }\n  .timestamp { color: #bebebe; }\n  .timestamp-kwd { color: #5f9ea0; }\n  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }\n  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }\n  .org-center { margin-left: auto; margin-right: auto; text-align: center; }\n  .underline { text-decoration: underline; }\n  #postamble p, #preamble p { font-size: 90%; margin: .2em; }\n  p.verse { margin-left: 3%; }\n  pre {\n    border: 1px solid #ccc;\n    box-shadow: 3px 3px 3px #eee;\n    padding: 8pt;\n    font-family: monospace;\n    overflow: auto;\n    margin: 1.2em;\n  }\n  pre.src {\n    position: relative;\n    overflow: visible;\n    padding-top: 1.2em;\n  }\n  pre.src:before {\n    display: none;\n    position: absolute;\n    background-color: white;\n    top: -10px;\n    right: 10px;\n    padding: 3px;\n    border: 1px solid black;\n  }\n  pre.src:hover:before { display: inline;}\n  /* Languages per Org manual */\n  pre.src-asymptote:before { content: 'Asymptote'; }\n  pre.src-awk:before { content: 'Awk'; }\n  pre.src-C:before { content: 'C'; }\n  /* pre.src-C++ doesn't work in CSS */\n  pre.src-clojure:before { content: 'Clojure'; }\n  pre.src-css:before { content: 'CSS'; }\n  pre.src-D:before { content: 'D'; }\n  pre.src-ditaa:before { content: 'ditaa'; }\n  pre.src-dot:before { content: 'Graphviz'; }\n  pre.src-calc:before { content: 'Emacs Calc'; }\n  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }\n  pre.src-fortran:before { content: 'Fortran'; }\n  pre.src-gnuplot:before { content: 'gnuplot'; }\n  pre.src-haskell:before { content: 'Haskell'; }\n  pre.src-hledger:before { content: 'hledger'; }\n  pre.src-java:before { content: 'Java'; }\n  pre.src-js:before { content: 'Javascript'; }\n  pre.src-latex:before { content: 'LaTeX'; }\n  pre.src-ledger:before { content: 'Ledger'; }\n  pre.src-lisp:before { content: 'Lisp'; }\n  pre.src-lilypond:before { content: 'Lilypond'; }\n  pre.src-lua:before { content: 'Lua'; }\n  pre.src-matlab:before { content: 'MATLAB'; }\n  pre.src-mscgen:before { content: 'Mscgen'; }\n  pre.src-ocaml:before { content: 'Objective Caml'; }\n  pre.src-octave:before { content: 'Octave'; }\n  pre.src-org:before { content: 'Org mode'; }\n  pre.src-oz:before { content: 'OZ'; }\n  pre.src-plantuml:before { content: 'Plantuml'; }\n  pre.src-processing:before { content: 'Processing.js'; }\n  pre.src-python:before { content: 'Python'; }\n  pre.src-R:before { content: 'R'; }\n  pre.src-ruby:before { content: 'Ruby'; }\n  pre.src-sass:before { content: 'Sass'; }\n  pre.src-scheme:before { content: 'Scheme'; }\n  pre.src-screen:before { content: 'Gnu Screen'; }\n  pre.src-sed:before { content: 'Sed'; }\n  pre.src-sh:before { content: 'shell'; }\n  pre.src-sql:before { content: 'SQL'; }\n  pre.src-sqlite:before { content: 'SQLite'; }\n  /* additional languages in org.el's org-babel-load-languages alist */\n  pre.src-forth:before { content: 'Forth'; }\n  pre.src-io:before { content: 'IO'; }\n  pre.src-J:before { content: 'J'; }\n  pre.src-makefile:before { content: 'Makefile'; }\n  pre.src-maxima:before { content: 'Maxima'; }\n  pre.src-perl:before { content: 'Perl'; }\n  pre.src-picolisp:before { content: 'Pico Lisp'; }\n  pre.src-scala:before { content: 'Scala'; }\n  pre.src-shell:before { content: 'Shell Script'; }\n  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }\n  /* additional language identifiers per \"defun org-babel-execute\"\n       in ob-*.el */\n  pre.src-cpp:before  { content: 'C++'; }\n  pre.src-abc:before  { content: 'ABC'; }\n  pre.src-coq:before  { content: 'Coq'; }\n  pre.src-groovy:before  { content: 'Groovy'; }\n  /* additional language identifiers from org-babel-shell-names in\n     ob-shell.el: ob-shell is the only babel language using a lambda to put\n     the execution function name together. */\n  pre.src-bash:before  { content: 'bash'; }\n  pre.src-csh:before  { content: 'csh'; }\n  pre.src-ash:before  { content: 'ash'; }\n  pre.src-dash:before  { content: 'dash'; }\n  pre.src-ksh:before  { content: 'ksh'; }\n  pre.src-mksh:before  { content: 'mksh'; }\n  pre.src-posh:before  { content: 'posh'; }\n  /* Additional Emacs modes also supported by the LaTeX listings package */\n  pre.src-ada:before { content: 'Ada'; }\n  pre.src-asm:before { content: 'Assembler'; }\n  pre.src-caml:before { content: 'Caml'; }\n  pre.src-delphi:before { content: 'Delphi'; }\n  pre.src-html:before { content: 'HTML'; }\n  pre.src-idl:before { content: 'IDL'; }\n  pre.src-mercury:before { content: 'Mercury'; }\n  pre.src-metapost:before { content: 'MetaPost'; }\n  pre.src-modula-2:before { content: 'Modula-2'; }\n  pre.src-pascal:before { content: 'Pascal'; }\n  pre.src-ps:before { content: 'PostScript'; }\n  pre.src-prolog:before { content: 'Prolog'; }\n  pre.src-simula:before { content: 'Simula'; }\n  pre.src-tcl:before { content: 'tcl'; }\n  pre.src-tex:before { content: 'TeX'; }\n  pre.src-plain-tex:before { content: 'Plain TeX'; }\n  pre.src-verilog:before { content: 'Verilog'; }\n  pre.src-vhdl:before { content: 'VHDL'; }\n  pre.src-xml:before { content: 'XML'; }\n  pre.src-nxml:before { content: 'XML'; }\n  /* add a generic configuration mode; LaTeX export needs an additional\n     (add-to-list 'org-latex-listings-langs '(conf \" \")) in .emacs */\n  pre.src-conf:before { content: 'Configuration File'; }\n\n  table { border-collapse:collapse; }\n  caption.t-above { caption-side: top; }\n  caption.t-bottom { caption-side: bottom; }\n  td, th { vertical-align:top;  }\n  th.org-right  { text-align: center;  }\n  th.org-left   { text-align: center;   }\n  th.org-center { text-align: center; }\n  td.org-right  { text-align: right;  }\n  td.org-left   { text-align: left;   }\n  td.org-center { text-align: center; }\n  dt { font-weight: bold; }\n  .footpara { display: inline; }\n  .footdef  { margin-bottom: 1em; }\n  .figure { padding: 1em; }\n  .figure p { text-align: center; }\n  .equation-container {\n    display: table;\n    text-align: center;\n    width: 100%;\n  }\n  .equation {\n    vertical-align: middle;\n  }\n  .equation-label {\n    display: table-cell;\n    text-align: right;\n    vertical-align: middle;\n  }\n  .inlinetask {\n    padding: 10px;\n    border: 2px solid gray;\n    margin: 10px;\n    background: #ffffcc;\n  }\n  #org-div-home-and-up\n   { text-align: right; font-size: 70%; white-space: nowrap; }\n  textarea { overflow-x: auto; }\n  .linenr { font-size: smaller }\n  .code-highlighted { background-color: #ffff00; }\n  .org-info-js_info-navigation { border-style: none; }\n  #org-info-js_console-label\n    { font-size: 10px; font-weight: bold; white-space: nowrap; }\n  .org-info-js_search-highlight\n    { background-color: #ffff00; color: #000000; font-weight: bold; }\n  .org-svg { width: 90%; }\n\n</style>\n<script type=\"text/javascript\">\n\nfunction CodeHighlightOn(elem, id)\n {\n   var target = document.getElementById(id);\n   if(null != target) {\n     elem.cacheClassElem = elem.className;\n     elem.cacheClassTarget = target.className;\n     target.className = \"code-highlighted\";\n     elem.className   = \"code-highlighted\";\n   }\n }\n function CodeHighlightOff(elem, id)\n {\n   var target = document.getElementById(id);\n   if(elem.cacheClassElem)\n     elem.className = elem.cacheClassElem;\n   if(elem.cacheClassTarget)\n     target.className = elem.cacheClassTarget;\n }\n\n</script>\n</head>\n<body>\n<div id=\"content\">\n<div id=\"table-of-contents\">\n<h2>Table of Contents</h2>\n<div id=\"text-table-of-contents\">\n<ul>\n<li><a href=\"#org6a7ea47\">1. Emacs 笔记</a>\n<ul>\n<li><a href=\"#orga44e949\">1.1. core 核心键位</a></li>\n<li><a href=\"#org7566de2\">1.2. buffer管理</a></li>\n<li><a href=\"#org6da97c2\">1.3. 在org大纲中移动 创建org大纲</a></li>\n<li><a href=\"#orgcd62c20\">1.4. style 样式</a>\n<ul>\n<li><a href=\"#orgf13ff98\">1.4.1. 各种格式</a></li>\n<li><a href=\"#orgdec8264\">1.4.2. ordered-list unordered-list description  各种列表（有序/无序/描述）</a></li>\n<li><a href=\"#orgcf79d1c\">1.4.3. checkbox 检查点</a></li>\n<li><a href=\"#org600f97f\">1.4.4. link 链接</a></li>\n<li><a href=\"#org96b580a\">1.4.5. 换行</a></li>\n</ul>\n</li>\n<li><a href=\"#org095b1fb\">1.5. codes 代码块和其他block</a>\n<ul>\n<li><a href=\"#orgfd6dd0f\">1.5.1. 普通代码块</a></li>\n</ul>\n</li>\n<li><a href=\"#orgac957b1\">1.6. table 表格</a>\n<ul>\n<li><a href=\"#org816a0e3\">1.6.1. 创建表格</a></li>\n<li><a href=\"#org92b3d0b\">1.6.2. 增加行列</a></li>\n<li><a href=\"#orgd96d6de\">1.6.3. 删除行列</a></li>\n<li><a href=\"#orge654cbc\">1.6.4. 移动行列</a></li>\n</ul>\n</li>\n<li><a href=\"#org28d2028\">1.7. calendar 日历</a>\n<ul>\n<li><a href=\"#org40cc6f0\">1.7.1. 进入日历</a></li>\n<li><a href=\"#org2a3d4f5\">1.7.2. 基本操作</a></li>\n<li><a href=\"#org92c4454\">1.7.3. 日记</a></li>\n</ul>\n</li>\n<li><a href=\"#orgbd7c803\">1.8. windows 窗口调整</a>\n<ul>\n<li><a href=\"#orgd99906b\">1.8.1. 新建窗口</a></li>\n<li><a href=\"#org0a8668e\">1.8.2. 移动窗口</a></li>\n<li><a href=\"#org0ceed61\">1.8.3. 调整窗口大小</a></li>\n<li><a href=\"#org44a1444\">1.8.4. 调整窗口位置</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-org6a7ea47\" class=\"outline-2\">\n<h2 id=\"org6a7ea47\"><span class=\"section-number-2\">1</span> Emacs 笔记</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\n修订历史\n</p>\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col  class=\"org-right\" />\n\n<col  class=\"org-left\" />\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"org-right\">时间</th>\n<th scope=\"col\" class=\"org-left\">内容                               ;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"org-right\">2019-07-15</td>\n<td class=\"org-left\">init，增加了一些基本样式和移动的说明</td>\n</tr>\n</tbody>\n<tbody>\n<tr>\n<td class=\"org-right\">2019-07-16</td>\n<td class=\"org-left\">增加了对日历使用说明</td>\n</tr>\n</tbody>\n</table>\n</div>\n\n\n<div id=\"outline-container-orga44e949\" class=\"outline-3\">\n<h3 id=\"orga44e949\"><span class=\"section-number-3\">1.1</span> core 核心键位</h3>\n<div class=\"outline-text-3\" id=\"text-1-1\">\n<ul class=\"org-ul\">\n<li><code>M-m</code> unlock the infinite power !!!</li>\n<li><code>C-x</code> some useful shortcuts !!!</li>\n<li><code>M-x</code> all functions and packages !!!</li>\n<li><code>M-x h d f</code> help to describe a function !!!</li>\n\n<li><code>C-f</code> 删除当前的命令（打错命令可以用这个来删除重新敲）</li>\n<li><code>C-c</code> org模式下面的prefix快捷键，可以查看常用的操作</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org7566de2\" class=\"outline-3\">\n<h3 id=\"org7566de2\"><span class=\"section-number-3\">1.2</span> buffer管理</h3>\n<div class=\"outline-text-3\" id=\"text-1-2\">\n<p>\n基本上有两种途径可以实现\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-org6da97c2\" class=\"outline-3\">\n<h3 id=\"org6da97c2\"><span class=\"section-number-3\">1.3</span> 在org大纲中移动 创建org大纲</h3>\n<div class=\"outline-text-3\" id=\"text-1-3\">\n<ul class=\"org-ul\">\n<li><code>C-c C-n</code> 移动到下一个标题</li>\n<li><code>C-c C-p</code> 移动到上一个标题</li>\n\n<li><code>M-RET</code> 新建标题\n<code>注意</code> 如果是在： \n<b>之前</b> 那么会在之前新建\n<b>之中</b> 那么会切分成两半\n<b>之后</b> 那么会在之后新建</li>\n<li><code>C-RET</code> 在下面新建标题（跳过所有的子节点）</li>\n<li><code>M-up</code> 向上移动标题（同等级的移动）</li>\n<li><code>M-down</code> 向下移动标题（同等级的移动）</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orgcd62c20\" class=\"outline-3\">\n<h3 id=\"orgcd62c20\"><span class=\"section-number-3\">1.4</span> style 样式</h3>\n<div class=\"outline-text-3\" id=\"text-1-4\">\n</div>\n<div id=\"outline-container-orgf13ff98\" class=\"outline-4\">\n<h4 id=\"orgf13ff98\"><span class=\"section-number-4\">1.4.1</span> 各种格式</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-1\">\n<dl class=\"org-dl\">\n<dt>bold 粗体 </dt><dd><b>粗体</b></dd>\n<dt>Italy 斜体</dt><dd><i>斜体</i></dd>\n<dt>delete 删除线</dt><dd><del>delete</del></dd>\n<dt>underline 下划线</dt><dd><span class=\"underline\">下划线</span></dd>\n<dt>subscript 下标</dt><dd>H<sub>2</sub> O</dd>\n<dt>superscript 上标</dt><dd>E = mc<sup>2</sup></dd>\n<dt>monospace 等宽</dt><dd><code>git</code> 或者 <code>git</code> (btw, I love this color!!)</dd>\n</dl>\n</div>\n</div>\n\n<div id=\"outline-container-orgdec8264\" class=\"outline-4\">\n<h4 id=\"orgdec8264\"><span class=\"section-number-4\">1.4.2</span> ordered-list unordered-list description  各种列表（有序/无序/描述）</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-2\">\n<p>\n官网：<a href=\"https://orgmode.org/manual/Plain-lists.html\">https://orgmode.org/manual/Plain-lists.html</a>\n</p>\n<ol class=\"org-ol\">\n<li>有序列表\n直接标注 1. 或者 1) <code>注意</code> 要使用英文输入</li>\n<li>无序列表\n用 - + 或 *</li>\n<li>描述（类似于定义之类的）\n空格加上两冒号，例如：\nterm :: definition\n注意，如果此时是加载无序列表前面，还会自动加粗\n<ol class=\"org-ol\">\n<li>无序列表 :: definition</li>\n<li>无序列表 :: definition</li>\n<li>无序列表 :: definition</li>\n</ol></li>\n</ol>\n<p>\n<code>注意，所有层级关系都可以用以下快捷键</code>\n</p>\n<ul class=\"org-ul\">\n<li><code>M-RET</code> 来插入一个新行（可以自动增加序号）</li>\n\n<li><code>M-up</code> 向上移动标题（同等级的移动）</li>\n<li><code>M-down</code> 向下移动标题（同等级的移动）</li>\n\n<li><code>M-left</code> 不带子节点，让当前标示升级 <b>标题或者列表</b> 列表可以是无序列表，下同</li>\n<li><code>M-right</code> 不带子节点，让当前标示降级 <b>标题或者列表</b></li>\n<li><code>M-S-left</code>  带子节点，让当前标示升级 <b>标题或者列表</b></li>\n<li><code>M-S-right</code> 带子节点，让当前标示升级 <b>标题或者列表</b></li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orgcf79d1c\" class=\"outline-4\">\n<h4 id=\"orgcf79d1c\"><span class=\"section-number-4\">1.4.3</span> checkbox 检查点</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-3\">\n<ul class=\"org-ul\">\n<li><code>M-S-RET</code> 创建一个检查点（仅限于org模式）\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> 待办事项</li>\n</ul></li>\n<li><code>C-c C-c</code> 改变box的状态\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> 未完成</li>\n<li class=\"on\"><code>[X]</code> 已完成</li>\n</ul></li>\n<li><code>S-right</code> 用在标题上: 加上 TODO 或者 DONE 字样;\n用在列表上：改变列表样式（无序改为有序等）</li>\n<li><code>S-right</code> 同上</li>\n\n<li><code>[/]</code> 用来标记完成情况\n使用方法：先写成上面这样，然后创建检查点 <code>M-S-RET</code> ，然后用 <code>M-right</code> 或 <code>M-left</code>  缩进即可\n任务进度<code>[0/3]</code>\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n\n<li>[ ]<code>[0/2]</code>\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n</ul></li>\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n</ul></li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org600f97f\" class=\"outline-4\">\n<h4 id=\"org600f97f\"><span class=\"section-number-4\">1.4.4</span> link 链接</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-4\">\n<p>\n官网：<a href=\"https://orgmode.org/manual/Internal-links.html\">https://orgmode.org/manual/Internal-links.html</a>\n</p>\n\n\n<p>\n[[月亮宝石[英]威尔基·柯林斯.徐汝椿等译.上海译文出版社(1980).pdf][d]]\ncontrol x\ncontrol f\ncontrol b\n窗口调整\n全屏\n安装layers\n查看所有layers\noption m\noption x \n</p>\n</div>\n</div>\n\n<div id=\"outline-container-org96b580a\" class=\"outline-4\">\n<h4 id=\"org96b580a\"><span class=\"section-number-4\">1.4.5</span> 换行</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-5\">\n<ul class=\"org-ul\">\n<li><code>M-m t l</code> 自动换行 toggle - truncate line</li>\n</ul>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-org095b1fb\" class=\"outline-3\">\n<h3 id=\"org095b1fb\"><span class=\"section-number-3\">1.5</span> codes 代码块和其他block</h3>\n<div class=\"outline-text-3\" id=\"text-1-5\">\n</div>\n<div id=\"outline-container-orgfd6dd0f\" class=\"outline-4\">\n<h4 id=\"orgfd6dd0f\"><span class=\"section-number-4\">1.5.1</span> 普通代码块</h4>\n<div class=\"outline-text-4\" id=\"text-1-5-1\">\n<p>\n例如c：\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-c\">int add(int a, int b){\n    return a + b;\n}\n</pre>\n</div>\n\n<p>\n例如java：\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">public static int add(int a, int b){\n    System.out.println()\n    return a + b;\n}\n</pre>\n</div>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-orgac957b1\" class=\"outline-3\">\n<h3 id=\"orgac957b1\"><span class=\"section-number-3\">1.6</span> table 表格</h3>\n<div class=\"outline-text-3\" id=\"text-1-6\">\n<p>\n<code>表格对中文支持很差，不建议在表格中使用中文</code>\n</p>\n</div>\n<div id=\"outline-container-org816a0e3\" class=\"outline-4\">\n<h4 id=\"org816a0e3\"><span class=\"section-number-4\">1.6.1</span> 创建表格</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-1\">\n<p>\norg模式下\n</p>\n<ul class=\"org-ul\">\n<li><code>| | |</code> 然后 <code>tab</code> ，可以新建对齐的列</li>\n</ul>\n<p>\n在第一步的基础上，可以用\n</p>\n<ul class=\"org-ul\">\n<li><code>|-</code> 然后 <code>tab</code> ，可以新建带横线的边框</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org92b3d0b\" class=\"outline-4\">\n<h4 id=\"org92b3d0b\"><span class=\"section-number-4\">1.6.2</span> 增加行列</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-2\">\n<ul class=\"org-ul\">\n<li><code>|-</code> 然后 <code>tab</code> 可以新建带横线的边框（新增一行）</li>\n<li><code>|</code> 然后 <code>tab</code> 可以新建一列</li>\n\n<li><code>M-S right</code> 新建一列</li>\n<li><code>M-S down</code> 新建一行</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orgd96d6de\" class=\"outline-4\">\n<h4 id=\"orgd96d6de\"><span class=\"section-number-4\">1.6.3</span> 删除行列</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-3\">\n<ul class=\"org-ul\">\n<li><code>M-S left</code> 删除一列</li>\n<li><code>M-S up</code> 删除一行</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orge654cbc\" class=\"outline-4\">\n<h4 id=\"orge654cbc\"><span class=\"section-number-4\">1.6.4</span> 移动行列</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-4\">\n<ul class=\"org-ul\">\n<li><code>M-left</code> 向左移动</li>\n<li><code>M-right</code> 向右移动</li>\n<li><code>M-up</code> 向上移动</li>\n<li><code>M-down</code> 向下移动</li>\n</ul>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-org28d2028\" class=\"outline-3\">\n<h3 id=\"org28d2028\"><span class=\"section-number-3\">1.7</span> calendar 日历</h3>\n<div class=\"outline-text-3\" id=\"text-1-7\">\n</div>\n<div id=\"outline-container-org40cc6f0\" class=\"outline-4\">\n<h4 id=\"org40cc6f0\"><span class=\"section-number-4\">1.7.1</span> 进入日历</h4>\n<div class=\"outline-text-4\" id=\"text-1-7-1\">\n<p>\n好多种方法可以打开日历\n</p>\n<ul class=\"org-ul\">\n<li><code>C-c &gt;</code> 直接进入</li>\n<li><code>M-x calendar</code> 搜索进入</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org2a3d4f5\" class=\"outline-4\">\n<h4 id=\"org2a3d4f5\"><span class=\"section-number-4\">1.7.2</span> 基本操作</h4>\n<div class=\"outline-text-4\" id=\"text-1-7-2\">\n<p>\n进入之后下面就有说明\n</p>\n<ul class=\"org-ul\">\n<li><code>?</code> 查看帮助手册</li>\n<li><code>.</code> 定位到当前日期</li>\n<li><code>o</code> 快速定位到其他日期</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org92c4454\" class=\"outline-4\">\n<h4 id=\"org92c4454\"><span class=\"section-number-4\">1.7.3</span> 日记</h4>\n<div class=\"outline-text-4\" id=\"text-1-7-3\">\n<p>\n<code>基本操作</code>\n</p>\n<ol class=\"org-ol\">\n<li>日记需要遵循一定的格式</li>\n<li>支持鼠标操作（右键日期）</li>\n</ol>\n\n<p>\n<code>查看操作</code>\n通过日历查看\n<code>M-x calendar</code> 进入日历\n</p>\n<ol class=\"org-ol\">\n<li><code>d</code> display 查看日记（不能编辑）</li>\n<li><code>s</code> 直接进入日记文件（可以编辑）</li>\n<li><code>m</code> mark所有有日记的日期</li>\n<li><code>u</code> unmark之前的标记</li>\n</ol>\n\n<p>\n直接查看diary\n</p>\n<ol class=\"org-ol\">\n<li><code>M-x diary</code> 直接查看diary</li>\n</ol>\n\n\n<p>\n<code>新建操作</code>\n</p>\n<ol class=\"org-ol\">\n<li><code>i d</code> 在选择的日期上添加一个日记入口（精确到日）</li>\n<li><code>i w</code> 在选择的星期上添加一个日记入口（精确到周）</li>\n<li><code>i m</code> 在选择的月份上添加一个日记入口（精确到月）</li>\n<li><code>i y</code> 在选择的年份上添加一个日记入口（精确到年）</li>\n<li><code>i u</code> 创建一个在指定日期之后的每年的纪念日（例如节日，生日等等）\n<code>注意是在指定日期之后</code></li>\n<li><code>i b</code> 创建一个指定范围内所有日期的日记入口（范围时间）</li>\n<li><code>i c</code> 创建循环的日记入口</li>\n</ol>\n\n<p>\n<code>消息通知</code>\n</p>\n<ol class=\"org-ol\">\n<li></li>\n\n<li></li>\n</ol>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-orgbd7c803\" class=\"outline-3\">\n<h3 id=\"orgbd7c803\"><span class=\"section-number-3\">1.8</span> windows 窗口调整</h3>\n<div class=\"outline-text-3\" id=\"text-1-8\">\n</div>\n<div id=\"outline-container-orgd99906b\" class=\"outline-4\">\n<h4 id=\"orgd99906b\"><span class=\"section-number-4\">1.8.1</span> 新建窗口</h4>\n</div>\n<div id=\"outline-container-org0a8668e\" class=\"outline-4\">\n<h4 id=\"org0a8668e\"><span class=\"section-number-4\">1.8.2</span> 移动窗口</h4>\n</div>\n<div id=\"outline-container-org0ceed61\" class=\"outline-4\">\n<h4 id=\"org0ceed61\"><span class=\"section-number-4\">1.8.3</span> 调整窗口大小</h4>\n</div>\n<div id=\"outline-container-org44a1444\" class=\"outline-4\">\n<h4 id=\"org44a1444\"><span class=\"section-number-4\">1.8.4</span> 调整窗口位置</h4>\n<div class=\"outline-text-4\" id=\"text-1-8-4\">\n<ul class=\"org-ul\">\n<li><code>M-x w .</code> 进入主控面板，可以做一切事情\n拥有对面板控制的最高权限\n包括调整窗口大小，位置，恢复，删除等</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div id=\"postamble\" class=\"status\">\n<p class=\"validation\"><a href=\"http://validator.w3.org/check?uri=referer\">Validate</a></p>\n</div>\n</body>\n</html>\n","tags":["Emacs","org-mode"],"categories":["Emacs"]},{"title":"建。。建站手册？🗝","url":"/2019/08/11/Hello-World/","content":"\n[TOC]\n\n# 修改历史\n\n| 时间      | 内容                       |\n| --------- | -------------------------- |\n| 2019-8-12 | 初稿                       |\n| 2019-8-29 | 完善图片显示和其他格式问题 |\n\n# 前言\n\n花了点时间捣鼓了个Hexo博客，顺便记录一下捣鼓过程，不想看过程的可以直接跳到[最后](#最后)\n\n**🕘 预计配置时间**： 3hours？Maybe fewer.\n\n**🖥 完成配之后将拥有：**\n\n1. 一个github仓库作为数据存储的静态博客\n\n2. 基本功能齐全，前端还算不错的个人博客，省得自己搭架子\n\n   ![blog](https://s2.ax1x.com/2019/08/29/mbAVyQ.png)\n\n3. 采用hexo博客框架，[Casper](https://github.com/xzhih/hexo-theme-casper)作为模板，自动渲染md，一键部署到github\n\n4. 模板自身支持发布文章，阅读文章，新建页面，分类，标签\n\n5. 自己添加了一些功能可以手动写md实现时间轴，增加了流量统计\n\n\n\n# 折腾过程实录\n\n**1. github page**\n\n​\t要部署到github的话，先搞一个github仓库，直接google一下[github page](https://www.google.com/search?q=github+page&oq=github+page&aqs=chrome..69i57j35i39j69i60l4.2108j0j4&sourceid=chrome&ie=UTF-8)咋整就行了，这一步注意仓库的名字有特殊的要求，不然后面会显示不出来东西。有手就行的东西就不展开了🙌\n\n**2. hexo**\n\n​\t同上，google一下[hexo](https://hexo.io/zh-cn/docs/)的安装过程，同有手就行🤞\n\n​\t这里可以稍微熟悉一下几个命令\n\n```shell\nhexo new post helloworld\nhexo clean  # 清空一下之前生成的文件，如果修改不生效可以试试这个命令，先清空一下\nhexo g      # generate，编译渲染\nhexo d      # deploy，自动部署\n```\n\n\n\n**3. hexo部署到github page上**\n\n​\tgoogle之[hexo整合github](https://hexo.io/zh-cn/docs/deployment)。。有手就行👀。。。\n\n​\t这里可以稍微注意一下，部署的分支和资源存储的分支是分开的，部署的分支github貌似要求是master，资源可以新建一个分支\n\n**4. pick一个主题**\n\n​\t这里我选了[Casper](https://github.com/xzhih/hexo-theme-casper)作为模板，另外有一个模板看起来也不错👉[icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/about/)。下面的内容都是根据我选择的Casper展开。\n\n​\t更换主题就是直接把Casper的github repo（具体地址在上面链接👆）clone到**themes**文件夹下。\n\n​\t稍微解释一下这些个文件夹都是干啥的，之后有用。\n\n```\n├── README.md\n├── _config.yml          # 配置文件，可以配置很多东西，之后会介绍\n├── languages            # 语言包，直接在配置文件里面设置zh-CN就是中文了\n│   ├── default.yml\n│   ├── fr.yml\n│   ├── nl.yml\n│   ├── no.yml\n│   ├── ru.yml\n│   ├── zh-CN.yml\n│   └── zh-TW.yml\n├── layout               # 布局文件，自定义一些布局基本都在这里修改\n│   ├── _layout.swig\n│   ├── _partials\n│   ├── archive.swig\n│   ├── category.swig\n│   ├── index.swig\n│   ├── page.swig\n│   ├── post.swig\n│   └── tag.swig\n├── scripts\n│   └── index.js\n└── source               # 源文件，配合布局一起修改\n    ├── css\n    ├── fonts\n    ├── img\n    └── js\n```\n\n**5. 配置主题**\n\n​\t这一步主要是修改**_config**这个文件，这里有俩config，一个是博客根目录的config，一个是**themes/hexo-casper**里的config，都可以配置，重点说一下主题里面的那个config\n\n![_config](https://s2.ax1x.com/2019/08/29/mbAtm9.png)\n\n参考我这个稍微配置一下就行了，另外[Casper](https://github.com/xzhih/hexo-theme-casper)里面写的很清楚了，照着改改就差不多了\n\n\n\n**6. 增加流量统计**\n\n​\t提了issue问怎么统计流量，回答说有个评论系统自带了流量统计功能，但是注册过程比较麻烦，就放弃了。这里采用[不蒜子](http://ibruce.info/2015/04/04/busuanzi/)，很是方便，而且速度很快，只要简单配置一下就可以了。\n\n配置之前先详细解释一下layout的结构：\n\n```shell\n├── _layout.swig            # 页面总体布局（修改基本没用到它）\n├── _partials               # 小组件，方便复用\n│   ├── about.swig            # 这个就是ABOUT界面上面的那些小东西，见下面图例\n│   ├── footer.swig           # 注脚，见下面图例\n│   ├── head.swig\n│   ├── header.swig\n│   ├── index.swig\n│   ├── javascript.swig\n│   ├── page.swig\n│   ├── post.swig\n│   ├── public\n│   │   ├── fload-header.swig\n│   │   ├── icons\n│   │   ├── json-ld.swig\n│   │   ├── nav.swig\n│   │   ├── social.swig\n│   │   └── toc.swig\n│   ├── search.swig\n│   ├── widget                # 这三个就是分类、tag和recent\n│   │   ├── category.swig\n│   │   ├── recent_posts.swig\n│   │   └── tagcloud.swig\n│   └── widget.swig\n├── archive.swig              # archive页面的布局\n├── category.swig\n├── index.swig\n├── page.swig\n├── post.swig\n└── tag.swig\n```\n\n_partials/about.swig:\n\n![about](https://s2.ax1x.com/2019/08/29/mbAUT1.png)\n\n_partials/foot.swig:\n\n![foot](https://s2.ax1x.com/2019/08/29/mbAdFx.png)\n\n**7. 将分类写到导航栏上面**\n\n```\nhexo new page xxx\n```\n\n这个命令可以新建一个导航页面，但是只是单独的一页文章。如果要把categories的每个分类放到导航栏上面，可以稍作修改。\n\n方法一：\n\n在**config**里面修改：\n\n```\nmenu:\n  ABOUT: /about\n  ARCHIVES: /archives\n  TEST: /categories/test/\n```\n\n这样手动可以把某个分类添加到导航栏上面。\n\n方法二：\n\n观察**layout/_partails/widget/categories**中的写法，发现只要添加一行代码就可以添加link到指定分类的链接。故只要在**layout/_partails/public/nav.swig**中修改如下：（绿色的注释）\n\n![nav](https://s2.ax1x.com/2019/08/29/mbVkrQ.png)\n\n**8. 给页面加上阴影**\n\n因为项目中将css全部整合到**allinonecss.min.css**中，因此要直接修改这个css文件，修改其他的css文件不生效！！！\n\n全局搜索\n\n```\n.post-full-content\n```\n\n添加css\n\n```\nbox-shadow:0px 16px 16px #E0E0E0;\nborder-radius: 8px;\n```\n\n即可添加shadow和圆角\n\n**8. 添加时间线**\n\n这个可以通过手写markdown来手动实现时间线\n\n首先在**scripts/index.js**最后添加如下代码：（来自<http://channingsun.bid/2016/05/10/20160510_%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Timeline/>）\n\n```js\n//timeline\nhexo.extend.tag.register('timeline', function(args, content){\n\tdate = args[0]\n\ttime = args[1]\n\tlogo = args[2]\n\tvar result = '';\n\tresult += '<blockquote>';\n\tlogo = '<span class=\"fa-stack fa-lg\"><i class=\"fa ' + logo + ' fa-stack-1x\"></i></span>';\n\tresult += hexo.render.renderSync({text: logo + content, engine: 'markdown'});\n\tfooter = '<span>' + date + ' ' + time + '</span>'\n\tresult += '<footer>' + footer + '</footer>';\n\tresult += '</blockquote>';\n\treturn result;\n}, {ends: true});\n```\n\n然后只要写\n\n```\n{% timeline 2015-01-23 18:38:26 fa-lg %} 第一篇博客 {% post_link hello-world hello-world %} {% endtimeline %}\n```\n\n即可跳转到对应的博客\n\n也可以适当调整一下js里面的内容，比如表情和time可以删掉\n\n# 最后\n\n最后就配置好了，嗯。想看配置过程的可以看[折腾过程实录](#%E6%8A%98%E8%85%BE%E8%BF%87%E7%A8%8B%E5%AE%9E%E5%BD%95)\n\n\n\n\n\n\n\n","tags":["Hello World"]},{"title":"hello-world","url":"/2019/08/10/hello-world/","content":"\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment]("}]