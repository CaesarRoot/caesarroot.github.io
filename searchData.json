[{"title":"ffmpeg常用功能精简使用指南","url":"/2020/04/30/ffmpeg常用功能精简使用指南/","content":"\nffmpeg命令是一个强大的流媒体处理命令。下面是几个常用的可以使用ffmpeg来解决的问题场景：\n\n1. 压缩文件大小\n2. 剪辑视频长度\n3. 下载网页视频\n\n\n\n## 安装\n\n直接看官网就行\n\nhttps://www.ffmpeg.org/download.html\n\nmacos下可以用brew安装\n\n```shell\nbrew install ffmpeg\n```\n\n\n\n## 压缩文件大小\n\nffmpeg本身支持多种压缩方法，包括码率和其他的格式等。这些命令一般比较复杂，其实有一个特别简单的方法：\n\n```shell\nffmpeg -i input.mp4 output.mp4\n```\n\n默认的ffmpeg命令就已经优化了视频的压缩算法，因此直接导入导出就可以明显缩减视频大小\n\n\n\n## 剪辑视频长度\n\n有时候只想简单的截取视频的某一部分，这时可能手边没有视频剪辑软件，或者是视频剪辑软件太重，对于这个轻量级的任务ffmpeg有更好的解法：\n\n```shell\nffmpeg -ss 00:01:00 -i input.mp4 -t 00:01:00 -c copy output.mp4\n```\n\n上面这个命令将input.mp4视频中1分钟-2分钟的部分剪辑出来，存放在output.mp4中\n\n`-ss`意思是一个偏移量，即从1分钟的地方开始\n\n`-i`意思是输入文件\n\n`-t`是要剪辑的视频长度，上面命令为一分钟\n\n`-c`表示不重新编码。这个参数应该是为了加速处理过程，应该不是特别重要\n\n\n\n## 下载网页视频\n\n在这个需求上ffmpeg真的是神器。\n\n现在网页播放的视频，基本没有网站会把完整的mp4的url放在response中，基本都会采用另外一些格式，例如m3u8格式，这种格式会有一个index文件，标识了视频的元信息，后续的视频通过分片的方式，每个分片都是一个小的ts文件，这些文件组合起来就是一个完整的视频。如果手动下载所有的ts再组合就太麻烦了，这里用ffmpeg就会变得非常简单。\n\n我们随便打开一个视频：http://www.dytt.com/vod-play-id-94467-src-1-num-7.html\n\n打开控制台，看network，搜索m3u8\n\n<img src=\"https://s1.ax1x.com/2020/04/30/JbEDEQ.png\" alt=\"JbEDEQ.png\" border=\"0\" />\n\n点开看请求头\n\n<img src=\"https://s1.ax1x.com/2020/04/30/JbEfDU.png\" alt=\"JbEfDU.png\" border=\"0\" />\n\n复制到命令行，如下\n\n```shell\nffmpeg -i https://us8.wl-cdn.com/hls/20200403/090990addb56baa30668886c0095679b/index.m3u8 output.mp4\n```\n\n就会开始自动下载了\n\n<img src=\"https://s1.ax1x.com/2020/04/30/JbEzUH.png\" alt=\"JbEzUH.png\" border=\"0\" />\n\n整个过程就是下载ts文件，然后拼起来\n\n<img src=\"https://s1.ax1x.com/2020/04/30/JbeggI.png\" alt=\"JbeggI.png\" border=\"0\" />\n\n\n\n## 在线播放视屏\n\n利用ffplay可以直接在线播放，而不用等到视屏下载完毕，支持多种格式，例如m3u8格式只要输入如下命令：\n\n```shell\nffplay -i https://youku.com-iqiyi.net/20180128/IVmdoB2k/index.m3u8\n```\n\n会弹出一个窗口直接播放，且支持快进、暂停等","categories":["linux"]},{"title":"flink源码阅读和解析笔记--任务执行","url":"/2020/03/15/flink源码阅读和解析笔记-任务执行/","content":"\n# Flink任务运行流程\n\n## StreamTask\n\n该类是所有流计算任务的基类，一个任务是部署在`TaskManager`上并且由它运行的一个本地处理单元。另外，有关checkpoint的实现也在这里。\n每一个任务运行着一个或多个`StreamOperator`，如下图所示\n\n![image](https://s1.ax1x.com/2020/03/15/83kiDK.png)\n\n这些`StreamOperator`会形成operator chain，形成条件包括上下游算子的并行度等。\n代码中将单个`StreamOperator`和它们所形成的chain统一表示，即统一采用`StreamTask`。对于chain来说，`StreamTask`包含了chain的\"head\"，此时`StreamTask`的类型就是这个\"head\" operator的类型。\n\n```java\npublic abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>\n\t\textends AbstractInvokable\n\t\timplements AsyncExceptionHandler {\n    ...\n\t/** the head operator that consumes the input streams of this task. */\n\tprotected OP headOperator;\n    ...\n}\n```\n\n一个chain里面的所有算子在同一个线程中同步执行，因此它们在同一个stream partition上。\n一个任务处理一个流的建立（由head operator读入），和流的产生（chain中最后一个operator的输出），注意一个chain可能有多个流出（end）。\n\n## 生命周期\n\n一个task的生命周期如下：\n\n```shell script\n *  -- setInitialState -> provides state of all operators in the chain\n *\n *  -- invoke()\n *        |\n *        +----> Create basic utils (config, etc) and load the chain of operators\n *        +----> operators.setup()\n *        +----> task specific init()\n *        +----> initialize-operator-states()\n *        +----> open-operators()\n *        +----> run()\n *        +----> close-operators()\n *        +----> dispose-operators()\n *        +----> common cleanup\n *        +----> task specific cleanup()\n```\n\n注意：在一个chain里面，`StreamOperator`的方法是不能并发调用的，内部实现是通过一个锁。\n\n```java\npublic final void invoke() throws Exception {\n    try {\n        beforeInvoke();\n\n        // final check to exit early before starting to run\n        if (canceled) {\n            throw new CancelTaskException();\n        }\n\n        // let the task do its work\n        runMailboxLoop();\n\n        // if this left the run() method cleanly despite the fact that this was canceled,\n        // make sure the \"clean shutdown\" is not attempted\n        if (canceled) {\n            throw new CancelTaskException();\n        }\n\n        afterInvoke();\n    }\n    finally {\n        cleanUpInvoke();\n    }\n}\n```\n\n在`beforeInvoke`中会做一些初始化工作，包括提取出所有的operator等。\n在`runMailboxLoop`中调用task运行\n在`afterInvoke`中结束\n\n任务的运行使用了`mailbox-based execution model`，这个模型做了很多封装。\n在invoke中会启动这个模型的处理循环吗，之后各个行为都被封装在Action中被调用执行。invoke的调用链：\n\n```shell script\ninvoke() -> runMailboxLoop() -> mailboxProcessor.runMailboxLoop()\n```\n\n最后交由`MailboxProcessor`来循环处理各个action，因此只要关注任务的action即可把握任务的运行情况。\n\n## 执行任务\n\n这个是任务运行的核心，即这里会产生action交由`MailboxProcessor`执行。\n`processInput`方法处理输入，是task的默认action，在输入上处理一个事件（event）。该方法又会调用`StreamInputProcessor`来处理输入，返回一个处理后的状态。\n判断当前状态来决定是否要继续这个action：如果当前有更多输入，且输出（`recordWriter`）就绪，那么直接返回（因为还有更多的输入，因此不结束action）；如果输入已经结束，标记一下action为结束状态，直接返回；否则将当前的action暂停，直到有输入且输出（`recordWriter`）就绪的时候恢复执行（异步等待）\n\n```java\nprotected void processInput(MailboxDefaultAction.Controller controller) throws Exception {\n    InputStatus status = inputProcessor.processInput();\n    if (status == InputStatus.MORE_AVAILABLE && recordWriter.isAvailable()) {\n        return;\n    }\n    if (status == InputStatus.END_OF_INPUT) {\n        controller.allActionsCompleted();\n        return;\n    }\n    CompletableFuture<?> jointFuture = getInputOutputJointFuture(status);\n    MailboxDefaultAction.Suspension suspendedDefaultAction = controller.suspendDefaultAction();\n    jointFuture.thenRun(suspendedDefaultAction::resume);\n}\n```\n\n### StreamInputProcessor\n\n这个是真正执行读取上游输入并且处理任务的接口，该接口只有一个方法：\n\n```java\npublic interface StreamInputProcessor extends AvailabilityProvider, Closeable {\n\t/**\n\t * @return input status to estimate whether more records can be processed immediately or not.\n\t * If there are no more records available at the moment and the caller should check finished\n\t * state and/or {@link #getAvailableFuture()}.\n\t */\n\tInputStatus processInput() throws Exception;\n}\n```\n\n该方法处理完输入之后，会返回状态，是一个枚举类型：\n\n```java\npublic enum InputStatus {\n\n\t/**\n\t * Indicator that more data is available and the input can be called immediately again\n\t * to emit more data.\n\t */\n\tMORE_AVAILABLE,\n\n\t/**\n\t * Indicator that no data is currently available, but more data will be available in the\n\t * future again.\n\t */\n\tNOTHING_AVAILABLE,\n\n\t/**\n\t * Indicator that the input has reached the end of data.\n\t */\n\tEND_OF_INPUT\n}\n```\n\n`StreamInputProcessor`有三个实现类，分别是：\n\n```java\nStreamOneInputProcessor\nStreamTwoInputProcessor\nStreamMultipleInputProcessor\n```\n\n这三个实现类都有一个成员变量：\n\n```java\nprivate final OperatorChain<?, ?> operatorChain;\n```\n\n配套这个成员变量的还有两组成员变量，配套的意思是如果是`StreamTwoInputProcessor`，那么下面就有两组：\n\n```java\nprivate final StreamTaskInput<IN> input;\nprivate final DataOutput<IN> output;\n```\n\n这里的input负责读，读到ouput中，调用ouput的方法，例如`emitRecord`，这个方法的实现类一般是某个`StreamTask`子类的实现类，在这里会开始处理这个输入数据，例如`OneInputStreamTask`的内部类中的一个实现：\n\n```java\n@Override\npublic void emitRecord(StreamRecord<IN> record) throws Exception {\n    numRecordsIn.inc();\n    operator.setKeyContextElement1(record);\n    operator.processElement(record);\n}\n```\n\n下面具体看一下整个调用链\n\n#### StreamOneInputProcessor\n\n核心的方法为：\n\n```java\npublic InputStatus processInput() throws Exception {\n    InputStatus status = input.emitNext(output);\n\n    if (status == InputStatus.END_OF_INPUT) {\n        operatorChain.endHeadOperatorInput(1);\n    }\n\n    return status;\n}\n```\n\n`StreamInputProcessor`的三个实现类都有类似的语句，可以看到`StreamTaskInput`类型的`emitNext`方法返回的`InputStatus`即为`processInput`判断的状态，即只包含三种输入流的状态。\n在这个方法中，最核心的就是下面这条语句：\n\n```java\nInputStatus status = input.emitNext(output);\n```\n\n这里的input和output分别是：\n\n```java\nprivate final StreamTaskInput<IN> input;\nprivate final DataOutput<IN> output;\n```\n\n`StreamTaskInput`有`emitNext`接口方法，两个实现，其中一个还是TODO状态，`StreamTaskNetworkInput`已有实现。\n首先，从deserializer中获得一个反序列化之后的结果\n\n```java\n@Override\npublic InputStatus emitNext(DataOutput<T> output) throws Exception {\n\n    while (true) {\n        // get the stream element from the deserializer\n        if (currentRecordDeserializer != null) {\n            DeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate);\n            if (result.isBufferConsumed()) {\n                currentRecordDeserializer.getCurrentBuffer().recycleBuffer();\n                currentRecordDeserializer = null;\n            }\n\n            if (result.isFullRecord()) {\n                processElement(deserializationDelegate.getInstance(), output);\n                return InputStatus.MORE_AVAILABLE;\n            }\n        }\n\n        Optional<BufferOrEvent> bufferOrEvent = checkpointedInputGate.pollNext();\n        if (bufferOrEvent.isPresent()) {\n            processBufferOrEvent(bufferOrEvent.get());\n        } else {\n            if (checkpointedInputGate.isFinished()) {\n                checkState(checkpointedInputGate.getAvailableFuture().isDone(), \"Finished BarrierHandler should be available\");\n                if (!checkpointedInputGate.isEmpty()) {\n                    throw new IllegalStateException(\"Trailing data in checkpoint barrier handler.\");\n                }\n                return InputStatus.END_OF_INPUT;\n            }\n            return InputStatus.NOTHING_AVAILABLE;\n        }\n    }\n}\n```\n\n再将这个结果放到`DataOutput`中，根据流中元素的类型，调用不同的方法，例如，如果是一条记录，那么调用其`emitRecord`方法：\n\n```java\nprivate void processElement(StreamElement recordOrMark, DataOutput<T> output) throws Exception {\n    if (recordOrMark.isRecord()){\n        output.emitRecord(recordOrMark.asRecord());\n    } else if (recordOrMark.isWatermark()) {\n        statusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), lastChannel);\n    } else if (recordOrMark.isLatencyMarker()) {\n        output.emitLatencyMarker(recordOrMark.asLatencyMarker());\n    } else if (recordOrMark.isStreamStatus()) {\n        statusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), lastChannel);\n    } else {\n        throw new UnsupportedOperationException(\"Unknown type of StreamElement\");\n    }\n}\n```\n\n在这里，output的实现类就会将这一条输入记录进行处理，例如调用各种operator等。\n\n```java\n@Override\npublic void emitRecord(StreamRecord<IN> record) throws Exception {\n    numRecordsIn.inc();\n    operator.setKeyContextElement1(record);\n    operator.processElement(record);\n}\n```\n\n#### OperatorChain\n\n另外说一下chain operator是怎么处理元素的，上面说到只要实现`DataOutput`接口就可以处理输入，但是我们可以看到实现`DataOutput`接口的类其实很少，比如`OperatorChain`就没有实现这个接口，那么是如何实现处理的呢？\n看到它的内部有一个实现类：\n\n```java\nstatic class ChainingOutput<T> implements WatermarkGaugeExposingOutput<StreamRecord<T>> {\n    ...\n    @Override\n    public void collect(StreamRecord<T> record) {\n        if (this.outputTag != null) {\n            // we are not responsible for emitting to the main output.\n            return;\n        }\n        pushToOperator(record);\n    }\n\n    protected <X> void pushToOperator(StreamRecord<X> record) {\n        try {\n            // we know that the given outputTag matches our OutputTag so the record\n            // must be of the type that our operator expects.\n            @SuppressWarnings(\"unchecked\")\n            StreamRecord<T> castRecord = (StreamRecord<T>) record;\n\n            numRecordsIn.inc();\n            operator.setKeyContextElement1(castRecord);\n            operator.processElement(castRecord);\n        }\n        catch (Exception e) {\n            throw new ExceptionInChainedOperatorException(e);\n        }\n    }\n\n    @Override\n    public void emitWatermark(Watermark mark) { ...}\n\n    @Override\n    public void emitLatencyMarker(LatencyMarker latencyMarker) { ... }\n    ...\n}\n```\n\n在这里实现了operator对数据的处理，而在这个内部类外面，有个方法可以返回一组Output：\n\n```java\nprivate <IN, OUT> WatermarkGaugeExposingOutput<StreamRecord<IN>> createChainedOperator(...){...}\n```\n\n这个`WatermarkGaugeExposingOutput`继承于`Output`接口（注意不是`DataOutput`接口）,该接口定义了几个方法\n\n```java\npublic interface Output<T> extends Collector<T> {\n\tvoid emitWatermark(Watermark mark);\n\n\t<X> void collect(OutputTag<X> outputTag, StreamRecord<X> record);\n\n\tvoid emitLatencyMarker(LatencyMarker latencyMarker);\n}\n```\n\n在`Operator`接口的各个实现中，很多都有`Output`类型的的成员变量或是其内部实现类，这些类通过层层调用，达到处理元素或者其他消息的目的。即`Output`一般是作为实现了`DataOutput`接口的成员变量而存在的，通过调用`DataOutput`，用`Output`来处理，推测可能是因为版本的原因，`Output`很早的版本就已经存在了（我看了1.4版本就已经有了），但是`DataOutput`是之后的版本才加入的，引入的目的就是重构读取输入并且处理的这个框架。它们之间的调用情况可以看一个具体的类实现：\n\n```java\npublic class SourceReaderStreamTask<T> extends StreamTask<T, SourceReaderOperator<T>> {\n  /**\n\t * Implementation of {@link DataOutput} that wraps a specific {@link Output} to emit\n\t * stream elements for {@link SourceReaderOperator}.\n\t */\n\tprivate static class StreamTaskSourceOutput<T> extends AbstractDataOutput<T> {\n\n\t\tprivate final Output<StreamRecord<T>> output;\n\n\t\tStreamTaskSourceOutput(\n\t\t\t\tOutput<StreamRecord<T>> output,\n\t\t\t\tStreamStatusMaintainer streamStatusMaintainer) {\n\t\t\tsuper(streamStatusMaintainer);\n\n\t\t\tthis.output = checkNotNull(output);\n\t\t}\n\n\t\t@Override\n\t\tpublic void emitRecord(StreamRecord<T> streamRecord) {\n\t\t\toutput.collect(streamRecord);\n\t\t}\n\n\t\t@Override\n\t\tpublic void emitLatencyMarker(LatencyMarker latencyMarker) {\n\t\t\toutput.emitLatencyMarker(latencyMarker);\n\t\t}\n\n\t\t@Override\n\t\tpublic void emitWatermark(Watermark watermark) {\n\t\t\toutput.emitWatermark(watermark);\n\t\t}\n\t}\n}\n```\n\n这里output的collect会进一步调用到operator的`processElement`（可以看到`OperatorChain`的实现就是这样）\n\n可以理解成整个读取输入并处理的过程就是从input读取，给output处理，中间通过几个接口的委托，最后会委托到具体算子来处理\n\n\n\n### 输出结果\n\n在`StreamTask`中有一个成员变量：\n\n```java\nprivate final RecordWriterDelegate<SerializationDelegate<StreamRecord<OUT>>> recordWriter;\n```\n\n改成员变量负责写入结果，其内部又代理给了`RecordWriter`，这个类里面定义了各种类型的`emit`方法，在这里面写记录\n\n\n\n#### numRecordsIn\n\n这个`Counter`类型的变量封装了处理的记录数，基本上，每次operator处理一条记录，都会累加以`numRecordsIn`为变量名的`Counter`类型的变量，例如在各种的Output里面等。\n\n","tags":["flink"],"categories":["并行计算"]},{"title":"C++学习笔记（五）","url":"/2019/12/30/C-学习笔记（五）/","content":"\n# 面向对象\n\n## 为什么要有OO\n\n解决名空间冲突问题\n\n消除安全隐患（对成员的直接赋值和修改）\n\n封装和信息隐藏\n\n封装内部结构，提供统一接口，更多的类型检查\n\n\n\n## 构造函数\n\n### 重载构造函数\n\n```c++\nclass A{\npublic:\n    A(){ cout << \"Default\" << endl; }\n    A(int i) { cout << \"int i\" << endl; }\n    A(char *p) { cout << \"char *p\" << endl; }\n};\n\nint main(){\n    A a1 = A(1); // 等价于A a1(1); A a1 = 1;\n    A a2 = A(); // 等价于 A a2;\n    A a3 = A(\"abcd\"); // 调用A(char *p)\n    A a[4]; // 调用a[0]、a[1]、a[2]、a[3]的A()\n    A b[5] = { A(), A(1), A(\"abcd\"), 2, \"xyz\" };\n    return 0;\n}\n```\n\n\n\n### 成员初始化表\n\n初始化表先于构造函数，因此const和引用要用初始化表初始化\n\n初始化表式按照对象的声明次序初始化\n\n```c++\n/*\n引用和常量必须在初始化列表中初始化\n*/\nclass A{\npublic:\n    int x;\n    const int y;\n    int z;\n    int &w;\n    A():w(x),y(1),z(x),x(0){ x = 100; }\n};\n\nclass CString{\npublic:\n    char *p;\n    int size;\n    // 按声明顺序执行初始化表\n    // 且初始化表是最先执行的\n    // 而此时size还未初始化\n    CString(int x):size(x),p(new char[size]){}\n};\n\nint main(){\n    A a;\n    cout << a.w << endl;  // 100，w设置成为了x的引用\n    cout << a.x << endl;  // 100\n    cout << a.y << endl;  // 1\n    cout << a.z << endl;  // 0，初始化表先执行，且按照声明顺序，因此x先被赋值成0，然后z赋值成x\n\n    CString s(10);\n    return 0;\n}\n```\n\n如果要调用某个成员函数的非默认构造函数，也要在成员初始化表里面显式写出\n\n要调用父类的特定构造函数，也要在成员初始化表里面显式写出\n\n\n\n## 析构函数\n\nRAII\n\nresoure acquisition is initialization\n\n对象获得即初始化\n\n核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源\n\n\n\n强制在堆上分配空间：将析构函数设为private\n\n```c++\nclass A{\nprivate:\n    ~A(){}\npublic:\n    void destroy() { delete this; }\n};\n\nint main(){\n    // A a; // 将会报错，因为析构函数是私有的，因此不能在栈上创建\n    A* a = new A;\n    // delete a; // 将会报错，因为delete默认调用析构函数\n    a -> destroy();\n    return 0;\n}\n```\n\n除了destroy，还可以写成一个静态方法：\n\n```c++\nstatic void free(A* p){ delete p; }\nA::free(p);\n```\n\n\n\n强制在栈上分配空间：将new操作符设为private\n\n```c++\nclass A\n{\nprivate:\n    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的\n    void operator delete(void* ptr){} // 重载了new就需要重载delete\npublic:\n    A(){}\n    ~A(){}\n};\n\nint main(){\n    // 将new操作符访问级别设为private可以强制只能在栈上分配对象空间\n    // A a = new A;\n    return 0;\n}\n```\n\n\n\n## 拷贝构造函数\n\n调用时机：\n\n1. 初始化的时候 A b = a;\n2. 函数参数传递\n3. 函数返回值\n\n\n\n默认的拷贝构造函数是浅拷贝，指针指向同一块内存区域，这样当一个对象析构的时候，指向同一块内存区域的指针就会变成悬挂指针（野指针）\n\n\n\n如果定义了自己的拷贝构造函数，那么就覆盖掉了默认生成的：\n\n```c++\nclass A{\npublic:\n    int x,y;\n    A(){ x = y = 0;}\n    void inc(){ x++; y++; }\n};\n\nclass B{\npublic:\n    int z;\n    A a;\n    B(){ z = 0; }\n    B(const B& b):a(b.a){ z = b.z; }\n    void inc(){ z++; a.inc(); }\n};\n\nint main(){\n    B b1;  // b1.z = b1.a.x = b1.a.y = 0\n    cout << b1.z << \" \" << b1.a.x << \" \" << b1.a.y << endl;\n    b1.inc();  // b1.z = b1.a.x = b1.a.y = 1\n    cout << b1.z << \" \" << b1.a.x << \" \" << b1.a.y << endl;\n    B b2(b1);  \n    // 如果是默认的拷贝构造函数，那么 b2.z = b2.a.x = b2.a.y = 1\n    // 如果是自己的拷贝构造函数但是没有初始化列表，那么 b2.z = 1 b2.a.x = b2.a.y = 0\n    // 如果是自己的拷贝构造函数且有初始化列表，那么 b2.z = b2.a.x = b2.a.y = 1\n    cout << b2.z << \" \" << b2.a.x << \" \" << b2.a.y << endl;\n    return 0;\n}\n```\n\n\n\n## new 和 delete\n\n### 为什么要有new和delete？\n\n会调用构造函数和析构函数\n\n\n\n### new vs malloc\n\n和malloc不同的是，new返回的是有类型的指针，不用再强制类型转化；而malloc只返回void*\n\n而且new可以重载，用于更加精细化内存管理，例如内存池模式\n\n\n\n### 调用重载构造函数\n\nnew默认调用默认构造函数，如果要调用其他构造函数，要写成：\n\n```c++\nA p = new A(1);\n```\n\n\n\nnew也可以用于内置基本类型\n\n\n\n###动态数组\n\n如果new申请的是一个数组，直接调用delete p而不是delete p[]，那么只会释放掉第一个对象的空间\n\ndelete void*会释放空间，因为分配的空间是和指针存放在一起的，但是不会调用析构函数\n\ndelete之后最好赋值成nullptr，可以防止二次delete（啥都不做）\n\n```c++\nclass A{\npublic:\n    A(){ cout << \"A's default constructor\" << endl; }\n    A(int i){ cout << \"A's int\" << endl; }\n    ~A(){ cout << \"A's de-constructor\" << endl; }\n};\n\nint main(){\n    A *p = new A[10]{1};  // 调用1次带有参数的构造函数和9次默认的构造函数，且只能调用默认构造函数\n    cout << p << endl;\n    cout << &p[0] << endl;\n    // delete p;  // 只调用一个析构函数，然后再调用delete []p会报错\n    delete []p;  // 调用10个析构函数，且是逆序delete的\n\n    void* vp = new A;\n    delete vp;  // 会有编译警告，且不会调用析构函数\n    return 0;\n}\n```\n\n\n\n## const成员函数\n\n实际上是this参数变为\n\n```c++\nvoid show(cosnt A* const this);\n```\n\nmutable关键字强调是可变的，因此可以在const成员函数里面修改mutable标记的变量\n\n```c++\n/*\n本质上是函数的参数变为了 const A* const this\n\n注意const重载的时候\n自身是否是const不会重载\n只有指向的是const还是非const才会构成重载\n类的const成员函数就会构成这样的重载\n*/\nclass A{\npublic:\n    int x,y;\n    int &indirect_int;\n    mutable int m;\n    A(int x1, int y1):indirect_int(*new int){};\n    void f();\n    // 非const和const形成了重载\n    void show() const;\n    void show();\n};\n\nvoid A::f(){\n    x = 1;\n    y = 1;\n}\n\n// 一定要写明到底有没有const\nvoid A::show(){\n    cout << \"Not const\" << endl;\n}\n\n// 一定要写明到底有没有const\nvoid A::show() const {\n    // 注意不能修改变量的值\n    // x = 1;\n    // 引用特殊，实际上引用就是const，修改的是引用指向的值\n    // 事实上不存在const &，没有意义\n    indirect_int = 1;\n    // 标记为mutable的变量永远可修改\n    m = 1;\n    cout << \"Const\" << endl;\n}\n\nint main(){\n    A a(0,0);\n    // 调用的是非const的方法\n    a.show();\n\n    const A ca(0,0);\n\n    // const对象不能调用非const的方法\n    // ca.f();\n    ca.show();\n\n    return 0;\n}\n```\n\n\n\n## 静态成员\n\n同一个类的不同对象如何共享变量？\n\n- 如果把这些共享变量定义为全局变量，则缺乏数据保护\n\n- 名污染\n\n使用static成员可以解决这个问题\n\n\n\n头文件中只是声明静态成员变量，因此不会调用静态成员变量的构造函数\n\nstatic变量初始化：\n\n```c++\n/*\n引用、常量、静态\n\n引用和常量必须在初始化列表中初始化\n静态成员变量在类外初始化且不能再带有static关键字\n*/\nclass A{\npublic:\n    // 静态成员不能在类内部初始化\n    // static int a = 0;\n    static int o;\n\n    // 但是静态的常量可以在类内初始化\n    const static int a = 0;\n    const static int b;\n};\n\nconst int A::b = 1;\n\nint A::o = 0;\n\n\nint main(){\n    A a;\n    // const static 如果直接在类内给出值，那么用到的时候是作为常量直接替换，不会分配存储空间\n    // cout << &a.a << endl;\n    // 只有在类外定义才会有存储空间\n    cout << &a.b << endl;\n    return 0;\n}\n```\n\n\n\n## 友元\n\n### 为什么要有友元？\n\n相对于c引入了访问权限，不能访问private成员，只能通过public方法，但是这会降低效率。既要有访问控制，又要有访问效率，因此就引入了友元，使得声明成友元的类或者方法可以直接使用该类的private成员\n\n\n\n友元可以访问私有成员和私有方法\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass B{\npublic:\n    void g();\n};\n\nclass A{\nprivate:\n    int a;\n    void f(){cout << \"A's f()\" << endl;}\n    friend class B;\n};\n\nvoid B::g(){\n    A a;\n    // 友元类的成员函数可以调用私有方法\n    a.f();\n    // 友元类的成员函数可以调用私有成员\n    cout << a.a << endl;\n};\n\nint main(){\n    B b;\n    b.g();\n    return 0;\n}\n```\n\n\n\n### 不完全声明\n\n下面这个例子不能通过编译，因为看不到Vector的声明\n\n编译器要提前计算每个数据的大小，由于引用或者指针都是一样大的，因此编译器只要知道类型的确存在就行了，所以只要写 class Vector; 就可以通过编译\n\n注意这里是因为是引用或者指针才能用不完全声明来解决，如果要用到具体类型的成员方法或者成员变量，还是要看到具体的完全声明。因此如果是两个友元类的方法互相声明，那将无法解决\n\n```c++\nclass Matrix\n\t\t{    ......\n \t\t     friend void multiply(Matrix &m, Vector &v, Vector &r);\n\t\t};\nclass Vector\n{    ......\n  \tfriend void multiply(Matrix &m, Vector &v, Vector &r);\n};\n\n```\n\n\n\n\n\n友元不具有传递性，也和继承体系无关\n\n\n\n## 继承\n\n### 访问权限\n\nprotected：外部访问不到，子类能访问；子类的友元也访问不到，只能通过子类来访问\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\nprotected:\n    void func1(){\n        cout << \"A's func1\" << endl;\n    }\n};\n\nclass B: public A{\npublic:  \n    // 子类中可以直接通过A来调用protected\n    void func2(){\n        A::func1();\n    }\n    // 不能通过A类型的对象来调用protected\n    void fg(A a){\n        // a.func1();\n    }\n    // 在B类中可以使用B对象的protected\n    void g(B b){\n        b.func1();\n    }\n    friend void gg();\n};\n\nvoid gg(){\n    // 在友元中可以通过子类来使用protected\n    B b;\n    b.func1();\n    // 友元中不能直接通过A来调用protected\n    // A::func1();\n}\n\nint main(){\n    B b;\n    // 在B类的外部无法使用protected\n    // b.func1();\n    return 0;\n}\n```\n\n\n\n### 继承权限\n\n不管是哪一种权限，对自己的类没有影响\n\n如果写成private，那么相当于把父类的public和protected改成自己的private\n\n因此如果是private，那么它的子类啥都使用不了\n\n如果是pretocted，就是把父类中的public变成自己的protected\n\n默认是private，一般情况下没有意义\n\n\n\n私有继承目的是复用基类的数据和方法，类似于组合，但是可以重载virtual function，更加灵活一点\n\n私有继承而且还可以节省派生对象的大小，如果私有继承的子类没有成员函数，那么大小是0，组合的话还有一个组合对象的指针\n\n注意私有继承在设计上没有意义，只是实现上复用方法以及节省空间\n\n在设计上没有意义是因为私有继承和protected继承不能转化成基类\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    virtual void func1(){\n        cout << \"A's func1\" << endl;\n    }\n};\n\nclass B: public A{\nprivate:  \n    virtual void func1(){\n        cout << \"B's func1\" << endl;\n    }\n};\n\nint main(){\n    // 有两点需要注意\n    // 1. 如果在某个时刻，通过B的对象不能访问A的公有方法，那么此时B不能转化成A，指针和引用也不行\n    // 2. 一旦B的某个形式可以转化成A，那么即使在B中为private，只要它是虚函数，通过A都可以访问到这个函数（编译器期间确定访问权限）\n    A* a = new B;\n    a -> func1();\n    return 0;\n}\n```\n\n\n\n\n\n### 不完全声明\n\n```c++\n//错误声明\nClass Undergraduated_Student:public Student;\n//正确声明\nClass Undergraduated_Student;\n// 不完全声明不需要指出继承关系\n```\n\n\n\n### 继承成员\n\n如果子类中有同名的变量或者方法，会直接覆盖掉父类的\n\n如果要保留父类的，那么要写明 A::f 或者 using A::f\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Father{\npublic:\n    void f(){cout << \"Father f()\" << endl;}\n    void f(int){cout << \"Father f(int)\" << endl;}\n};\n\nclass Son:public Father{\npublic:\n    using Father::f;\n    void f(){cout << \"Son f()\" << endl;}\n};\n\n\nint main(){\n    Son s;\n    s.f();\n    // 使用了using就可以继承父类的所有同名方法了\n    // 只会覆盖掉其中子类自定义的版本\n    s.f(1);\n    return 0;\n}\n```\n\nusing可以改变默认的访问权限\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    void f(int){cout << \"A's f(int)\"<<endl;}\n};\n\nclass B:private A{\npublic:\n    // using 可以让private继承而来的函数变成public\n    using A::f;\n    void f(){cout << \"B's f()\"<<endl;}\n};\n\nint main(){\n    B b;\n    b.f(1);\n    return 0;\n}\n```\n\n对构造函数的处理特殊，见下\n\n\n\n### 构造函数调用顺序\n\n单继承：\n\n从上往下调用构造函数\n\n从下往上调用析构函数\n\n\n\n### 继承构造函数\n\n类不能继承默认、拷贝和移动构造函数，因为编译器会为派生类合成默认的\n\n和\"继承\"别的函数一样，使用using即可，不过using完了之后，其他函数是直接照搬过来，但是对于构造函数，编译器会稍作修改\n\n![image](https://s2.ax1x.com/2019/12/18/QTqAUJ.png)\n\n还有一个区别就是，普通函数的using可以改变访问级别，例如我在private里面using，那么\"继承\"下来的函数就会是private的，但不是构造函数不一样，基类的私有构造函数在派生类中还是一个私有构造函数，而不管using出现在哪\n\n\n\n![image](https://s2.ax1x.com/2019/12/18/QTqBVg.png)\n\n![image](https://s2.ax1x.com/2019/12/18/QTqIIJ.png)\n\n\n\n事实上，如果有private版本的重载函数（非构造函数），那么不能使用using\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\nprivate:\n    A(int){}\n    void f(int){cout << \"A's f(int)\"<< endl;}\npublic:\n    A(){}\n    void f(){cout << \"A's f()\" << endl;}\n};\n\nclass B:public A{\npublic:\n    // 如果有重载的版本为private的，那么不能继承，编译报错\n    // 构造函数例外，编译不会报错，只是不会改变访问权限，仍然是private\n    // using A::f;\n    using A::A;\n    void f(){cout << \"B's f()\"<<endl;}\n};\n\nint main(){\n    B b;\n    b.f();\n    return 0;\n}\n```\n\n\n\n\n\n## 虚函数\n\n### 赋值相容，类型相容\n\n可以通过=赋值的就是赋值相容的，例如可以把子类对象赋值给父类，对象切片，对象的身份发生了变化\n\n类型相容是指保留了派生类的类型，例如通过指针或者引用来将派生类赋值给基类\n\n\n\n### 前期绑定vs后期绑定\n\n前期绑定\n\n- 编译时刻\n- 依据对象的静态类型\n- 效率高、灵活性差\n\n动态绑定：\n\n- 运行时刻\n- 依据对象的实际类型（动态）\n- 灵活性高、效率低\n\nc++注重效率，因此默认前期绑定，后期绑定需要显式指出(virtual)\n\n\n\n### 限制\n\n- 累的成员函数才可以是虚函数\n- 静态成员函数不能是虚函数\n- 内联成员函数不能是虚函数\n- 构造函数不能是虚函数\n- 析构函数可以（往往）是虚函数\n\n**虚函数一定要有实现！！！纯虚函数例外**\n\n\n\n### 虚析构函数\n\n如果析构函数不是虚函数，那么派生对象得到的资源可能不会被释放\n所以析构函数应该定义成虚函数\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    int a;\n    ~A(){\n        cout << \"A's de-constructor\" << endl;\n    }\n    A(){}\n    A(const A& a){\n        cout << \"A's copy function\" << endl;\n    }\n};\n\nclass B:public A{\n    int b;\npublic:\n    ~B(){\n        cout << \"B's de-constructor\" << endl;\n    }\n    B(){}\n    B(const B& b){\n        cout << \"B's copy function\" << endl;\n    }\n};\n\n// 析构函数也会层层调用\n// 调用如下函数，函数退出的时候\n// 会依次调用B的析构函数和A的析构函数\nvoid func(){\n    B b;\n    return;\n}\n\nint main(){\n    A* a = new B;\n    // 如果析构函数非虚，那么只会调用A的析构函数\n    delete a;\n    func();\n    return 0;\n}\n```\n\n\n\n### 原理\n\n维护一张虚函数表\n\n因此对对象做sizeof，除了成员变量的大小之外，还有虚函数表的指针大小\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\n    virtual void f(){}\n};\n\nclass B:A{\n    int a;\n};\n\nint main(){\n    B b;\n    // 大小比没有虚函数的大\n    cout << sizeof(b) << endl;\n    return 0;\n}\n```\n\n\n\n### 到底调用哪个版本\n\n**根据静态类型看能否调用；如果是virtual，且是通过指针和引用调用，根据动态类型找到调用哪个版本**\n\n\n\n非虚调虚，行为变化（非虚接口）\n\n虚调非虚，行为不变\n\n注意如果是非指针的对象调用非虚函数，里面又调用了虚函数，仍然可以动态绑定。因为方法默认第一参数为*this是一个指针（非虚接口）\n\n\n\n例子：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Father{\npublic:\n    void f(){cout << \"father's f()\" << endl;}\n    void f(int a){cout << \"father's f(int)\" << endl;}\n    virtual void g() {cout << \"father's g()\" << endl;}\n};\n\nclass Son:public Father{\npublic:\n    void f(){cout << \"son's f()\" << endl;}\n    void g() {cout << \"son's g()\" << endl;}\n};\n\nint main(){\n    // 调用非虚函数，调用的都是父类的\n    // 只有虚函数会动态调用到子类的\n    Father *f = new Son;\n    f->f(1);\n    f->f();\n\n    // 如果不是指针，那么即使是虚函数也不会动态调用\n    Father ff = Son();\n    ff.g();\n    return 0;\n}\n```\n\n\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Father{\npublic:\n    virtual void f(){\n        cout << \"Father: f()\"<<endl;\n        g();\n    }\n    void f(int a){cout << \"Father: f2(int a)\"<<endl;}\n    virtual void g(){cout << \"Father: g()\"<<endl;}\n\n    void nvf(){\n        cout << \"Father: nvf()\" << endl;\n        g();\n    }\n};\n\nclass Son:public Father{\npublic:\n    // using Father::f;\n    void f(){\n        cout << \"Son: f()\"<<endl;\n        g();\n    }\n\n    void g(){\n        cout << \"Son: g()\"<<endl;\n    }\n};\n\nint main(){\n    // 虚函数调用非虚函数和虚函数的行为都是一致的\n    // 前提是子类没有同名的非虚函数\n    Father *f = new Son;\n    // 会调用子类的g()\n    // 无论此时g是否是virtual\n    f->f();\n    cout << endl;\n\n    Father *ff = new Father;\n    ff->f();\n    // 会调用父类的g()\n    // 无论此时g是否是virtual\n    cout << endl;\n\n\n\n    // 非虚函数调用虚函数和非虚函数是有区别的\n    // 这也是模版方法的实现基础\n    // 这时候如果g是virtual，那么可以调用到子类的g()\n    // 否则调用的是父类的g\n    f->nvf();\n    cout << endl;\n\n\n\n\n    // 如果不是指针，那么只能调用父类的方法，与virtual无关\n    Father f2 = Son();\n    f2.f();\n    cout << endl;\n\n    Son s;\n    // virtual与redefined无关\n    // 如果有同名方法仍旧会被覆盖\n    // 需要使用using\n    // s.f(2);\n    return 0;\n}\n```\n\n\n\n特别注意下面这个例子，权限检查是静态时完成的，一旦静态类型检查通过，运行时就会动态调用：\n\nhttps://www.zhihu.com/question/22526510\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    virtual void f(){cout << \"A's f()\" << endl;}\n};\n\nclass B:public A{\nprivate:\n    void f(){cout << \"B's f()\" << endl;}\n};\n\nint main(){\n    A* a = new B;\n    // 仍然可以调用B的私有方法\n    // 权限检查是静态编译过程中就确定了的\n    a -> f();\n    return 0;\n}\n```\n\n\n\n\n\n### 构造函数和析构函数中调用虚函数\n\n不会有虚函数的特性，构造和析构到哪一步，调用那一步类型的对应函数\n\n\n\n构造函数中B（子类）的虚函数表还没构造\n\n因此调用的还是A（父类）的f\n\n也可以理解成B还没构造完的时候，仍然是A对象\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    A(){f();}\n    virtual void f(){cout << \"A's f()\"<<endl;}\n    virtual ~A(){f();}\n};\n\nclass B:public A{\npublic:\n    void f(){cout << \"B's f()\"<<endl;}\n};\n\nint main(){\n    // 无论是构造过程还是析构过程\n    // 调用的都是A的f()\n    // 因为到A的时候\n    // 1. B还没有构造\n    // 2. B已经析构\n    // 因此调用的都是A的f\n    B b;\n    return 0;\n}\n```\n\n\n\n\n\n### final && override\n\n见例子：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    virtual void f()final{}\n    void g(){}\n};\n\nclass B:public A{\npublic:\n    void g(int a){}\n};\n\n\n// 只有虚函数才能被定义为final\n// 不允许再被覆盖\nint main(){\n    A a;\n    return 0;\n}\n```\n\n```c++\n#include <iostream>\nusing namespace std;\n\nstruct A{};\nstruct C:A{};\n\nstruct B{\n    virtual void f1(int) const;\n    virtual A& fc();\n    virtual double fc2();\n    virtual void f2();\n    void f3();\n    // 非虚函数不能用final修饰\n    // void f5(int) final;\n\n    virtual void f5(int) final;\n};\n\nstruct D:B{\n    // 正确\n    void f1(int) const override;\n\n    // 错误，virtual重载的返回类型也要一致\n    // int f1(int) const override;\n\n    // 正确，虽然要求返回值相同\n    // 但是协变也是可以的\n    // https://blog.csdn.net/gjggj/article/details/72626794\n    C& fc()override;\n    // 基本类型没有协变\n    // int fc2()override;\n\n\n    // 错误，因为没有重载任何函数\n    // 因为不是const\n    // void f1(int) override;\n\n\n    // 下面这是重写的f1，而不是重载\n    void f1(int);\n\n\n    // 错误，没有重载任何函数\n    // void f2(int) override;\n\n    // 错误，f3不是virtual修饰，不能重载\n    // 只能重写\n    // void f3() override;\n\n    // 因为f5是final，因此不能重载\n    // void f5(int);\n};\n\nint main(){\n    return 0;\n}\n```\n\n另外注意，如果子类中没有virtual，那么调用的还是父类的版本\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass B{\npublic:    \n    virtual void f1(){ cout << \"father's f1()\" << endl; };\n};\n\nclass D:public B{\npublic:\n    void f1(int){ cout << \"son's f1()\" << endl; };\n};\n\nint main(){\n    B *b = new D;\n    b -> f1();\n    return 0;\n}\n```\n\n\n\n### 纯虚函数\n\n纯虚函数也可以有实现，但是不能是在类中实现，只能写在类外\n\n有默认实现的纯虚函数仍然不能实例化，派生类仍然需要重写\n\n可以显式调用纯虚函数的默认实现\n\n抽象类不能被实例化，因此抽象类作为接口的时候，只能传递指针和引用，不会有对象切片的问题\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    virtual void func1()=0;\n    // 纯虚函数不能直接写inline实现\n    // {\n    //     cout << \"default A func1\" << endl;\n    // }\n\n    void func2()\n    {\n        // 普通函数或普通虚函数可以直接写inline实现\n        cout << \"default A func2\" << endl;\n    }\n};\n\n// 纯虚函数可以有实现，但是实现只能在类定义的外部，不能inline\nvoid A::func1(){\n    // 纯虚函数即使有默认实现，派生类仍然需要重写该方法\n    cout << \"default A func1\" << endl;\n}\n\nclass B: public A{\npublic:    \n    void func1(){\n        // 这样就可以调用纯虚函数的默认实现了\n        A::func1();\n        cout << \"B func1\" << endl;\n    }\n};\n\nint main(){\n    B b;\n    b.func1();\n    b.func2();\n    return 0;\n}\n```\n\n\n\n### 虚函数的默认参数\n\n默认参数静态绑定，如果是动态绑定，那么调用的时候还要再查找一次默认参数的值\n这样就要查表两次（找虚函数一次，找默认参数）效率低，因此编译的时候直接用值来替换默认参数，即对象中只记录虚函数的入口地址\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    virtual void f(int a = 0) { cout << \"A's f() \" << a << endl;}\n};\n\nclass B:public A{\npublic:\n    void f(int a = 1) { cout << \"B's f() \" << a << endl;}\n};\n\nclass C:public A{\npublic:\n    void f(int a) { cout << \"C's f() \" << a << endl;}\n};\n\nint main(){\n    // 默认参数静态绑定\n    // 下面全都是打印0\n    A *p_a;\n    B b;\n    p_a = &b;\n    p_a -> f();\n\n    A *p_a1;\n    C c;\n    p_a1 = &c;\n    p_a1 -> f();\n    return 0;\n}\n```\n\n\n\n## 多继承\n\n**非虚直线继承(单继承)**\n\nB继承A，C继承B，那么C可以使用A中的成员变量和方法，但是不允许直接调用A的构造函数，**即只能负责直接基类的构造函数调用**\n\n构造函数调用顺序为：\n\n对C实例化，要先实例化B，要先实例化A\n\n因此可以看到下面的输出为：\n\nA's int a 2\nB's int a 1\nC's int a 0326696997（无意义的值）\nA's f()（这个是在C的构造方法里面调用的A的f）\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\nprotected:\n    int a;\npublic:\n    A(){}\n    A(int a){cout << \"A's int a \" << a << endl;}\n    void f(){cout << \"A's f()\" << endl;};\n};\n\nclass B:public A{\npublic:\n    B(){}\n    B(int a):A(2){cout << \"B's int a \" << a << endl;}\n};\n\nclass C:public B{\npublic:\n    C(){}\n    // 可以这样使用间接非虚拟基类的可访问的成员变量和成员方法（但是不能直接调用构造方法）\n    C(int a):B(1){cout << \"C's int a \" << a << A::a << endl;A::f();}\n    // 不允许使用间接非虚拟基类的构造函数\n    // C(int a):A(1){cout << \"C's int a\" << endl;}\n};\n\nint main(){\n    // 构造函数层层调用\n    C c(0);\n    return 0;\n}\n```\n\n\n\n**非虚菱形继承**\n\n构造函数的调用顺序为派生列表中基类的出现顺序保持一致\n\n如果有同名变量要加上基类类型\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    int a;\n    A(){}\n    A(int a):a(a){cout << \"A's int a \" << a << endl;}\n};\n\nclass B:public A{\npublic:\n    B(){}\n    B(int a):A(2){cout << \"B's int a \" << a << endl;}\n};\n\nclass C:public A{\npublic:\n    C(){}\n    C(int a):A(1){cout << \"C's int a \" << a << endl;}\n};\n\nclass D:public C, public B{\npublic:\n    D(){}\n    // 可以通过::来访问不同父类中的同名变量\n    // 该同名变量可能是父类自身的，也可能是父类继承而来的\n    D(int a):B(1),C(2){cout << \"D's int a in B is \" << B::a << endl;}\n};\n\nint main(){\n    // 构造函数层层调用\n    // 顺序为派生类的继承列表顺序\n    // 且此时因为B和C是非虚继承\n    // 因此A会初始化两次\n    D d(0);\n    // D中的a不明确，二义性\n    // cout << d.a << endl;\n    // 正确的是要加上明确的父类\n    cout << d.B::a << endl;\n    return 0;\n}\n```\n\n构造函数和析构函数的调用顺序\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    int a;\n    A(){}\n    A(int a):a(a){cout << \"A's constructor\" << endl;}\n    ~A(){cout << \"A's deconstructor\" << endl;}\n};\n\nclass B:public A{\npublic:\n    B(){}\n    B(int a):A(2){cout << \"B's constructor\" << endl;}\n    ~B(){cout << \"B's deconstructor\" << endl;}\n};\n\nclass C:public A{\npublic:\n    C(){}\n    C(int a):A(1){cout << \"C's constructor\" << endl;}\n    ~C(){cout << \"C's deconstructor\" << endl;}\n};\n\nclass D:public C, public B{\npublic:\n    D(){}\n    D(int a):B(1),C(2){cout << \"D's constructor\" << endl;}\n    ~D(){cout << \"D's deconstructor\" << endl;}\n};\n\nint main(){\n    // 构造函数层层调用\n    // 顺序为派生类的继承列表顺序\n    // 且此时因为B和C是非虚继承\n    // 因此A会初始化两次\n    // 析构函数是相反的顺序\n    D d(0);\n    return 0;\n}\n```\n\n\n\n**虚基类**\n\n如果直接基类有公共的基类，则该公共基类中的成员变量，在多继承的派生类中有多个副本，**为了消除这种多副本的情况，使用虚基类**\n\n下面这两种都行：\n\n```c++\nclass A;\nclass B:virtual public A;\nclass C:public virtual A;\nclass D:B, C;\n```\n\n显然，整体设计好了之后才会知道哪些需要虚继承\n\nis a关系变为has a关系，没有拷贝，B和C中只是有指向同一个A对象的指针，在没有实例化D时，虚基类不会构造，**虚基类的构造函数是由最新派生出的类（D）的构造函数来调用的（其他类对该基类的构造函数调用完全不起作用），且虚基类的构造函数优先非虚基类的构造函数执行**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\nprotected:\n    int a;\npublic:\n    A(){}\n    A(int a):a(a){cout << \"A's int a \" << a << endl;}\n};\n\nclass B:virtual public A{\nprotected:    \n\npublic:\n    B(){}\n    // 此时B不会调用A的构造函数\n    B(int a):A(2){cout << \"B's int a \" << a << endl;}\n    void f(){cout << \"B's f()\" << A::a << endl;}\n};\n\nclass C:virtual public A{\nprotected:\n    int a;\npublic:\n    C(){}\n    // 此时C不会调用A的构造函数\n    C(int a):A(1){cout << \"C's int a \" << a << endl;}\n    void f(){cout << \"C's f()\" << A::a << endl;}\n};\n\nclass D:public C, public B{\nprotected:\n    int a;\npublic:\n    D(){}\n    // 如果使用了虚继承，那么初始化A的责任就交到了D身上\n    // 如果D没有调用A的构造函数，那么A不会被初始化，此时B::a因为是继承自A的，那么将会是任意值\n    // 如果D指明调用A的构造函数，那么无论A在初始化列表中的位置如何，永远优先调用A的构造函数\n    // B和C对于A的初始化完全没有作用\n    D(int a):B(1),C(2),A(100){cout << \"D's int a \" << a << endl;}\n    // 可以使用A::a来访问A的成员变量和方法\n    // 如果存在vitual和非virtual，或者两个非virtual继承，那么都认为同名的变量或者方法是不明确的，不能使用A::a\n    void f(){cout << \"D's f()\" << A::a << endl; B::f(); C::f();}\n};\n\nint main(){\n    D d(0);\n    // B和C公用同一个A，持有指向同一个a对象的指针\n    d.f();\n    return 0;\n}\n```\n\n输出：\n\n```c++\nA's int a 100\nC's int a 2\nB's int a 1\nD's int a 0\nD's f()100\nB's f()100\nC's f()100\n```\n\n\n\n**虚继承和非虚继承同时存在**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\nprotected:\n    int a;\npublic:\n    A(){}\n    A(int a):a(a){cout << \"A's int a \" << a << endl;}\n};\n\nclass B:virtual public A{\nprotected:    \n\npublic:\n    B(){}\n    // 此时B不会调用A的构造函数\n    B(int a):A(2){cout << \"B's int a \" << a << endl;}\n    void f(){cout << \"B's f()\" << A::a << endl;}\n};\n\nclass C:virtual public A{\nprotected:\n    int a;\npublic:\n    C(){}\n    // 此时C不会调用A的构造函数\n    C(int a):A(1){cout << \"C's int a \" << a << endl;}\n    void f(){cout << \"C's f()\" << A::a << endl;}\n};\n\nclass E:public A{\nprotected:\n    int a;\npublic:\n    E(){}\n    E(int a):A(1000){cout << \"E's int a \" << a << endl;}\n    void f(){cout << \"E's f()\" << A::a << endl;}\n};\n\nclass D:public E,public C, public B{\nprotected:\n    int a;\npublic:\n    D(){}\n    // 虚基类的构造函数优先非虚基类的构造函数执行\n    D(int a):B(1),C(2),E(3),A(100){cout << \"D's int a \" << a << B::a << endl;}\n    void f(){cout << \"D's f()\" << endl; B::f(); C::f();E::f();}\n};\n\nint main(){\n    D d(0);\n    // B和C公用同一个A，持用指向同一个a对象的指针，且和D中的相同\n    // E有自己的A\n    d.f();\n    return 0;\n}\n```\n\n输出为\n\n```c++\nA's int a 100\nA's int a 1000\nE's int a 3\nC's int a 2\nB's int a 1\nD's int a 0100\nD's f()\nB's f()100\nC's f()100\nE's f()1000\n```\n\n\n\n### 小结和补充\n\n一个子类可以继承多个类，每一个继承都可以有自己的继承方式，成员变量的情况和单继承一样，只不过是多个\n\n多继承的构造函数的调用顺序为派生列表中基类的出现顺序保持一致，且子类只能负责直接基类的构造函数调用（非虚继承的情况下）\n\n子类可以继承构造函数，但是如果继承而来的构造函数是一样的，那么就会出错，此时子类必须要有自定义版本的该构造函数\n\n![](https://s2.ax1x.com/2019/12/31/l1XQEt.png)\n\n\n\n**类型转化的二义性错误**\n\n![](https://s2.ax1x.com/2019/12/31/l1XT2D.png)\n\n\n\n**同名的变量或者方法的二义性错误**\n\n![](https://s2.ax1x.com/2019/12/31/l1jzwR.png)\n\n除非指明调用的版本\n\n```c++\ncout << d.B::a << endl;\n```\n\n\n\n**内存布局**\n\n![](https://s2.ax1x.com/2019/12/31/l3SY0H.png)\n\n","tags":["c++"],"categories":["c++"]},{"title":"设计模式-结构型模式","url":"/2019/12/24/设计模式-结构型模式/","content":"\n# 适配器模式\n\n当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作\n\n\n\n## 定义\n\n适配器模式(Adapter Pattern) :将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。\n\n适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。\n\n\n\n## 类图\n\n分为两种\n\n![image](https://s2.ax1x.com/2019/12/24/lPiuJx.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPiQSK.png)\n\n类适配器中Target是接口，因为Adapter继承Adaptee，单继承\n\n![image](https://s2.ax1x.com/2019/12/24/lPFmng.png)\n\n类适配器是通过继承的方式调用被适配的接口\n\n![image](https://s2.ax1x.com/2019/12/24/lPFMAs.png)\n\n而对象适配器则是通过关联一个被适配者的对象来实现的\n\n![image](https://s2.ax1x.com/2019/12/24/lPkCKU.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPkPrF.png)\n\n第三方模块是被适配者，原来的模块是目标类target，采用对象适配器模式类图如下\n\n![image](https://s2.ax1x.com/2019/12/24/lPkXLD.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPVdsK.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPVcRI.png)\n\n\n\n## 优点\n\n将目标类和适配者类解耦\n\n增加了类的透明性和复用性\n\n灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。 \n\n\n\n\n\n## 类适配器vs对象适配器\n\n由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 \n\n对于类适配器来说，Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类（因为有的方法没有实现，因此不能让它实例化）， 不能为具体类，其使用有一定的局限性，不能将一个适 配者类和它的子类都适配到目标接口。 \n\n一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。\n\n与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。\n\n\n\n具体选择哪一种，可以稍微写一下代码实现，从实现角度来考虑。\n\n类适配器用的多：猜测是因为有的时候适配需要修改一些父类的实现才能实现适配。\n\n类适配器一般是一对一的情况下使用。\n\n\n\n## 应用场景\n\n![image](https://s2.ax1x.com/2019/12/24/lPEtu8.png)\n\n总的来说有两条\n\n1. 修改接口。定义一个抽象，这个抽象是客户想要的接口，然后有一个实现，实现中调用另外的符合需求的接口\n2. 将两个类扭在一起\n\n\n\n## 模式扩展\n\n### 默认适配器\n\n当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。因此也称为单接口适配器模式\n\nhttps://blog.csdn.net/IO_Field/article/details/52791975\n\n**本质就是绕过接口必须实现**这一规则\n\n\n\n### 双向适配器\n\n在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器。\n\n分析：只能用对象适配器模式，且两边都是，因此是一个对称的结构。且要有专门的方法set进适配者。在两个不同的方法中封装对于实现方法的调用\n\n![image](https://s2.ax1x.com/2019/12/24/lPZLhd.png)\n\n\n\n# 组合模式\n\n树形结构，递归调用，一致处理叶子节点和非叶子节点\n\n\n\n## 组合模式\n\n组合模式(Composite Pattern):组合多个对象形成树形结构以表示“整体-部分”的结构层次。组合模式对单个对象(即叶子对象)和组合对象(即容器对象)的使用具有一致性。\n\n组合模式又可以称为“整体-部分”(Part-Whole)模式，属于对象的结构模式，它将对象组织到树结构中，可以用来描述整体与部分的关系。\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lPutuq.png)\n\n由于要叶子和非叶子要相同对待，那么就要继承自统一的接口。其中如果是非叶子节点，那么还要聚合这个接口\n\n对于叶子节点来说，有三个方法都是不能有实现的，因此：\n\n![image](https://s2.ax1x.com/2019/12/24/lPKBeP.png)\n\n**透明性往往是要牺牲安全性**\n\n**这里的叶子节点的三个方法都是要抛出异常的，不是可以调用的方法**\n\n\n\n同时注意非叶子节点中的operation代码，需要遍历列表调用：\n\n![image](https://s2.ax1x.com/2019/12/24/lPKgzj.png)\n\n**因为组合是递归的，是一次性调用下去的，是内部遍历**\n\n**如果需要迭代器，那么是一个外部遍历，要额外维护一个栈或者队列来记录当前访问到哪一个元素**\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPK4e0.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPMY7V.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPMY7V.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPM5jA.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPQ9H0.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPQtKA.png)\n\n\n\n## 优点\n\n可以清楚地定义分层次的复杂对象 \n\n客户端可以一致的使用组合结构或其中单个对象 \n\n定义了包含叶子对象和容器对象的类层次结构，叶子对象可以被组合成更复杂的容器对象，而这个容器对象又可以被组合，这样不断递归下去，可 以形成复杂的树形结构\n\n更容易在组合体内加入对象构件（例如上面的例子中新增一个新的文件类型）\n\n\n\n## 缺点\n\n使设计变得更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大挑战性，而且不是所有的方法都与叶子对象子类都有关联\n\n增加新构件时可能会产生一些问题，很难对容器中的构件类型进行限制。 \n\n\n\n## 应用场景\n\n需要表示一个对象整体或部分层次\n\n一致对待整体和部分\n\n客户端可以针对抽象构件编程，无须关心对象层次结构的细节\n\n对象的结构是动态的并且复杂程度不一样，但客户需要一致地处理它们\n\n\n\n## 模式扩展\n\n### 透明组合模式和安全组合模式\n\n所谓的透明，是对于客户端来说透明，及叶子节点和非叶子节点没有任何区别，这样接口固定，但是必然导致叶子节点有多余的方法，这样就不安全\n\n所谓安全，及叶子节点只有operation方法，而非叶子节点有增加删除的方法，接口只有operation，这样会保证不会进行非法操作，但是要判断是叶子节点还是非叶子节点，这样就不透明了\n\n![image](https://s2.ax1x.com/2019/12/24/lPQbrR.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPlnzQ.png)\n\n即：\n\n透明模式：对待叶子节点和非叶子节点一样，所有的接口方法都可以调用\n\n安全模式：调用前要先判断一下是什么类型再调用其方法\n\n**透明性往往是要牺牲安全性**\n\n**透明模式中叶子节点的三个方法都是要抛出异常的，不是可以调用的方法**\n\n\n\n## 桥接模式\n\n两个变化维度，例如形状和颜色，需要进行组合，如果采用继承，那么产生的类的数量是乘积关系；而如果采用组合，那么类的数量是相加的关系\n\n继承：静态的强耦合\n\n组合：动态的弱耦合\n\n\n\n## 定义\n\n桥接模式(Bridge Pattern):将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式。\n\n又称为柄体(Handle and Body)模式或接口(Interface)模式。\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lP3qqs.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPYYJx.png)\n\n\n\n## 分析\n\n![image](https://s2.ax1x.com/2019/12/24/lP8eJK.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPYrTA.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPYTkn.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPYvm4.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPYz79.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPNoR0.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPNHMT.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPU8oj.png)\n\n\n\n## 优点\n\n分离抽象接口及其实现部分\n\n桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则(即一个类只有一个变化的原因)，复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法\n\n![image](https://s2.ax1x.com/2019/12/24/lPtw90.png)\n\n提高了系统的可扩充性\n\n实现细节对客户透明，可以对用户隐藏实现细节\n\n\n\n## 缺点\n\n增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程\n\n桥接模式要求正确识别出系统中两个独立变化的维度， 因此其使用范围具有一定的局限性 \n\n\n\n## 应用场景\n\n总结来说有两个方面：\n\n1. 两个变化维度\n2. 抽象和实现分离\n\n\n\n需要在构件的抽象化角色和具体化角色之间增加更多的灵活性， 避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系 \n\n抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响 \n\n一个类存在两个独立变化的维度 \n\n不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系 统 \n\n\n\n## 模式联用\n\n![image](https://s2.ax1x.com/2019/12/24/lPae74.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPa3jK.png)\n\n\n\n# 桥接模式vs命令模式\n\n参考：https://www.iteye.com/blog/c610367182-1965668\n\n不仅Implementor具有变化（ConcreteImplementor），而且Abstraction也可以发生变化（RefinedAbstraction），而且两者的变化是完全独立的，RefinedAbstraction与ConcreateImplementor之间松散耦合，它们仅仅通过Abstraction与Implementor之间的关系联系起来。强调Implementor接口仅提供基本操作，而Abstraction则基于这些基本操作定义更高层次的操作\n\n并不考虑Context的变化，只有算法的可替代性。强调Strategy抽象接口的提供的是一种算法，一般是无状态、无数据的，Context简单调用这些算法完成其操作\n\n\n\n# 装饰者模式\n\n对客户透明的方式动态地给一个对象附加上更多的责任\n\n在不需要创造更多子类的情况下，将对象的功能加以扩展\n\n\n\n## 定义\n\n装饰模式(Decorator Pattern) :动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。\n\n其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”，它是一种对象结构型模式。\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lPa2Nj.png)\n\n为什么正常的component和decorator不一样？\n\n从设计上来说，装饰者只是增加一个小职责，因此和正常的component就是不一样\n\n从调用上来说，层层调用，最内层必须要终止，因此也要区分开来\n\n\n\n是否破坏了Liskov替换原则\n\nconcreteDecoratorB，因addedBehavior是public的，因此是有可能破坏Liskov\n\n但是如果只是在operation里面调用的话则不会，例如concreteDecoratorA\n\n\n\n在抽象的Decorator中调用component的方法\n\n![image](https://s2.ax1x.com/2019/12/24/lPd3Ps.png)\n\n具体的Decorator中调用新增的方法\n\n![image](https://s2.ax1x.com/2019/12/24/lPdJx0.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPdhIH.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPdHQP.png)\n\n半透明\n\n如果只是使用move，那么就是透明的\n\n如果要使用robot里面新加的方法，就要了解当前的类型，因此是不透明的\n\n![image](https://s2.ax1x.com/2019/12/24/lPdzJs.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPwZFJ.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPwI7F.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPwHh9.png)\n\n\n\n## 优点\n\n装饰模式可以提供比继承更多的灵活性\n\n通过一种动态的方式来扩展一个对象的功能 \n\n通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合 \n\n具体构件类与具体装饰类可以独立变化 \n\n\n\n## 缺点\n\n装饰方法只能在正常对象前或者后调用，因此只能改变前置或者后置，而不能改变中间实现过程\n\n小对象太多，可以和工厂方法连用，用来创建小对象\n\n装饰模式比继承更加易于出错，排错也很困难，对于多次装饰 的对象，调试时寻找错误可能需要逐级排查，较为烦琐 \n\n\n\n## 模式扩展\n\n一个装饰类的接口必须与被装饰类的接口保持相同（实现透明性）\n\n不要把太多的逻辑和状态放在具体构件类中 ，而是通过装饰者来进行扩展\n\n如果只有一个具体构件类而没有抽象构件类，那么抽象装饰类可以作为具体构件类的直接子类 \n\n![image](https://s2.ax1x.com/2019/12/24/lPwXX6.png)\n\n\n\n## 透明性与接口扩充\n\n如果想要扩充接口，就无法实现透明，如果要透明，就无法扩充接口\n\n![image](https://s2.ax1x.com/2019/12/24/lPwx0O.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lP0Vnf.png)\n\n\n\n## 应用场景\n\n以动态、透明的方式给单个对象添加职责\n\n当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时，例如继承会使得子类太多，或是final不能继承\n\n\n\n\n\n# 外观模式\n\n## 定义\n\n外观模式(Facade Pattern):外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n外观模式又称为门面模式，它是一种对象结构型模式\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lP0uNQ.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lP0XCj.png)\n\n\n\n## 分析\n\n![image](https://s2.ax1x.com/2019/12/24/lP06HO.png)\n\n外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能\n\n**外观模式并不提供抽象**\n\n![image](https://s2.ax1x.com/2019/12/24/lPBTzR.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lP0v2n.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPB9bT.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPBiaF.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPBNsP.png)\n\n\n\n## 优点\n\n对客户屏蔽子系统组件\n\n实现了子系统与客户之间的松耦合关系\n\n降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程\n\n只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类\n\n\n\n## 缺点\n\n不能很好地限制客户使用子系统类\n\n在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了\"开闭原则\"\n\n\n\n## 应用场景\n\n当要为一个复杂子系统提供一个简单接口时可以使用外观模式\n\n客户程序与多个子系统之间存在很大的依赖性\n\n在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度\n\n\n\n## 模式扩展\n\n![image](https://s2.ax1x.com/2019/12/24/lPBfdU.png)\n\n不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现\n\n### 抽象外观\n\n![image](https://s2.ax1x.com/2019/12/24/lPBbsx.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPDuSs.png)\n\n\n\n# 享元模式\n\n享元模式通过共享技术实现相同或相似对象的重用 \n\n\n\n## 定义\n\n享元模式(Flyweight Pattern):运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为**轻量级模式**，它是一种\n对象结构型模式。\n\n\n\n## 分析\n\n在享元模式中可以共享的相同内容称为内部状态(Intrinsic State)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的\n\n在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)用于存储具有相同内部状态的享元对象\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lPDBm6.png)\n\n注意这里内部状态是共享的，右下角的意思是：不共享的话内部和外部就不分了，都是私有成员\n\n根据代码可以看出来：\n\n享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象\n\n享元工厂是一个简单工厂\n\n![image](https://s2.ax1x.com/2019/12/24/lPDfXt.png)\n\n\n\n## 内部状态vs外部状态\n\n![image](https://s2.ax1x.com/2019/12/24/lPDTAS.png)\n\n需要特别强调的是：外部状态 — 客户端保存，比如颜色的前景和背景都是保存在客户端的。只有内部状态是成员属性\n\n![image](https://s2.ax1x.com/2019/12/24/lPD7tg.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPDxBV.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPDz7T.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPri9J.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPrAj1.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lPrQ9H.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPrUUS.png)\n\n\n\n## 优点\n\n1. 共享\n2. 减少数量\n\n\n\n## 缺点\n\n1. 复杂，需要分离外部状态和内部状态\n2. 需要将某些状态外部化，使得运行时间变长\n\n\n\n## 应用场景\n\n有大量相同或者相似的对象\n\n应当在多次重复使用享元对象时才值得使用享元模式\n\n\n\n## 模式扩展\n\n### 单纯享元模式\n\n就是上面类图中的右下角，所有的享元对象都是可以共享的\n\n\n\n### 复合享元模式（和组合模式联用）\n\n![image](https://s2.ax1x.com/2019/12/24/lPr6bV.png)\n\n\n\n## 模式联用\n\n### 和静态工厂联用\n\n享元工厂是静态工厂\n\n\n\n### 和单例模式联用\n\n享元工厂是单例的\n\n\n\n### 和组合模式联用\n\n享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态，如上\n\n\n\n# 享元模式vs原型模式\n\n和原型模式的比较：原型是复制相同的，可以存储状态和备份等\n\n\n\n原型管理器 vs 享元工厂\n\n原型管理器只负责管理\n享元还负责创建\n原型管理器不一定要有\n但原型管理器是享元是模式的一部分\n\n\n\n\n\n# 代理模式\n\n通过引入一个新的对象(如小图片和远程代理对象)来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象\n\n\n\n## 定义\n\n代理模式(Proxy Pattern) :给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/24/lPrxxA.png)\n\n代理对象和真实对象接口是一致的\n将任务委托给真实对象\n可以增加一些新的行为来控制对真实对象的访问(preRequest和postRequest)，如下\n\n![image](https://s2.ax1x.com/2019/12/24/lPsprt.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/24/lPsPVf.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPcbyd.png)\n\n\n\n![image](/Users/cengshaoxun/Library/Application Support/typora-user-images/image-20191224221400409.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lPgAwq.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/24/lP27qA.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lP2LIP.png)\n\n\n\n## 优点\n\n代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度\n\n\n\n## 缺点\n\n由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢\n\n实现代理模式需要额外的工作，有些代理模式的实现非常复杂（例如远程代理就非常复杂）\n\n\n\n## 模式扩展\n\n### 保护（Protect or Access）代理\n\n控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限\n\n该代理用于控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 见实例中的第一个例子\n\n\n\n### 远程（Remote）代理\n\n为一个位于不同的地址空间的对象提供一个本地的代理 对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中， 远程代理又叫做大使(Ambassador)\n\n\n远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求\n\n和保护模式和虚拟代理相比，远程代理和业务逻辑无关，因此其实可以放在类库里面复用\n\n![image](https://s2.ax1x.com/2019/12/24/lP208U.png)\n\n\n\n### 虚拟（Virtual）代理\n\n如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。虚拟代理模式是一种内存节省技术。在应用程序启动的时候，可以用代理对象代替真实对象初始化，节省了内存的占用，并大大加速了系统的启动时间\n\n虚拟代理通过使用一个小对象来代表一个大对象，可以 减少系统资源的消耗，对系统进行优化并提高运行速度 \n\n![image](https://s2.ax1x.com/2019/12/24/lP2fPK.png)","tags":["软件设计"],"categories":["软件设计"]},{"title":"设计模式--创建型模式","url":"/2019/12/22/设计模式-创建型模式/","content":"\n# 简单工厂模式\n\nSimple Factory Pattern\n\n又称为静态工厂方法 Static Factory Method\n\n属于类创建型模式：类来创建，不需要实例化出对象来创建\n\n在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类（创建的是具体类型，但是返回的还是抽象类型）\n\n\n\n## 类图\n\n三个角色：\n\n工厂角色\n\n抽象产品角色\n\n具体产品角色\n\n![image](https://s2.ax1x.com/2019/12/22/QzFLQJ.png)\n\n简单工厂代码\n\n![image](https://s2.ax1x.com/2019/12/22/QzkZwt.png)\n\n\n\n## 分析\n\n复杂性转移：整个程序的复杂性没有变化，只不过转移了\n\n将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。 \n\n工厂方法是静态方法，可以通过类名直接调用。\n\n可以将调用时所传入的参数写在配置文件中\n\n**简单工厂模式的要点在于:当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节**\n\n\n\n策略模式经常和工厂模式配合，因为要新建一个策略，通常可以通过工厂来管理\n\n模式的引入经常会增加对象的数量，因此工厂模式很容易和其他模式结合\n\n\n\n## 优点\n\n工厂类含有必要的判断逻辑，可以决定在什么时候创建 哪一个产品类的实例，客户端可以免除直接创建产品对 象的责任，而仅仅“消费”产品;简单工厂模式通过这种做法实现了**对责任的分割，它提供了专门的工厂类用于创建对象**。 \n\n客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名 ，通过**简单工厂模式可以减少使用者的记忆量。** \n\n通过引入**配置文件**，可以在不修改任何客户端代码的情 况下更换和增加新的具体产品类，在一定程度上提高了 系统的灵活性。 \n\n对于需要先创建一些xx，才能创建xx的情况，简单工厂提供了封装。\n\n\n\n## 缺点\n\n工厂类的职责相对过重。由于工厂类集中了所有产品创建逻辑，一旦不 能正常工作，整个系统都要受到影响。 具体产品与工厂类之间的耦合度高，严重影响了系统的灵活性和扩展性\n\n使用简单工厂模式将会增加系统中类的个数， 在一定程序上增加了系统的复杂度和理解难度 \n\n系统扩展困难，一旦添加新产品就不得不修改 工厂逻辑，在产品类型较多时，有可能造成工 厂逻辑过于复杂，不利于系统的扩展和维护。 \n\n简单工厂模式由于使用了静态工厂方法，造成 工厂角色无法形成基于继承的等级结构。 \n\n简单工厂模式最大的缺点是当有新产品要加入到系统中时，必须修改工厂类，加入必要的处理逻辑，这违背了 “开闭原则”。\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QzkllQ.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QzkUYT.png)\n\n注意上面对于具体产品的关系是依赖（虚线表示）\n\n可以和代理模式结合起来\n\n![image](https://s2.ax1x.com/2019/12/22/Qzkj1g.png)\n\n\n\n在JDK类库中，日期时间类用到了简单工厂模式：\n\n![image](https://s2.ax1x.com/2019/12/22/QzAE3F.png)\n\n\n\n加密也可以使用简单工厂\n\n![image](https://s2.ax1x.com/2019/12/22/QzAZjJ.png)\n\n\n\n\n\n## 应用场景\n\n工厂类负责创建的对象比较少:由于**创建的对象较少**，不会造成工厂方法中的业务逻辑太过复杂。 \n\n客户端只知道传入工厂类的参数，**对于如何创建对象不关心**:客户端既不需要关心创建细节 ，甚至连类名都不需要记住，只需要知道类型 所对应的参数。 \n\n**变化比较少的情况**\n\n\n\n## 模式扩展\n\n![image](https://s2.ax1x.com/2019/12/22/QzAUHI.png)\n\n\n\n# 工厂方法模式\n\nFactory Method Pattern\n\n虚拟构造器 Virtual Constructor\n\n多态工厂 Polymorphic Factory\n\n类创建型模式\n\n我们先定义一个**抽象的按钮工厂类**，再定义**具体的工厂**类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在**不修改具体工厂类的情况下引进新的产品**，如果出现新的按钮类型，只需要为这种新类型的按钮**创建一个具体的工厂类**就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性\n\n\n\n## 分析\n\n不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给**专门的工厂子类**去完成\n\n在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作**延迟到工厂子类中完成**，即**通过工厂子类来确定究竟应该实例化哪一个具体产品类**\n\n具体化延迟：将具体化子类的实例化工作延迟到具体工厂来完成\n\n不是时间上的延迟，而是设计上的延迟\n\n\n\n**并不是解决简单工厂的if else的问题**，因为就算是工厂模式，具体的工厂仍然需要指明（可以把工厂方法看作是策略模式的应用，那么这个缺点其实就是策略模式的弊端）\n\n工厂方法**解决的是简单工厂增添产品需要大幅度修改的问题**\n\n工厂方法只需要增加具体的工厂就行，可修改性更好\n\n\n\n工厂方法模式退化后可以演变成简单工厂模式\n\n\n\n**为了提高系统的可扩展性和灵活性，在定义工厂和产品时都必须使用抽象层**\n\n\n\n工厂方法模式也是策略模式的一个体现。具体的工厂可以看成是一类策略，抽象的工厂就是策略的接口\n\n\n\n## 类图\n\n对比简单工厂，这里的类图增加了一个工厂父类\n\n![image](https://s2.ax1x.com/2019/12/22/QzEMrj.png)\n\n为了提高系统的可扩展性和灵活性，在定义工厂和产品时都必须使用抽象层\n\n客户端代码：\n\n![image](https://s2.ax1x.com/2019/12/22/QzEcRO.png)\n\n**工厂方法模式里面的具体工厂仍然可以接受参数，将不太会变化的放在一类工厂里面**\n\n一般将具体工厂类的实例化过程进行改进，不直接使用new关键字来创建对象，而是将具体类的类名写入配置文件中，再通过Java的反射机制，读取XML格式的配置文件，根据存储在XML文件中的类名字符串生成对象。\n\n\n\n## 补充：JAVA反射\n\n![image](https://s2.ax1x.com/2019/12/22/QzETFP.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QzEOyQ.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QzVCWT.png)\n\n客户端拥有两个抽象的父类，具体的工厂和具体的产品都是实现父类接口，然后由具体工厂创建具体产品\n\n![image](https://s2.ax1x.com/2019/12/22/QzVwp8.png)\n\n工厂方法模式也是策略模式的一个体现。具体的工厂可以看成是一类策略，抽象的工厂就是策略的接口\n\n\n\n## 优点\n\n用户只需要关心所需产品对应的工厂，**无须关心创建细节，甚至无须知道具体产品类的类名**。（这一点和简单工厂类似）\n\n基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它 能够使**工厂可以自主确定创建何种产品对象，而如何创建这个对象 的细节则完全封装在具体工厂内部**。工厂方法模式之所以又被称为 多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 \n\n使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修 改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而**只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”**（比简单工厂改进的地方） \n\n\n\n## 缺点\n\n需要编写新的具体产品类，而且**还要提供与之对应的具体工厂类**，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度\n\n增加了系统的抽象性和理解难度\n\n每种产品都是独立创建，无法在产品之间创建依赖关系，即无法生产一组互相依赖的产品\n\n\n\n## 应用场景\n\n一个类不知道它所需要的对象的类，只需要知道所对应的工厂即可\n\n将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。\n\n\n\n# 抽象工厂模式\n\n我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象\n\n\n\n产品等级结构:产品等级结构即产品的**继承结构**\n\n产品族:在抽象工厂模式中，**产品族是指由同一个工厂生产的 ，位于不同产品等级结构中的一组产品**\n\n产品等级结构和产品族：**纵向和横向关系**，产品族包含了多个产品等级结构的产品\n\n\n\n当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。\n\n工厂方法模式针对的是**一个产品等级结构**，而抽象工厂模式则需要面对**多个产品等级结构**\n\n\n\n抽象工厂模式(Abstract Factory Pattern):提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为**Kit模式**，属于对象创建型模式。\n\n\n\n## 类图\n\n对比于工厂方法模式，至少有两个抽象产品，一个具体的工厂和这些产品都有联系\n\n客户端持有抽象的工厂和所有抽象的产品\n\n![image](https://s2.ax1x.com/2019/12/22/QzmpFI.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QzmAOg.png)\n\n和上面的类图一模一样\n\n![image](https://s2.ax1x.com/2019/12/22/QzmQpV.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/22/Qzm3XF.png)\n\n这里的connection和statement是针对一个同一个系列的产品的，应该组合起来一起生产\n\n有两种数据库，对应的就是抽象的connection和statement有两种产品\n\n![image](https://s2.ax1x.com/2019/12/22/Qzmf9P.png)\n\n\n\n## 优点\n\n隔离了具体类的生成\n\n只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为\n\n增加新的具体工厂和产品族很方便，无须修改已有系统，符合“\n开闭原则”\n\n（以上都是工厂方法哦是就有的优点）\n\n能够保证客户端始终只使用同一个产品族中的对象（这个才是抽象工厂引入的目的）\n\n\n\n## 缺点\n\n在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品。\n\n因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。\n\n开闭原则的倾斜性（**增加新的工厂和产品族容易，增加新的产品等级结构麻烦**）\n\n1. 增加产品族:对于增加新的产品族，工厂方法模式很好的支持 了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工 厂即可，对已有代码无须做任何修改。 \n2. 增加新的产品等级结构:对于增加新的产品等级结构，需要修 改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生 产新产品的方法，不能很好地支持“开闭原则”。 \n\n\n\n## 应用场景\n\n一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的 \n\n系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。\n\n系统中有多于一个的产品族，而每次只使用其中某一产品族。\n\n属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。\n\n\n\n# 三个工厂模式的关系\n\n当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式\n\n当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式\n\n\n\n# 建造者模式\n\n复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。**由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里**，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机\n\n**外部化：把本来放在一起的职责分开创建对象的职责放到另一个对象中**\n\n\n\n## 定义\n\n建造者模式(Builder Pattern):将一个复杂对象的**构建**与它的**表示**分离，使得同样的构建过程可以创建不同的表示\n\n**表示：一个对象的不同内容**\n\n建造者模式是**一步一步创建一个复杂的对象**，它允许用户**只通过指定复杂对象的类型和内容**就可以构建它们，用户不需要知道内部的具体构建细节。\n\n对象创建型模式，又可称为生成器模式\n\n\n\n## 类图\n\n分成两大部分\n\nDirector负责封装创建过程（可以被复用）\n\nBuilder负责创建具体的每个部分（可以被多个指挥者复用；也可以被工厂方法代替，由工厂方法生产产品）\n\n**下面这个类图稍微有点问题，主要是Product和Builder的关系有点问题，详见实例第一题的图**\n\n![image](https://s2.ax1x.com/2019/12/22/Qzr9qe.png)\n\n其中Builder是一个抽象类，代码如下\n\n![image](https://s2.ax1x.com/2019/12/22/QzrVRP.png)\n\nDirector的作用主要有两个：一方面它隔离了客户与生产过程;另一方面它负责控制产品的生成过程\n\n客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。**也就是说客户将Builder传入指挥者，就可以返回构造之后的对象了**\n\n![image](https://s2.ax1x.com/2019/12/22/QzrQaj.png)\n\n客户端：\n\n![image](https://s2.ax1x.com/2019/12/22/Qzrby8.png)\n\n\n\n## 分析\n\n其实说的是三件事情\n\n1. 返回给客户端的是一个完整的、构造完的对象\n2. 创建过程（步骤）被封装在Director中\n3. 具体的每个部分的构造由Builder完成\n\n后两条就是定义中的将**对象的表现（Builder中完成的）和对象的构建（Director中完成的）分离开**，使得同样的构建过程可以创建出不同的表现\n\n第一条说的是另一个好处：**客户只需要确定指挥者和构造者就可以得到构造完的对象**\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QzsJkd.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QzyC4A.png)\n\n\n\nJavaMail\n\n![image](https://s2.ax1x.com/2019/12/22/Qz6GRI.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/22/Qz6oWR.png)\n\n\n\n\n\n## 优点\n\n客户端不必知道产品内部组成的细节\n\n将对象的构建与它的表示分离，使得相同的创建过程可以创建不同的产品对象\n\n用户使用不同的具体建造者即可得到不同的产品对象\n\n可以更加精细地控制产品的创建过程\n\n增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象\n建造者类编程，系统扩展方便，符合“开闭原则”\n\n\n\n## 缺点\n\n建造者模式所创建的产品一般具有较多的共同点，其组成部分相似（**例如套餐这样的**），如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制\n\n如果产品的内部变化复杂（**变化复杂而不是构造过程复杂，导致的结果是类数目增多**），可能会导致需要定义很多具体建造者类\n来实现这种变化，导致系统变得很庞大\n\n一个改进的尝试：在指挥者中指定各个部分的构造，而不是在builder中让他们组合；即指挥者来决定如何组合builder\n但是这样其实没有好处（基本可以认为是复杂性转移，将builder的工作移动到了director中），反而将生产原料的生产和组装放在一起，理解更困难\n\n\n\n## 应用场景\n\n需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多\n个成员属性\n\n需要生成的产品对象的属性相互依赖，需要指定其生成顺序\n\n对象的创建过程独立于创建该对象的类\n\n隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同\n的产品\n\n\n\n## 模式扩展\n\n省略抽象建造者角色:如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。 \n\n省略指挥者角色:在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让Builder角色扮演指挥者与建造者双重角色。 **这样的话就和普通的构造函数没什么区别只不过分到了很多小的方法中去**\n\n\n\n# 建造者模式和抽象工厂的关系\n\n与抽象工厂模式相比，建造者模式返回一个**组装好的完整产品**，而抽象工 厂模式返回**一系列相关的产品**，这些产品位于不同的产品等级结构，构成 了一个产品族。 \n\n在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以**不直接调用建造者的相关方法， 而是通过指挥者类来指导如何生成对象**，包括对象的组装过程和建造步骤， **它侧重于一步步构造一个复杂对象，返回一个完整的对象**。 \n\n如果将抽象工厂模式看成**汽车配件生产工厂**，生产一个产品族的产品，那么建造者模式就是一个**汽车组装工厂**，通过对部件的组装可以返回一辆完整的汽车。 \n\n\n\n# 原型模式\n\n建造者模式 — 复杂对象，表现很不一样；原型模式：复杂对象，但是很像\n\n使用原型模式来复制一个对象自身，从而克隆出多个与原型对象一模一样的对象 \n\n在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法 创建出更多同类型的对象，这就是原型模式的意图所在。 \n\n\n\n## 定义\n\n原型模式(Prototype Pattern):原型模式是一种对象创建型模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。原型模式允许一个对象再创建另外一个可定制的对象，无须知道任何创建的细节。\n\n\n\n## 类图\n\n原型模式的基本工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝原型自己来实现创建过程\n\n![image](https://s2.ax1x.com/2019/12/22/QzWhGQ.png)\n\n\n\n## Java提供的机制\n\n![image](https://s2.ax1x.com/2019/12/22/QzgUUg.png)\n\n![image](https://s2.ax1x.com/2019/12/22/Qz2tQ1.png)\n\n\n\n## 深克隆和浅克隆\n\n通常情况下，一个类包含一些成员对象，在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式:深克隆和浅克隆。\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QzRupd.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QzRETO.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/22/QzRL3d.png)\n\n\n\n## 优点\n\n当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过一个已有实例可以提高新实例的创建效率。（**只要按位拷贝就行了**）\n\n可以动态增加或减少产品类。 \n\n原型模式提供了简化的创建结构。 \n\n可以使用深克隆的方式**保存对象的状态**。 \n\n\n\n## 缺点\n\n**需要为每一个类配备一个克隆方法**，而且这个克隆方法 需要对类的功能进行通盘考虑，这对全新的类来说不是 很难，但对已有的类进行改造时，不一定是件容易的事， 必须修改其源代码，违背了“开闭原则”。 \n\n在**实现深克隆时需要编写较为复杂的代码**。 \n\n\n\n## 应用场景\n\n**创建新对象成本较大**。新的对象可以通过原型模式对已有对象\n进行复制来获得，如果是相似对象，则可以**对其属性稍作修改**。\n\n如果系统要**保存对象的状态**，而对象的**状态变化很小**，或者对象本身占内存不大的时候，也可以使用原型模式**配合备忘录模式来应用**。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用**状态模式**会比原型模式更好。 \n\n需要避免使用分层次的工厂类来创建分层次的对象，并且类的 实例对象只有一个或很少的几个组合状态，通过复制原型对象 得到新实例可能比使用构造函数创建一个新实例更加方便。 \n\n\n\n## 补充：备忘录模式\n\nhttps://www.runoob.com/design-pattern/memento-pattern.html\n\n![image](https://s2.ax1x.com/2019/12/22/QzW7q0.png)\n\n将备忘录对象作为状态，实现clone方法，每次都clone一下，然后改变一些状态，保存起来\n\n\n\n## 模式扩展\n\n带原型管理器的原型模式\n\n![image](https://s2.ax1x.com/2019/12/22/QzRWcR.png)\n\n\n\n很多情况下，复制所得到的对象与原型对象并不是完全相同的，它们的某些属性值存在异同。**通过原型模式获得相同对象后可以再对其属性进行修改，从而获取所需对象**。如多个学生对象的信息的区别在于性别、姓名和年龄，而专业、学院、学校等信息都相同，为了简化创建过程，可以通过原型模式来实现相似对象的复制。\n\n","tags":["软件设计"],"categories":["软件设计"]},{"title":"软件设计—行为型模式","url":"/2019/12/22/软件设计-行为型模式/","content":"\n# 策略模式\n\n## 一个例子\n\n我们要设计一个鸭子类型，自然的就想到继承。设计一个父类为鸭子，然后具体的鸭子子类去继承这个父类\n\n![image](https://s2.ax1x.com/2019/12/22/QxvKKK.png)\n\n如果我们需要添加接口，就在父类上添加接口，然后具体的子类实现\n\n但是这会产生一个问题，即添加的行为不是所有子类都有，例如有的橡皮鸭子不会飞\n\n而且每次产生新的类型的鸭子的时候，可能都需要覆盖掉这些不需要的方法\n\n因此我们考虑接口，如下：\n\n![image](https://s2.ax1x.com/2019/12/22/QxvY8I.png)\n\n\n\n但是接口同样不好，因为我们不能复用代码，例如有的行为是一样的，原先继承父类的方法就行了，现在接口就无法复用代码了\n\n因此我们要重新设计一样\n\n\n\n## 封装变化\n\n这一思想是几乎所有设计模式的宗旨\n\n唯一不变的就是变化，变化可以来自外在，也可能来自内驱\n\n设计的原则就是封装变化的部分\n\n**首先要将变化的和不变的分离出来**，对象是封装的基本单位，要把变化的部分变成新的类\n\n在上述例子中，我们需要把那些行为从鸭子类中分离出来\n\n\n\n**然后再封装**\n\n如何封装？\n\n根据需求来封装\n\n想想设计原则中的面向抽象编程，之前的设计都是根据具体编程（子类中有具体的行为实现，子类中有具体的接口的实现），因此我们要改变，面对抽象编程\n\n我们将行为抽象成为接口，然后让具体的行为去实现这个接口。这样我们可以复用这些行为的实现，还可以动态的添加这些行为，并且可以通过委托代理的方式让具体的鸭子有这些行为，委托 — 调用非本类的方法，调用其他类的方法\n\n![image](https://s2.ax1x.com/2019/12/22/QxxseO.png)\n\n这就是策略模式\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/22/Qxx7Tg.png)\n\n\n\n## 分析\n\n策略 strategy，有时又被称为 Policy\n\n定义了一组算法，将它们封装起来，让算法和客户代码独立开\n\n\n\n## 应用场景\n\n我们有一组算法，如果采用硬编码的形式将会产生大量的判断，像这种有一大堆if else来判断行为的，我们可以将它们分离出去，形成单独的策略类\n\n![image](https://s2.ax1x.com/2019/12/22/QxzQtH.md.png)\n\n一些类仅仅是行为上有一些区别（例如鸭子的例子），采用继承+覆盖的形式不灵活，无法动态配置，修改起来也麻烦。因此可以考虑采用策略模式，动态的去配置这种行为\n\n对于一个算法来说，我们有一组实现（空间或时间上的权衡），我们可以动态的选择用哪种算法。当我们让算法形成单独的类之后，我们就可以将这些变化封装起来\n\n我们还可以隐藏复杂的数据结构，将数据封装起来，和客户端分离开\n\n\n\n## 限制\n\n客户端需要知道所有的策略，需要做出选择\n\nstrategy需要设置\n\n使用者就要知道更多细节\n\n这些细节本来只要开发者知道\n\n同时也增加了类的数量\n\n\n\n# 状态模式\n\n## 定义\n\n状态模式(State Pattern) :允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。 \n\n\n\n## 分析\n\n1. 状态模式描述了对象状态的变化\n2. 对象如何在每一种状态下表现出不同的行为\n\n关键是引入了一个抽象类来专门表示对象的状态，这个类我们叫做抽象状态类，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了不同状态的行为，**包括各种状态之间的转换**\n\n即：\n\n**策略模式中策略的转化不需要由具体的策略完成**\n\n**而状态模式中状态的转化要具体的状态来负责**\n\n\n\n用抽象类来表示对象的状态而不是用接口：\n\n抽象类 — 可以有默认实现，例如全都实现为抛出异常，然后需要实现的方法就覆盖掉这些默认实现\n\n\n\n实现状态转化的两种方法：\n\n1. 由具体的状态负责\n2. 由上下文负责\n\n在实现状态切换时，在具体状态类内部需要调用环境类Context的setState()方法进行状态的转换操作\n\n在具体状态类中可以调用到环境类的方法，因此状态类与环境类之间通常还存在关联关系或者依赖关系。通过在状态类中引用环境类的对象来回调环境类的setState()方法实现状态的切换\n\n\n\n酒店的例子中，执行一个动作之后的状态是不确定的（下图中，入住之后转化到的状态要根据当前状态来确定），因此只能在具体的状态中执行状态的转化\n\n![image](https://s2.ax1x.com/2019/12/23/lSzKNF.png)\n\n\n\n环境类和状态类：\n\n![image](https://s2.ax1x.com/2019/12/23/lpVap6.png)\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/23/lSjxgI.png)\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/23/lpSKqP.png)\n\n重构之后的代码为：\n\n![image](https://s2.ax1x.com/2019/12/23/lpSQVf.png)\n\n上面代码存在一点问题：\n\n没必要if else，可以写成很多个单独方法\n\n没必要每次都new，可以保存一下，下次再取出来\n\n进一步因为没有成员对象，就可以写成静态方法\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/lpVw6O.png)\n\n这个例子中，两个地方需要注意\n\n1. 可以和代理模式联用（论坛三个等级，不同行为，就可以让三个等级的具体行为再委托其他类来执行类似的方法，这样就可以复用）\n2. 状态的转化可以在环境类中进行，因为转化规则相对固定；而不像酒店的例子中那样，转化是动态的，只能放在具体的状态中进行\n\n![image](https://s2.ax1x.com/2019/12/23/lpV5ng.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/lpeKLF.png)\n\n![image](https://s2.ax1x.com/2019/12/23/lpeJRx.png)\n\n\n\n## 优点\n\n封装了转换规则。 \n\n枚举可能的状态，在枚举状态之前需要确定状态种类。 \n\n将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 \n\n允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 \n\n可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 \n\n\n\n## 缺点\n\n状态模式的使用必然会增加系统类和对象的个数。\n\n状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。\n\n状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码（可能是其他某些状态类，也可能是环境类），否则无法切换到新增状态;而且修改某个状态类的行为也需修改对应类的源代码。 （新增加状态的源状态是要改变的（转向这个新状态），目标状态不用（新增的状态可以写转向什么状态，和开闭原则是没有关系的））\n\n上面说的开闭原则指的是可切换状态的状态模式，有一种简单状态模式是不破坏开闭原则的：\n\n这种简单状态模式类似于命令模式，封装了某个状态下对应的一系列操作\n\n![image](https://s2.ax1x.com/2019/12/23/lpuJWn.png)\n\n破坏开闭原则的解决思路：将抽象放进代码，细节放进源数据。可以将转化后的状态放到配置文件中，读取配置文件（当然这是一种改进，不属于模式本身，模式本身是带有这个缺点的）\n\n\n\n## 应用场景\n\n1. 对象的行为依赖于它的状态(属性)并且可以根 据它的状态改变而改变它的相关行为。 \n2. 代码中包含大量与对象状态有关的条件语句。\n\n\n\n## 模式扩展\n\n共享状态 \n\n在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象。 \n\n\n\n# 状态模式和策略模式对比\n\n比策略模式更进一步，状态模式还封装了对应的行为，不再需要判断具体的命令，而是由状态来负责变化到的下一个状态\n\n即：策略模式中策略的转化不需要由具体的策略完成；而状态模式中状态的转化要具体的状态来负责\n\n\n\n# 命令模式\n\n请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。\n\n命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。\n\n\n\n## 定义\n\n命令模式(Command Pattern):将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化;对请求排队或者记录请求日志，以及支持可撤销的操作。\n\n参数化：将行为转成数据，实现空间和时间上的跨越\n\n三个应用场景：\n\n1. 封装请求\n2. 队列、行为日志\n3. 撤销操作\n\n命令模式是一种对象行为型模式\n\n**别名为动作(Action)模式或事务(Transaction)模式**\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/23/lpI8AI.png)\n\n\n\n## 分析\n\n对命令进行封装，将发出命令的责任和执行命令的责任分割开\n\n请求的一方发出请求，要求执行一个操作;接收的一方收到请求，并执行操作\n\n命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n\n**关键在于引入了抽象命令接口**，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/23/lpo7Zj.png)\n\n电视机是receiver，它执行真正的操作\n\n遥控器是invoker，它持有许多命令对象\n\n抽象命令类定义一个接口\n\n有三个具体命令类实现了抽象命令接口，内部关联了receiver，并在命令的执行方法中调用了receiver来真正执行动作\n\n客户端只是负责装配\n\n![image](https://s2.ax1x.com/2019/12/23/lpT1Yt.png)\n\n\n\n和遥控器那个例子不同，遥控器上的功能都是写死的，这里要求可以动态配置。所以就让invoker有一个set方法，可以动态set进来\n\n![image](https://s2.ax1x.com/2019/12/23/lp7CjS.png)\n\n![image](https://s2.ax1x.com/2019/12/23/lp7J41.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/lpHFxK.png)\n\n\n\n## 优点\n\n降低系统的耦合度\n\n新的命令可以很容易地加入到系统中\n\n可以比较容易地设计一个命令队列和宏命令(组合命令)\n\n可以方便地实现对请求的Undo和Redo\n\n\n\n## 缺点\n\n使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。\n\n\n\n## 应用场景\n\n系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 \n\n系统需要在不同的时间指定请求、将请求排队和执行请求。 \n\n系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\n\n系统需要将一组操作组合在一起，即支持宏命令。 \n\n\n\n## 模式扩展\n\n### 撤销\n\n只要在抽象命令加一个undo接口即可\n\n具体的命令类要实现这个接口\n\ninvoker调用undo方法即可\n\n![image](https://s2.ax1x.com/2019/12/23/lpHmad.png)\n\n\n\n### 宏命令\n\n宏命令又称为组合命令，它是命令模式和组合模式联用的产物\n\n在调用宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法 \n\n实现的方式也很简单，将接口（这时候需要是一个抽象类）加上add方法、remove方法和getCommand方法，然后有具体的宏命令实现，可以将多个命令add进一个command的arraylist，执行的时候依此调用arraylist中的execute\n\n![image](https://s2.ax1x.com/2019/12/23/lpHgo9.png)\n\n\n\n# 观察者模式\n\n建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应\n\n\n\n## 定义\n\n观察者模式(Observer Pattern):定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。\n\n观察者模式又叫做发布-订阅(Publish/Subscribe)模式、模型-视图\n(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。\n\n观察者模式是一种对象行为型模式。\n\n\n\n## 类图\n\n![image](https://s2.ax1x.com/2019/12/23/lpbspt.png)\n\n为什么观察者是接口而不是抽象类\n\n声明成接口的都是和应用功能正交的功能，而且观察者中的update都是需要各个观察者自己实现的，基本上没有什么公共部分\n\n\n\n## 分析\n\n被观察者对观察者通知之后，观察者有两种方法可以得到被观察者的信息：\n\n1. 一种是上图中的，观察者留有一个被观察者的引用，通过其getState方法可以得到状态信息。这种适用于状态信息比较大的情况\n2. 另外一种是在update的时候就直接传参。这一种适合数据量比较小的情况\n\n\n\n## 实例\n\n![image](https://s2.ax1x.com/2019/12/23/lpqq2t.png)\n\n![image](https://s2.ax1x.com/2019/12/23/lpLAMV.png)\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/lpOBtJ.png)\n\n![image](https://s2.ax1x.com/2019/12/23/lpOR0O.png)\n\n\n\n## 优点\n\n观察者模式可以实现表示层和数据逻辑层的分离 \n\n观察者模式在观察目标和观察者之间建立一个抽象的耦合 \n\n观察者模式支持广播通信\n\n观察者模式符合“开闭原则”的要求 \n\n\n\n## 缺点\n\n如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 \n\n如果在观察者和观察目标之间有循环依赖的话，观察目标会触 发它们之间进行循环调用，可能导致系统崩溃。 （尽量不要实现间接观察，因为有可能会造成循环通信）\n\n观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 \n\n\n\n## 应用场景\n\n一个抽象模型有两个方面，其中一个方面依赖于另一个方面。 将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n\n一个对象的改变将导致其他一个或多个对象也发生改变，而不 知道具体有多少对象将发生改变\n\n一个对象必须通知其他对象，而并不知道这些对象是谁。 \n\n需要在系统中创建一个触发链，A对象的行为将影响B对象，B 对象的行为将影响C对象......，可以使用观察者模式创建一种链式触发机制\n\n\n\n## Java中的观察者模式\n\n![image](https://s2.ax1x.com/2019/12/23/lpO4tH.png)\n\n图上标注的意思是，update的第一个参数是Observable，用来让观察者识别当前到底是哪个被观察者发来的更新信息，以便进行下一步处理\n\n![image](https://s2.ax1x.com/2019/12/23/lpOxhj.png)\n\nnotify有两个版本，有参数的是push模式，将所有信息都push过去，无参数的是pull模式，传递给update的第二个参数是null，观察者保留被观察者的引用，然后主动去pull信息。对应的是两种得到被观察者信息的方式\n\n被观察者很难控制更新粒度：这就是setChanged方法的作用。对于不需要发生通知的变化，我们就不要setChanged，那么就不会更新（notify之前会检查是否setChanged）。一系列的变化之后，可以用 `clearChanged()`撤消更新\n\n\n\n## 模式扩展\n\n观察者列表，加一个参数，分辨到底是哪一类事件，只通知那一类事件的观察者\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/lpj6eK.png)\n\n\n\n外部观察者模式：委托外部对象来管理观察者和被观察者，可以解决java类库是父类的问题，还可以统一管理复杂的观察关系（java内置的不行，因为这样需要二维数组，来维护每一个被观察者的观察者列表）（例如我们就可以检测是否有环），缺点就是有了中心的节点，性能可能会成为瓶颈\n\n\n\n# 中介者模式\n\n用于解决通信问题\n\n\n\n## 定义\n\n中介者模式(Mediator Pattern)定义:用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n中介者模式又称为调停者模式，它是一种对象行为型模式。\n\n\n\n## 类图\n\n![](https://s2.ax1x.com/2019/12/24/lPBDiQ.png)\n\n\n\n## 分析\n\n体现了迪米特法则，没有了复杂的依赖关系，都直接和中介者交流\n\n外部观察者其实也体现了中介者模式，维护一个表，由外部观察者来通知信息\n\n减少子类生成：不用像分身一样存在于很多个不同的关系网络中\n\n思想：转移复杂度\n\n在结构和行为两方面承担职责\n\n\n\n## 实例\n\n![](https://s2.ax1x.com/2019/12/24/lCWbi6.png)\n\n![image](https://s2.ax1x.com/2019/12/24/lCW5L9.png)\n\n\n\n![](https://s2.ax1x.com/2019/12/24/lCfuoq.png)\n\n\n\n## 优点\n\n简化了对象之间的交互。\n\n将各同事解耦。\n\n减少子类生成。\n\n可以简化各同事类的设计和实现。\n\n\n\n## 缺点\n\n在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。\n\n\n\n## 应用场景\n\n系统中对象之间存在复杂的引用关系\n\n一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象\n\n想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的中介者类\n\n\n\n# 中介者模式与迪米特法则\n\n在中介者模式中，通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，中介者模式就是迪米特法则的一个典型应用。\n\n\n\n# 模板方法模式\n\n模板方法模式是基于继承的代码复用基本技术\n\n\n\n## 定义\n\n模板方法模式(Template Method Pattern):定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法是一种类行为型模式。\n\nc++中的非虚接口就是模版方法（父类中的非虚函数是复用部分，子类中覆盖的虚函数是自定义的）\n\n模板方法模式导致一种反向的控制结构，通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，符合“开闭原则”\n\n\n\n## 类图\n\n![](https://s2.ax1x.com/2019/12/24/lC4PxS.png)\n\n\n\n## 分析\n\n实现这些具体逻辑步骤的方法称为基本方法(Primitive Method)，而将这些基本法方法汇总起来的方法称为模板方法(Template Method)，模板方法模式的名字从此而来。\n\n模板方法:一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。\n\n基本方法:基本方法是实现算法各个步骤的方法，是模板方法的组成部分。\n\n基本方法有三种：\n\n1.  抽象方法\n2. 具体方法\n3. 钩子方法\n\n![](https://s2.ax1x.com/2019/12/24/lC4JaR.png)\n\n钩子方法有两种：\n\n1. 一种是空方法，嵌入在算法的步骤中（例如开头或者结尾，用户可以添加实现，也可以不添加）\n2. 一种是返回bool值的方法，可以控制是否执行某个步骤\n\n![](https://s2.ax1x.com/2019/12/24/lCoqJI.png)\n\n![](https://s2.ax1x.com/2019/12/24/lC4RRf.png)\n\n\n\n## 实例\n\n![](https://s2.ax1x.com/2019/12/24/lC47on.png)\n\n![](https://s2.ax1x.com/2019/12/24/lC4jQU.png)\n\n\n\n![](https://s2.ax1x.com/2019/12/24/lC5EQO.png)\n\n![](https://s2.ax1x.com/2019/12/24/lC5VyD.png)\n\n\n\n\n\n![](https://s2.ax1x.com/2019/12/24/lCIPBQ.png)\n\n\n\n![](https://s2.ax1x.com/2019/12/24/lCIEhq.png)\n\n\n\n## 优点缺点\n\n每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，但是更加符合“单一职责原则”，使得类的内聚性得以提高。\n\n\n\n## 应用场景\n\n各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复\n\n对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现\n\n控制子类的扩展，确保父类控制处理流程的逻辑顺序\n\n\n\n\n\n# 鼓励继承的模板方法&&好莱坞原则\n\n模板方法模式鼓励我们恰当使用继承，此模式可以用来改写一些拥有相同功能的相关类，将可复用的一般性的行为代码移到父类里面，而将特殊化的行为代码移到子类里面。这也进一步说明，虽然继承复用存在一些问题，但是在某些情况下还是可以给开发人员带来方便，模板方法模式就是体现继承优势的模式之一。\n\n\n\n![](https://s2.ax1x.com/2019/12/24/lCoFKO.png)\n\n\n\n# 策略模式vs命令模式vs模板模式\n\n参考\n\nhttps://jayfeng.com/2016/04/10/理解设计模式之命令模式、策略模式、模板方法模式/\n\n\n\n## 关联\n\n策略模式是命令模式的一个特例，而策略模式又和模板方法模式都是算法替换的实现，只不过替换的方式不同\n\n\n\n## 区别\n\n命令模式强调的是对已有行为的一个封装，而策略模式强调的是一系列未知算法的替换，这些算法需要独立的实现\n\n模板方法的重点是定义这些算法的结构，让子类去替换某些步骤；而策略模式是替换掉一整个算法实现（一般来说就是一个方法，更换策略相当于将整个算法实现替换掉）\n\n","tags":["软件设计"],"categories":["软件设计"]},{"title":"软件设计--面向对象设计原则概述","url":"/2019/12/22/软件设计-面向对象设计原则概述/","content":"\n# 软件的可维护性和可复用性\n\n**软件的复用(Reuse)或重用**拥有众多优点，如可以提高软件的开发效率，提高软件质量，节约开发成本，**恰当的复用还可以改善系统的可维护性**。\n\n面向对象设计复用的目标在于**实现支持可维护性的复用**。\n\n在面向对象的设计里面，**可维护性复用都是以面向对象设计原则为基础的**，这些设计原则首先都是复用的原则，遵循这些设计原 则可以有效地提高系统的复用性，同时提高系统的可维护性 。\n\n\n\n笔记：\n\n复用和维护通常情况下目标是相同的，但是有时候会有抵触，中的目标是既能复用，又将维护成本降低到最小。\n\n对算法、数据结构的复用通常会破坏可维护性，面向对象设计就是为了解决复用和维护的矛盾。\n\n\n\n# 重构\n\n重构(Refactoring)是在不改变软件现有功能的基础上，通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。 \n\n\n\n# 面向对象设计原则\n\n常用的面向对象设计原则包括7个，这些原则并不是孤立存在的，它们相互依赖，相互补充。 \n\n**地位不同：目标、具体操作、指导思想**\n\n![image](https://s2.ax1x.com/2019/12/22/QxypdJ.png)\n\n\n\n## 单一职责原则\n\nSingle Responsibility Princip SRP\n\n**是一个目标**\n\n### 定义\n\n一个对象应该只包含单一的职责，并且该职责被完整地封装\n在一个类中\n\n笔记：\n\n控制类的粒度，有利于复用，需要改动的可能降低到最低\n\n复用的粒度是类\n\n\n\n### 分析\n\n一个类(或者大到模块，小到方法)承担的职责越多，它被复用的可能性越小 \n\n类的职责主要包括两个方面：**数据职责和行为职责**，**数据职责通过其属性来体现，而行为职责通过其方法来体现。**\n\n单一职责原则是实现高内聚、低耦合的指导方针 \n\n\n\n### 实例\n\n![image](https://s2.ax1x.com/2019/12/22/QxysyT.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QxyyOU.png)\n\n\n\n## 开闭原则\n\n是最高目标\n\nOpen-Closed Principle, OCP\n\n### 定义\n\n一个软件实体应当**对扩展开放，对修改关闭**。也就是说在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展，即实现在不修改源代码的情况下改变这个模块的行为。\n\n**软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。**\n\n\n\n### 分析\n\n**抽象化**是开闭原则的关键\n\n开闭原则还可以通过一个更加具体的“**对可变性封装原则**”来描述，对可变性封装原则(**Principle of Encapsulation of Variation, EVP**)要求找到系统的可变因素并将其封装起来\n\n\n\n### 实例\n\n![image](https://s2.ax1x.com/2019/12/22/Qx6Zpq.png)\n\n可以看到Button是变化的部分，应该要单独抽象出来，形成一个抽象接口\n\n![image](https://s2.ax1x.com/2019/12/22/Qx6J91.png)\n\n \n\n## 里氏代换原则\n\nLiskov Substitution Principle, LSP\n\n### 定义\n\n所有引用基类(父类)的地方必须能透明地使用其子类的对象\n\n\n\n笔记：\n\n**继承和多态：并不是为了复用，而是为了提供一个稳定的抽象层。把不确定的，变化的部分封装起来形成一个稳定的抽象层。不使用具体方法，而是使用抽象的方法。新的类只要实现这些抽象方法，就可以被直接使用**\n\n\n\n### 分析\n\n在软件中如果能够使用基类对象，那么一定能够使用其子类对象。 \n\n里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子 类对象，因此**在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**。\n\n\n\n笔记：\n\n父类都是抽象方法，子类都要实现\n\n子类的额外方法是**私有方法**\n\n**不依赖具体子类**，而是在运行时使用具体子类，来**替换父类**\n\n**行为上一样；语法上可替换**\n\n**子类的前置条件更弱，后置条件更强**\n\n\n\n### 实例\n\n和开闭原则中的例子差不多\n\n![image](https://s2.ax1x.com/2019/12/22/QxcAbD.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QxcK2t.png)\n\n\n\n## 依赖倒转原则\n\nDependence Inversion Principle, DIP\n\n### 定义\n\n高层模块**不应该依赖低层模块**，它们都应该**依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。**\n\n**要针对接口编程，不要针对实现编程**\n\n\n\n### 分析\n\n代码要**依赖于抽象的类**，而不要依赖于具体的类；要**针对接口或抽象类编程**，而不是针对具体类编程\n\n\n\n依赖倒转原则的常用实现方式之一是**在代码中使用抽象类，而将具体类放在配置文件中**\n\n“**将抽象放进代码，将细节放进元数据**” \n\n\n\n笔记：\n\n修改的时候改配置文件就行了，**尽量将具体类的使用延后**\n\n\n\n类之间的耦合关系：\n\n零耦合关系（没有任何关系）\n\n具体耦合关系（和具体类耦合）\n\n抽象耦合关系（至少有一方是抽象类）\n\n**以抽象方式耦合是依赖倒转原则的关键**\n\n\n\n依赖注入：\n\n构造注入(Constructor Injection):通过构造函数注入实例变量。 \n\n设值注入(Setter Injection):通过Setter方法注入实例变量 。 \n\n接口注入(Interface Injection):通过接口方法注入实例变量。 \n\n\n\n### 实例\n\n一般来说看到类图中没有抽象类，都可以考虑用依赖倒转\n\n![image](https://s2.ax1x.com/2019/12/22/QxgFWn.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QxgEQ0.png)\n\n\n\n## 接口隔离原则\n\nInterface Segregation Principle, ISP \n\n\n\n### 定义\n\n客户端不应该依赖那些它不需要的接口。 \n\n一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。\n\n\n\n### 分析\n\n接口隔离原则是指使用**多个专门的接口，而不使用单一的总接口**（接口是一组方法的集合）\n\n1. 一个接口就只代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫做“角色隔离原则”。（**类似于单一职责**）\n2. 接口仅仅提供客户端需要的行为，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可 能小的单独的接口，而不要提供大的总接口。 （**语言层面的要求**）\n\n\n\n首先必须满足**单一职责原则**，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。\n 可以在进行系统设计时采用**定制服务**的方式，即为不同的客户端提供**宽窄不同**的接口，只提供用户需要的行为，而隐藏用户不需要的行为。\n\n\n\n### 实例\n\n看到巨大的接口就要拆分\n\n![image](https://s2.ax1x.com/2019/12/22/Qxgrlt.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QxgyOf.png)\n\n\n\n## 合成复用原则\n\nComposite Reuse Principle, CRP\n\n合成：组合和聚合都算合成\n\n\n\n### 定义\n\n**尽量使用对象组合（合成），而不是继承来达到复用的目的**\n\n\n\n### 分析\n\n合成复用原则就是指在一个新的对象里通过**关联关系(包括组合关系和聚合关系)**来使用一些已有的对象，使之成 为新对象的一部分;新对象通过**委派调用已有对象的方法达到复用其已有功能的目的**。简言之:**要尽量使用组合/聚合关系，少用继承**。\n\n\n\n继承复用和组合复用：\n\n继承复用:实现简单，易于扩展。破坏系统的封装性; 从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性;只能在有限的环境中使用。 (“**白箱**”复用 ) \n\n组合/聚合复用:耦合度相对较低，选择性地调用成员对象的操作;可以在运行时动态进行。(“**黑箱**”复用 ) \n\n\n\n**一般首选使用组合/聚合来实现复用**\n\n \n\n笔记：\n\n如果是改写接口的返回值等进行复用，那么可以用组成（**不涉及中间步骤的更改，只是在头尾修改**）\n如果要改变其中几个步骤，那么需要用继承\n\n\n\n正确的观点：\n\n**继承复用的是抽象接口**\n**合成复用的是具体实现**\n\n并且**合成的还是抽象耦合，使用的还是抽象类型**\n\n\n\n### 实例\n\n一般来说就是改继承为组合\n\n![image](https://s2.ax1x.com/2019/12/22/Qxgb0U.png)\n\n![image](https://s2.ax1x.com/2019/12/22/QxgXtJ.png)\n\n\n\n## 迪米特法则\n\nLaw of Demeter, LoD\n\n又称为最少知识原则(Least Knowledge Principle, LKP)\n\n\n\n### 定义\n\n1. **不要和“陌生人”说话**\n2. **只与你的直接朋友通信**\n\n3. **每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位**\n\n在狭义的迪米特法则中，**如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用**，如果其中的一个类需要调用另一个类的某一个方法的话， 可以通过**第三者转发这个调用**\n\n因为要转发，因此**通常和效率是矛盾的**\n\n广义的迪米特法则:指对对象（模块）之间的信息流量、流向以及信息的影响的控制，主要是对**信息隐藏**的控制，控制信息的过载\n\n \n\n朋友：\n\n1. 当前对象本身(this); \n\n2. 以参数形式传入到当前对象方法中的对象; \n\n3. 当前对象的成员对象; \n\n4. 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友; \n\n5. 当前对象所创建的对象。\n\n    \n\n陌生人：\n\n调用其他方法返回出来的对象\n\n\n\n指导行为：\n\n1. 在类的划分上，应当尽量创建**松耦合**的类，类之间的耦合度 越低，就越有利于复用，一个处在松耦合中的类一旦被修改 ，不会对关联的类造成太大波及; \n2. 在类的结构设计上，每一个类都应当尽量**降低其成员变量和成员函数的访问权限; **\n3. 在类的设计上，只要有可能，一个类型应当设计成**不变类;**\n4.  在对其他类的引用上，一个对象对其他对象的**引用应当降到最低** \n\n\n\n### 实例\n\n一般来说就是通信非常复杂，就引入中间层\n\n![image](https://s2.ax1x.com/2019/12/22/Qx2Ehd.png)\n\n![image](https://s2.ax1x.com/2019/12/22/Qx28hj.png)\n\n\n\n# 什么是设计模式\n\n设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结\n\n设计模式不会给出具体的代码实现，需要结合需求来给出实现\n\n设计模式不是发明出来的，而是发现的\n\n设计模式和设计原则大部分都是针对解决变化这个问题，允许系统的一部分单独变化而不会影响其他部分\n\n设计模式提供了共同语言\n\n设计模式被证实是一种好的面向对象设计经验\n\n\n\n# 为什么需要设计模式\n\n设计模式形成了术语，节约交流成本，可以让开发人员在设计层面上思考问题，而不是更细节的层面。注重设计，而不会迷失在细节当中\n\n设计模式的名字就可以概括一大堆设计中的细节和特点，交流付出的代价更小\n\n可以让年轻的设计人员更快上手\n\n\n\n只了解设计原则还不够，好的设计人员需要想的更多，让软件可维护性更好，更加灵活，可以应对更多变化。这就是设计模式的意义。但是设计原则是一个很好的指导。设计模式可以给出一个好的设计，符合设计原则的设计\n\n\n\n# 设计模式和类库和框架的关系\n\n设计模式比类库的层次更高，它知道我们如果解决一类问题，而不是着眼于一个具体的问题\n\n框架和类库不是设计模式，它们提供了具体的实现。但是它们的实现过程中使用了大量设计模式\n\n\n\n# 类行为型模式和对象行为型模式\n\n只有继承关系，没有对象关联关系，是类的行为型模式\n类行为型模式：继承来实现","tags":["软件设计"],"categories":["软件设计"]},{"title":"c++学习笔记（六）","url":"/2019/12/21/c-学习笔记（六）/","content":"\n# C部分\n\n## Data\n\n数据包括：\n\n1. 名\n2. 值\n3. 地址\n4. 类型\n5. 性质\n\n其中类型指的是：取值范围和操作\n\nc++是强类型，动静结合的语言（实际上还是静态）\n\n\n\n## 基本数据类型\n\nchar int float double\n\n修饰符：long short signed unsigned\n\nchar 只能用signed、unsigned修饰\n\nfloat 不能被修饰\n\ndouble 只能用long修饰\n\nint 可以用以上4种修饰符组合修饰，例如long long int a;实际上为8个字节，和long long长度一样，当然长度是和机器有关的\n\n\n\n一个char的大小和一个机器字节一样，8bits\n\nwchar_t为宽字符类型，16bits\n\n\n\nint short long 和 long long都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型，例如unsigned long，类型unsigned int可以缩写为unsigned\n\nchar有三种类型：char、signed char、unsigned char\n\n\n\n### 类型别名typedef\n\ntypedef可以定义类型的别名，含有typedef的声明语句定义的不再是变量而是类型别名，如下：\n\n![image](https://s2.ax1x.com/2019/12/21/QjdeEV.png)\n\n再如：\n\npstring是char *的别名\n\n![image](https://s2.ax1x.com/2019/12/21/QjdHaV.png)\n\npstring指代的类型要作为整体来看，不能直接带入原来的类型\n\n![image](https://s2.ax1x.com/2019/12/21/QjdzrR.png)\n\n上面的常量指针表达好像有点问题，见下面这个例子\n\n```c++\nint main(){\n    int i = 1;\n    const pa i1 = &i;\n    // 正确\n    // i1并不是指向常量，而是指针本身不可修改\n    *i1 = 2;\n    const int *i2 = &i;\n    // 错误\n    // i2指向常量\n    // *i2 = 2;\n    return 0;\n}\n```\n\n\n\ntypedef和数组\n\n```c++\ntypedef int A[10];\n\nvoid f(int (&a)[11]){\n\n}\n\nint main(){\n    A a;\n    cout << sizeof(a)/sizeof(a[0]) << endl;\n    // 错误\n    // A是长度为10的数组\n    // f的参数为长度为11的数组的引用，不兼容\n    // f(a);\n    return 0;\n}\n```\n\n\n\n## 表达式求值\n\n副作用值得是求值次序引起的结果不确定：例如y+ ++y\n\n\n\n### 计算中的类型转换\n\n```c++\nint main(){\n    int x=10;\n    int y=3; double d=2.0 ;\n    // 因为计算顺序问题会产生不同的结果\n    // cout << d + x/y*d + ++y << endl;\n\n    // 因为x/y仍然是整数，因此结果为8\n    cout << d + x/y*d << endl;\n    // 因为d*x/y是浮点数，因此结果为浮点数\n    cout << d + d*x/y << endl;\n\n    // 要注意下面这样其实是没用的，结果还是3\n    cout << 1.0*(x / y) << endl;\n    return 0;\n}\n```\n\n\n\n### 三目操作符的嵌套\n\n```c++\nint main(){\n    int x = -100;\n    // 三目运算符可以嵌套\n    // 遵循就近原则\n    // 结果为-1\n    cout << (x > 0? 1: x == 0? 0 : -1) << endl;\n    return 0;\n}\n```\n\n\n\n### 逗号表达式\n\n如果有一连串的逗号表达式赋值，那么最右边的那个表达式的值会赋值给左边，如下：\n\n```c++\nint main(){\n    int a,b,c;\n    int d = (a = 1, b = a+2, c = b+3);\n    // 最后一个表达式的值赋值给d\n    // 输出结果为6\n    cout << d <<endl;\n    return 0;\n}\n```\n\n\n\n### 位运算符\n\n主要是异或的运算比较特别\n\n![image](https://s2.ax1x.com/2019/12/21/Qjq3M4.png)\n\n\n\n### switch的优化\n\n如果内部实现成多个if else嵌套，那么最多找到正确的分支的时间为O(N)\n\n![image](https://s2.ax1x.com/2019/12/21/QjXFxO.png)\n\n优化成只比较一次：\n\n首先取出switch中的值，然后和最大值比较，如果超过，那么跳转到default，否则直接跳转到对应的情况的起始地址（专门做了一张表，按照顺序存放了各个可能情况的处理代码的起始地址，这样switch中的值就是作为偏移量，*4之后加上这张表的基址，就可以直接找到对应处理代码的起点）\n\n![image](https://s2.ax1x.com/2019/12/21/Qjzlkj.png)\n\n\n\n### 表驱动编程\n\n处理错误的时候，可以在一个数组中放struct，struct为错误信息，处理错误的函数指针（因为错误处理函数的接口都一样，因此可以统一定义类型）\n\n\n\n## 函数\n\n### 函数调用过程分析\n\n函数传递参数有两种形式：值传递和引用传递\n\n下面先看值传递的情况：\n\n![image](https://s2.ax1x.com/2019/12/21/Qv9P7F.png)\n\n例子中调用者维护堆栈：\n\n调用前，ebp在高地址，esp在低地址，中间是main函数的栈（已经包含了将要调用的函数的参数空间）\n\n参数从右到左放入（使用mov，移动到esp+某个偏移量，这样效率比push高）\n\n返回地址压栈（push，esp向下移动）\n\n跳转到新函数的起始地址开始执行\n\npush ebp，将ebp压栈，保存原来的ebp\n\n然后将ebp移动到此时的esp处（和第一个参数间隔0x8）\n\nesp移动到下面，分配足够这个函数运行的栈空间\n\n执行函数体，通过esp+0x8可以取出第一个参数，+0xc取出第二个参数，返回值放在eax中\n\n将esp置回esp的位置\n\n弹栈，还原main函数的ebp\n\n再弹栈，找到原先压入的返回地址\n\n返回之后，将eax的值（返回值）放到相应位置\n\n![image](https://s2.ax1x.com/2019/12/21/QvCwKx.png)\n\n![image](https://s2.ax1x.com/2019/12/21/QvCRxI.png)\n\n上面这种方式为cdecl call，由调用者清理参数的栈，这可以应对可变参数的情况（因为调用者知道有多少个实际参数，从而可以正确清理堆栈）\n\n另一种方式是stdcall，由被调用者清理堆栈，不能处理可变参数的情况\n\n还有一种方式是fastcall，用寄存器传递参数\n\ncdecl call的栈情况\n\n![image](https://s2.ax1x.com/2019/12/21/QvFKxA.png)\n\n\n\n下面看引用传递的情况：\n\n![image](https://s2.ax1x.com/2019/12/21/QvkWtS.png)\n\n和前面的区别是放入栈中的不再是一个数字，而是一个地址\n\n这个地址就是引用变量的地址，之后通过lea就可以操作原来的那个变量的值了\n\n\n\n![image](https://s2.ax1x.com/2019/12/21/Qvk6mt.png)\n\n![image](https://s2.ax1x.com/2019/12/21/Qvkr6A.png)\n\n\n\n总结：\n\n![image](https://s2.ax1x.com/2019/12/21/QvEJIK.png)\n\n\n\n还有两种特别奇葩的方式：c++好像没有实现\n\n![image](https://s2.ax1x.com/2019/12/21/QvV3lQ.png)\n\n![image](https://s2.ax1x.com/2019/12/21/QvVGOs.png)\n\n### 函数声明\n\n使用外部c函数要声明extern \"C\"，因为c++有重载c无重载，所以符号表不一样，因此一定要声明来自c，否则找不到\n\n\n\n### 函数重载\n\n返回值类型不作为区别重载函数的依据\n\n但是const可以区分，例如：\n\n```c++\n/*\n注意const重载的时候\n自身是否是const不会重载（因为没有意义）\n只有指向的是const还是非const才会构成重载\n类的const成员函数就会构成这样的重载\n*/\nvoid f(int *a){\n    cout << \"Not const\" << endl;\n}\n\n// 不构成重载\n// void f(int *const a){\n\n// }\n\nvoid f(const int *a){\n    cout << \"Const\" << endl;\n}\n```\n\n\n\n函数重载可能会出现二义性问题\n\n```c++\nvoid f(int a){\n    cout << \"f(int)\" << endl;\n};\n\nvoid f(double a){\n    cout << \"f(double)\" << endl;\n};\n\n// 如果是精确匹配不会有问题\n// 非精确匹配如果有转化优先级则不会有问题\n// 否则就会有问题\nint main(){\n    // long a = 1;\n    short a = 1;\n    f(a);\n    return 0;\n}\n```\n\n上面的例子中如果是第一行，因为long转为int和double并没有优先级，会报错，short优先转为int，因此不会报错\n\n\n\n### 默认参数\n\n靠右边写，因为函数的参数是从右向左压栈\n\n默认参数会导致二义性：\n\n```c++\nvoid f(int);\nvoid f(int, int=2);\n```\n\n\n\n### inline函数\n\n推荐而非强制，取决于调用方式\n\n加上inline不一定真的是内联函数，是否真的是inline还要看编译器的决定，如果inline被拒绝，那么每一份单独的文件里面都会出现该函数，仍然是函数调用，只不过被限制了作用域（static）\n\ninline函数不能是递归函数，如果是递归，那么拒绝inline\n\n如果有对inline函数取地址的操作，那么也会拒绝inline\n\n和宏相比：有类型检查\n\ninline函数调用前必须要有函数体，因为编译系统将为inline函数创建一段代码，每次调用时，用相应的代码替换，因此内联函数，包括函数模板中的内联 – 一般都是放在头文件中\n\n\n\ninline的缺点：增大目标代码；病态的换页；降低指令块取装置的命中率\n\n\n\n## 程序组织\n\n### extern\n\n在头文件中声明，源文件中定义\n\n头文件中声明成extern不会再分配空间，会在符号表留下位置\n\n\n\n### const\n\nconst默认作用域为本文件，因为编译之后直接拿值替换了\n\n例如：\n\na.cpp为：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nconst int a = 1;\n\nint main(){\n    return 0;\n}\n```\n\nb.cpp为：\n\n```c+\nextern const int a;\n\nvoid f(){\n    int b = a;\n}\n```\n\nlink阶段会报错\n\n为了使得可以共享同一常量，应该将常量统一写在头文件中\n\n\n\n### static\n\nstatic修饰函数内变量有全生命周期，但是可访问的范围还是不变\n\n```c++\nclass A{\npublic:\n    ~A(){cout << \"~ A\" << endl;}\n};\n\nvoid f(){\n    static A a;\n    return;\n}\n\nint main(){\n    f();\n    cout << \"main finished\" << endl;\n    return 0;\n}\n```\n\n上面的例子中，先打印main finished，再打印~ A\n\n\n\nstatic可以记录下函数的访问次数\n\n```c++\nint fun(void){\n    static int count = 0;\n    return count++;\n}\n\n// static变量全生命周期\n// 且可以用来记录访问次数\n// 这一点和类的static成员变量类似\nint main(void)\n{    \n    for(int i = 0; i < 10; i++)\n        cout << fun() << endl;    \n    return 0;\n}\n```\n\n\n\n不作任何处理的变量和函数都是程序级的（都可以访问）\n\n加上static表示文件级的，两个文件中有同名的static函数（因为限制在文件级中，不会冲突）\n\n\n\n### namespace\n\n在约束作用域方面，替代static\n\n解决全局变量/函数的名冲突\n\n两种形式：\n\nusing-declaration，例如using L::k\n\nusing-directive, 例如using namespace L（不建议在同一作用域两次使用using-directive）\n\n\n\n#### 支持别名\n\n```c++\nnamespace ATT = American_Telephone_and_Telegraph\n```\n\n\n\n#### 可嵌套\n\n```c++\nnamespace L1 { \n  inta;\n\t.......\n\tnamespace L2 { \n    void f() ;\n\t\t.......\n\t} \n}\n........\n\nL1::L2::f();\nusing namespace L1; \nL2::f();\n```\n\n内层命名空间声明的名字将隐藏外层命名空间声明的同名成员。在嵌套命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码想要访问它必须在名字前添加限定符\n\n\n\n#### 可以是不连续的\n\n![image](https://s2.ax1x.com/2019/12/21/Qv2DoQ.png)\n\n\n\n#### 全局命名空间\n\n全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在全局命名空间中。\n\n作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并没有名字：\n\n```c++\n::member_name\n```\n\n\n\n#### 例子\n\n```c++\n// 全局变量，默认初始化为0\nint a;\n\nnamespace X { \n    // 命名空间中的变量，默认初始化为0\n    int a;\n    void f(){\n        int a = 0;\n        // 临时变量\n        a++;\n        // X中的a\n        X::a++;\n        // 全局的a\n        ::a++;\n        // 三个都输出1\n        cout << ::a << endl;\n        cout << X::a << endl;\n        cout << a << endl;\n    }\n};\n\nint main(){\n    X::f();\n    return 0;\n}\n```\n\n\n\n## 预处理宏\n\n优点：\n\n方便程序修改\n\n提高程序运行效率\n\n\n\n缺点：\n\n看不到名字，不利于调试\n\n不能数值拷贝\n\n不能做参数类型检查\n\n可能会降低可读性\n\n\n\n### 常量\n\n可以用#define定义常量，已被const取代\n\n\n\n### 内联函数\n\n可以用#define定义无数个重载版本，已被inline取代。inline有类型检查\n\n\n\n### 泛型函数\n\n可以用#define定义无数个重载版本，实现泛型编程，已被template取代\n\n\n\n### 泛型类型\n\n同样被template取代\n\n\n\n### 重命名\n\n可以用#define进行重命名，已被namespace取代\n\n\n\n### 字符串拼接\n\n无法取代\n\n```c++\n#define conn(x,y) x##y\n#define ToChar(x) #@x\n#define ToString(x) #x\n```\n\nhttps://blog.csdn.net/xdsoft365/article/details/5911596\n\n\n\n### 预定义ifndef\n\n无法取代\n\n![image](https://s2.ax1x.com/2019/12/21/QvhjgA.png)\n\n\n\n\n\n### 控制程序组织\n\n例如#pragma可以定义内存布局\n\n\n\n## 数组\n\n相同类型，连续存储\n\n注意字符数组：\n\n![image](https://s2.ax1x.com/2019/12/21/Qv4PUS.png)\n\n\n\n### 多维数组\n\n可以这样看：\n\n```c++\nT A[c1][c2]\ntypedef T T1[c2]\nT1 A[c1];\n```\n\n\n\n作为函数参数，需要传递第二维，省略第一维：\n\n```c++\nvoid f(int a[][3], int n);\n```\n\n\n\n## struct\n\n可以控制对齐的程度\n\n\n\n## Union\n\n共享存储空间\n\n\n\n例子：\n\n```c++\nunion B{\n    char b;\n    int a;\n    short c;\n};\n\nint main(){\n    B b;\n    b.a = 0x12345678;\n    cout << b.a << endl; \n    // 输出的是16进制78的十进制值\n    // 因为是小端存储，因此78放在高地址处\n    // 可见char是对齐到高地址处\n    cout << (int)b.b << endl; \n    return 0;\n}\n```\n\n\n\n### 例题\n\n定义数组，存储100个图形（直线、矩形，圆）\n\n直线和矩形都要4个int\n\n圆只要3个int\n\n不能统一定义\n\n需要加一个字段表示类型\n\n因此最后的形式为：\n\n![image](https://s2.ax1x.com/2019/12/21/Qv7EnA.png)\n\n![image](https://s2.ax1x.com/2019/12/21/Qv7uh8.png)\n\n\n\n## 指针\n\n空指针不一定是0，例如：\n\n```c++\n// 如果定义空指针是0\n// 那么下面的代码将产生问题\nvoid f(int);\nvoid f(int *);\nf(NULL)\n```\n\n因此引入专门的值：nullptr\n\n\n\n### 指针运算\n\n指针加减整数运算，+1会偏移sizeof(基类型)\n\n![image](https://s2.ax1x.com/2019/12/21/QvHrRS.png)\n\n\n\n\n\n同类型的指针相减，得到的是整型，偏移量，具体为：\n\n值差/sizeof(基类型)，和上面加减整数的定义保持一致\n\n![image](https://s2.ax1x.com/2019/12/21/QvHRZn.png)\n\n\n\n### 指针的输出\n\nchar*特殊，直接输出的话是字符串，如果输出\\*p，那么因为p其实是第一个元素的地址，所以输出的是第一个字符，如果真的要输出地址，那么需要转型为(int\\*)\n\n![image](https://s2.ax1x.com/2019/12/21/QvHWaq.png)\n\n\n\n### void*指针\n\n只管理地址信息，定义的是指针类型的公共接口，任何指针都可以转化为void*指针（可以强制转化，也可以直接写void\\* a = &x），反之则不行（只能强制类型转换）\n\n\n\n用途：\n\n![image](https://s2.ax1x.com/2019/12/21/QvbkdI.png)\n\n![image](https://s2.ax1x.com/2019/12/21/QvqbU1.png)\n\n\n\n### 指针常量和常量指针\n\n从最靠近变量名开始向外看\n\n![image](https://s2.ax1x.com/2019/12/21/Qvq9hV.png)\n\n\n\n### const_cast\n\n可以将const转为非const\n\n可以用于函数调用中，但是修改const的值仍然是不允许的\n\n```c++\n#include <iostream> \nusing namespace std; \n  \nint fun(int* ptr) \n{ \n    *ptr = *ptr + 10; \n    return (*ptr); \n} \n  \nint main(void) \n{ \n    // val本来就是const，改变了const的值\n    // 输出是未定义的\n    const int val = 10; \n    const int *ptr = &val; \n    int *ptr1 = const_cast <int *>(ptr); \n    fun(ptr1); \n    cout << val << endl; \n    return 0; \n} \n```\n\n如果删除掉val原来的const定义，那么下面的行为是允许的：\n\n```c++\n#include <iostream> \nusing namespace std; \n  \nint fun(int* ptr) \n{ \n    *ptr = *ptr + 10; \n    return (*ptr); \n} \n  \nint main(void) \n{ \n    // val本来就是const，改变了const的值\n    // 输出是未定义的\n    const int val = 10; \n    const int *ptr = &val; \n    int *ptr1 = const_cast <int *>(ptr); \n    fun(ptr1); \n    // 输出10，因为常量的值编译时候就填入了\n    cout << val << endl; \n    return 0; \n} \n```\n\n\n\n像上面例子一样，看下面这个例子：\n\n因为常量的值编译的时候就会做替换，所以同一个地址看起来有两个值：\n\n![image](https://s2.ax1x.com/2019/12/21/QvLi5t.png)\n\n\n\n### 指针常量\n\n<类型>* const<指针变量>\n\n必须在定义的时候就初始化（所有常量都是如此）\n\n\n\n### 指针与函数\n\n作为形式参数：\n\n![image](https://s2.ax1x.com/2019/12/21/QvLeKg.png)\n\n\n\n作为函数指针：\n\n注意两种等价形式\n\n![image](https://s2.ax1x.com/2019/12/21/QvL82T.png)\n\n\n\n应用，计算器程序：\n\n![image](https://s2.ax1x.com/2019/12/21/QvLxJ0.png)\n\n进一步优化：\n\n![image](https://s2.ax1x.com/2019/12/21/QvOVF1.png)\n\n\n\n泛型冒泡排序：\n\n![image](https://s2.ax1x.com/2019/12/21/QvONSf.png)\n\n \n\n计算积分的接口：\n\n![image](https://s2.ax1x.com/2019/12/21/QvjCVJ.png)\n\n\n\n### 指针与数组\n\n数组的名字可以直接使用，为指向第一个元素的指针，因此用指针访问数组元素和使用下标具有同等的能力\n\n但是数组名不能修改，即不能a++，（这并不代表它是一个常量，事实上，指针名可以作为参数传入非const的一维指针形参）如下：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int a[10] = {0};\n    int *p = a;\n    for(int i = 0; i < 10; i++){\n        cout << *(a+i) << endl;\n        // 错误 a是指向第一个元素，但是是int *const\n        // cout << *(a++) << endl;\n\n        // 正确，相当于把 int *const赋值给int *\n        cout << *(p++) << endl;\n    }\n    return 0;\n}\n```\n\n\n\n对于二维数组来说，可以按照一维数组来访问，当然也可以按照二维数组来访问\n\n```c++\n&a[0][0] == a[0]\n&b[0] == b // 对于二维数组也同样适用\n```\n\n\n\n下面的q就是一个指向大小为3的数组的指针，其类型和a的第一个维度相同，因此可以直接赋值\n\n**使用指针++的形式效率更高（inc指令，只要一条指令即可）**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int a[2][3] = {1,2,3,4,5,6};\n    // 或者 &a[0][0]\n    int *p = a[0];\n    for(int i = 0; i < 6; i++){\n        // 输出 1 2 3 4 5 6\n        // 可以越界访问，但是输出是随机值\n        cout << *(p++) << endl;\n    }\n    int (*q)[3] = a;\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 3; j++){\n            cout << q[i][j] << endl;\n        }\n    }\n    return 0;\n}\n```\n\n\n\n计算偏移量访问：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int a[2][3] = {1,2,3,4,5,6};\n    // 或者 &a[0][0]\n    int *p = a[0];\n\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 3; j++){\n            // 一维指针计算偏移量\n            cout << *(p + 3*i + j) << endl;\n        }\n    }\n\n    int (*q)[3] = a;\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 3; j++){\n            // 二维指针计算偏移量\n            cout << *(*(q + i) + j) << endl;\n        }\n    }\n    return 0;\n}\n```\n\n\n\n对数组名使用sizeof得到的是整个数组的大小\n\n如果将指针名赋值给一个int，sizeof得到的是指针大小而不是数组大小\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int *p = nullptr;\n    // 输出8\n    // 运行时该编译器默认指针长度为8\n    cout << sizeof(p) << endl;\n\n    int a0[10] = {0};\n    // 输出40\n    // 40 = 4 * 10\n    cout << sizeof(a0) << endl;\n    // 输出8\n    // a0+1为指向第二个元素的指针，长度为8\n    cout << sizeof(a0+1) << endl;\n\n    int a[2][3] = {1,2,3,4,5,6};\n    // 输出24\n    // 24 = 2 * 3 * 4\n    cout << sizeof(a) << endl;\n    // 输出8\n    // a+1指向的类型为int (*)[3]\n    // 是一个指针，因此长度为 8（int *的长度为8）\n    cout << sizeof(a+1) << endl;\n\n    // 输出8\n    // 尽管指向的位置和a0相同\n    // 但是sizeof得到的是q（指针）的大小\n    int *q = a0;\n    cout << sizeof(q) << endl;\n    return 0;\n}\n```\n\n\n\n#### 降维\n\n通过取地址就可以完成\n\n可以让二维数组使用一维数组的接口：\n\n![image](https://s2.ax1x.com/2019/12/22/QzqijS.png)\n\n\n\n#### 升维\n\n需要借助typedef或者用强制类型转换\n\n```c++\n#include <iostream>\nusing namespace std;\n\nvoid show(int a[], int n){\n    for(int i=0;i<n;i++)\n        cout << a[i] << \" \" << endl;\n    cout << endl;\n};\n\nvoid show(int a[][2], int n){\n    for (int i=0;i<n;i++)\n        for (int j=0;j<2;j++) {\n                cout << *(a+i)+j << \":\"\n                     << a[i][j] << \" \";\n                // 每输出4个值就换行     \n                if ((i*2+j+1)%4 == 0) cout << endl;\n        }\n        cout << endl;\n};\n\nvoid show(int a[][2][3], int n){\n    for (int i=0;i<n;i++)\n        for (int j=0;j<2;j++) \n            for (int k=0;k<3;k++){\n                cout << *(*(a+i)+j)+k << \":\"\n                     << a[i][j][k] << \" \";\n            if ((i*6+j*3+k+1)%4 == 0) cout << endl;\n            }\n            cout << endl;\n};\n\n\nint main(){\n    int b[12];\n    for (int i=0;i<12;i++) b[i] = i+1;\n    show(b,12);\n    typedef int T[2]; \n    show( ( T *) b,6);\n    // 等价形式，注意括号\n    show( ( int (*)[2]) b,6);\n    typedef int A[3]; \n    typedef A B[2]; \n    show((B *) b,2);\n    // 等价形式，注意括号\n    show( ( int (*)[2][3]) b,2);\n    cout << endl;\n    return 0;\n}\n```\n\n\n\n### 多级指针\n\n如果是一个指针类型例如char *，那么取地址之后就是char **\n\n如果是一个数组名，例如 char p[5]，那么取地址之后就是char (*)[5]，而不是char **\n\n```c++\n#include <iostream>\nusing namespace std;\n\nvoid swap(char **p1, char **p2) { \n    char *tmp = *p1;\n    *p1 = *p2;\n    *p2 = tmp; \n};\n\nint main(){\n    // 报错，&p1的类型是char (*)[5]\n    // char p1[] = \"abcd\"; \n    // char p2[] = \"1234\";\n    char *p1 = \"abcd\";\n    char *p2 = \"1234\";\n    // 可以正确交换\n    cout << p1 << \" \" << p2<<endl; \n    swap( &p1,&p2 ); \n    cout << p1 << \" \" << p2<<endl; \n    return 0;\n}\n```\n\n\n\n正确的版本：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nvoid swap(char *&p1, char *&p2) { \n    char *tmp = p1;\n    p1 = p2;\n    p2 = tmp; \n};\n\nvoid f(char *c){}\n\nint main(){\n    // 可以正确交换\n    char p1[] = \"abcd\"; \n    char p2[] = \"1234\";\n    cout << p1 << \" \" << p2<<endl; \n    swap( p1,p2 ); \n    cout << p1 << \" \" << p2<<endl; \n    return 0;\n}\n```\n\n注意指针名并不是const，它是可以交换的！！！\n\n\n\n## 可变参数\n\n![image](https://s2.ax1x.com/2019/12/23/lSML7D.png)\n\n第一个的参数的地址是必须提供的，也就是可变参数必须至少包含一个参数，这个参数用来寻址，实现对所有参数的访问\n\n\n\n### printf\n\n主要是理解三个宏：\n\n![image](https://s2.ax1x.com/2019/12/23/lSMXAe.png)\n\n\n\n因为是以32位对齐，所以可变参数部分需要实现以int的长度为单位的向上取整，即_INTSIZEOF(x)\n\n使用：\n\n![image](https://s2.ax1x.com/2019/12/23/lSQENQ.png)\n\nmarker的类型是char*，每次+都只增加一个内存单元\n\n\n\n## 动态变量\n\nmalloc返回void *，需要类型转化\n\n如果返回null则说明申请失败\n\n\n\n和new的区别就是\n\n1. new调用构造函数\n2. new返回的是有类型的指针\n3. new可以重载，让内存分配更加合理\n4. new如果失败会抛出bad_alloc异常\n\n\n\n返回的指针仍然是在栈中\n\n\n\nnew一个数组：\n\n多维数组可以升维得到\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    // 申请一维数组\n    int *p = new int[10];\n    // 然后类型转换\n    int (*p2)[5] = (int (*)[5])p;\n    for (int i=0;i<10;i++) p[i] = i+1;\n    for (int j=0;j<2;j++){ \n        for (int k=0;k<5;k++)\n            cout << p2[j][k] << \" \"; \n        cout << endl;\n    }\n    return 0;\n}\n```\n直接得到多维数组：\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    // 先定义一个中间类型\n    typedef int i5Array[5];\n    // 然后直接申请得到二维数组\n    i5Array* p = new i5Array[2];\n    for (int j=0;j<2;j++)\n        for (int k=0;k<5;k++)\n            p[j][k] = (j*5)+(k+1);\n    return 0;\n}\n```\n\n\n\n### 归还\n\nnew 对应 delete\n\n如果是数组，那么要用delete []\n\n实现的机制是\n\n在返回地址的上面一个地址记录申请到的size，所以返回的指针不能动，不然不能正确free\n\n```\nA *p = new A[10]\n如果是delete p\n只会调用一个析构函数\n但是如果是delete[] p\n会调用所有的析构函数\n\n如果是int的话就没区别，上面的区别是针对类的\n```\n\n\n\nmalloc 对应 free\n\n\n\n## 链表\n\n### 结点定义\n\n![image](https://s2.ax1x.com/2019/12/23/l9CaBn.png)\n\n### 插入操作\n\n表头插入需要判断表头是否为空，分为两种情况讨论\n\n![image](https://s2.ax1x.com/2019/12/23/l9Co9O.png)\n\n表为插入要求head非空\n\n找到next为null的节点，将next赋值\n\n![image](https://s2.ax1x.com/2019/12/23/l9CjEt.png)\n\n某个值的节点后面插入\n\n从head开始搜索，只要不是null，就判断值是否是a（短路表达式），一直循环下去\n\n循环外要判断是否为null\n\n![image](https://s2.ax1x.com/2019/12/23/l9Psat.png)\n\n某个值前面插入\n\n因为是单向链表，需要记录前一个节点（guard node）\n\n![](https://s2.ax1x.com/2019/12/23/l9iKFP.png)\n\n### 删除操作\n\n如果使用next来判断的话比较简单，不用保存前一个节点用于连接（见有序链表）\n\n否则要保存前一个节点用来连接\n\n![](https://s2.ax1x.com/2019/12/23/l9iaF0.png)\n\n\n\n### 有序链表\n\n基本结构：\n\n![](https://s2.ax1x.com/2019/12/23/l9iBSU.png)\n\n插入：\n\n类似于在节点后插入（简单一点，不用guard node）\n\n![](https://s2.ax1x.com/2019/12/23/l9FVpT.png)\n\n删除操作：\n\n使用next判断比较简单\n\n![](https://s2.ax1x.com/2019/12/23/l9kp8K.png)\n\n\n\n要特别注意指针操作：\n\n![](https://s2.ax1x.com/2019/12/23/l9FUnH.png)\n\n## 引用\n\n引用变量时必须要有初始化\n\n\n\n引用要保持类型相同，例如指针的引用仍然要是指针\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int *p = new int;\n    int *&x = p;\n    cout << *x << endl;\n    return 0;\n}\n```\n\n\n\n![image](https://s2.ax1x.com/2019/12/23/l9eaDS.png)\n\n\n\n非const引用不能引用一个非左值\n\n```c++\nint main(){\n    // 错误\n    // int &p = 1;\n    // 正确\n    const int &p = 1;\n    return 0;\n}\n```\n\n\n\n如果函数返回值的类型是引用或指针类型，则不应把局部变量或局部变量的地址作为返回值返回。因为函数退出的时候会将栈破坏掉，局部变量都不会保留下来\n\n注意如果传入数组，返回数组中元素的引用，那是可以的\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint &max3(int x[], int num) { \n    int i, j;\n    j = 0;\n    for (i=1; i<num; i++)\n        if (x[i] > x[j]) j = i; \n    return x[j];\n}\n\nint main(){\n    int a[] = {1,2};\n    cout << max3(a, 2) << endl;\n    return 0;\n}\n```\n\n由于返回的是引用，甚至可以 max3(xxx, 2) = 100;\n\n\n\n对于指针来说也一样：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint * max2(int x[], int num) { \n    int *p,*q;\n    p = x; q = x+1; \n    while (num > 1){ \n        if (*q > *p) p = q;\n        q++; num--; \n    }\n    return p; \n}\n\nint main(){\n    int a[] = {1,2};\n    cout << *max2(a, 2) << endl;\n    return 0;\n}\n```\n\n\n\n释放堆中变量的引用\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main(){\n    int *p = new int(100);\n    int &x = *p;\n    cout << x << endl;\n    // 这里要取地址\n    delete &x;\n    return 0;\n}\n```\n\n","tags":["c++"],"categories":["c++"]},{"title":"C++学习笔记（四）","url":"/2019/12/17/C-学习笔记（四）/","content":"\n# 类继承\n\n## 成员函数\n\n两种成员函数\n\n1. 基类希望其派生类进行覆盖的函数，这一种函数是虚函数，当我们使用指针或引用调用虚函数时，该调用将被动态绑定，根据应用或指针所绑定的对象类型的不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数\n2. 基类不希望派生类进行覆盖的函数，这一类函数为非虚函数\n\n注意，如果派生类没有覆盖基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本\n\n\n\n## 类型转化\n\n派生类对象包含多个组成部分：含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的对象也有多个\n\n![image](https://s2.ax1x.com/2019/12/17/QoLJHg.png)\n\n## 派生类构造函数\n\n尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分\n\n派生类构造函数同样是铜鼓哦构造函数初始化列表来将实参传递给基类构造函数的\n\n\n\n## 静态类型和动态类型\n\n静态类型是在编译时就确定了的\n\n动态类型这是在变量或表达式表示的内存中的对象的类型，运行时才可知\n\n如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致\n\n用dynamic_cast请求类型转换，该转换的安全检查将在运行时执行\n\n用static_cast来强制覆盖掉编译器的检查工作，在编译期间就使得类型转化了\n\n\n\n## 虚函数\n\n引用或者指针调用一个函数的时候\n\n1. 如果说非虚函数，那么编译时期就可以确定\n2. 如果是虚函数，那么要到运行时刻才可以确定\n\n通过对象调用的函数编译时就可以确定，因为对象的类型是确定不变的（静态类型等于动态类型）\n\n虚函数一定要有定义，即使没有被用到；其他函数如果没有被用到，不需要给出定义\n\n\n\n### override\n\n这个关键字可以让编译器检查是否真的覆盖了虚函数\n\noverride关键字只能修饰虚函数\n\n\n\n### final\n\n如果被final修饰，那么将不能被覆盖\n\n只有虚函数才能被定义为final\n\n\n\n### 默认参数\n\n虚函数的默认参数是静态绑定的\n\n即如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也还是如此\n\n\n\n## 纯虚函数\n\n书写=0就可以将一个虚函数说明为纯虚函数\n\n含有纯虚函数的类是抽象类\n\n抽象类不能实例化\n\n派生类必须给出纯虚函数的实现，否则仍然是抽象类\n\n\n\n## 访问控制\n\n### protected\n\n与派生类分享，但是不会被其他类公共访问，可以看作是public和private中和后的产物\n\n派生类的成员或友元只能通过派生类对象来访问基类的受保护成员\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Father{\nprotected:\n    int a;\n    void g(){}\n};\n\nclass Son:public Father{\npublic:\n    // 子类不能直接访问父类中的protected成员或是方法\n    // 只能通过他的子类来使用\n    // void f(Father f){cout << f.a << endl;}\n    void f(Son s){cout << s.a << endl;s.g();}\n};\n\nint main(){\n    return 0;\n}\n```\n\n\n\n### 派生列表中的访问说明符\n\n派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么印象，对基类成员的访问权限只与积累中的访问说明符有关\n\n派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限\n\n\n\n## 类型转化\n\n对于代码中的某个节点来说，如果积累的公有成员是可访问的，则派生类向基类的类型转化也是可访问的；反之则不行\n\n例如：\n\n1. 如果是私有继承，那么用户代码不能使用派生类向基类的转化\n2. 无论D以什么方式继承B，D的成员函数和友元都可以使用派生类向基类的转化\n3. 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的转换\n\n\n\n## 友元和继承\n\n友元关系不能传递，不能继承\n\n基类的友元在访问派生类成员时不具有特殊性；派生类的友元也不能随意访问基类的成员\n\n每个类负责控制自己的成员的访问权限，因此如果基类定义了友元，那么这个友元可以访问之类中的基类部分，即使这一部分之类都无法访问，例如：\n\n```c++\nclass Father{\nprivate:\n    int father;\nprotected:\n    friend class F;\n};\n\nclass Son:public Father{\nprivate:\n    int son;\npublic:\n    void f(Son s){}\n};\n\nclass F{\npublic:\n    // F是父类的友元，因此可以访问Son中的Father的私有部分\n    // 尽管这一部分是Son都不能访问的\n    void f(Son s){cout << s.father << endl;}\n};\n```\n\n\n\n## 继承中的类作用域\n\n如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找改名字的定义\n\n### 在编译时就进行名字查找\n\n一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的，我们能使用哪些成员仍然是由静态类型决定的\n\n\n\n### 名字冲突与继承\n\n派生类的成员将隐藏同名的基类成员（因为在当前作用域中就已经找到了名字，就不会再去基类找了）\n\n可以通过using来使用一个被隐藏的基类成员\n\n![image](https://s2.ax1x.com/2019/12/18/QTfG6J.png)\n\n\n\n### 查找顺序\n\n![image](https://s2.ax1x.com/2019/12/18/QTfDpD.png)\n\n\n\n### 名字查找优先于类型检查\n\n即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉\n\n一旦名字找到，编译基就不再继续查找了，因此如果之类中有同名（只是同名，参数不一定相同）函数，就会覆盖掉基类中的所有同名函数\n\n\n\n### 虚函数的调用\n\n![image](https://s2.ax1x.com/2019/12/18/QThauj.png)\n\n![image](https://s2.ax1x.com/2019/12/18/QThyCT.png)\n\n![image](https://s2.ax1x.com/2019/12/18/QThDU0.png)\n\n\n\n### 覆盖重载的函数\n\n如果子类中有了一个同名的函数，那么基类中的所有函数都会被覆盖\n\n如果想继承所有的函数，但是只是覆盖掉其中几个，可以用using语句\n\n```c++\nclass Father{\npublic:\n    void f(){cout << \"Father f()\" << endl;}\n    void f(int){cout << \"Father f(int)\" << endl;}\n};\n\nclass Son:public Father{\npublic:\n    using Father::f;\n    void f(){cout << \"Son f()\" << endl;}\n};\n\n\nint main(){\n    Son s;\n    s.f();\n    // 使用了using就可以继承父类的所有同名方法了\n    // 只会覆盖掉其中子类自定义的版本\n    s.f(1);\n    return 0;\n}\n```\n\n\n\n## 构造函数与拷贝控制以及析构函数\n\n无论是合成的默认构造函数，还是拷贝构造函数，还是赋值运算符，还是析构函数，它们除了负责自己的那一部分，还要负责直接基类中的那一部分的对应行为\n\n因此如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问的函数，则派生类中对应的成员是被删除的，因为编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或者销毁操作\n\n\n\n### 析构函数\n\n基类的析构函数一般要定义成虚函数，这样就可以动态调用到子类的析构函数，正确释放资源\n\n析构函数和其他不同，只要负责自己销毁，因为会自动调用父类的析构进行销毁，但是例如构造函数、拷贝控制，都要现式写明调用情况或是拷贝的情况。\n\n即子类的析构函数只要析构自己就行了，不用再写任何其他的代码\n\n```c++\nclass A{\npublic:\n    ~A(){cout << \"Father's ~\" << endl;}\n};\n\nclass B:public A{\npublic:\n    ~B(){cout << \"Son's ~\" << endl;}\n};\n\nint main(){\n    B b;\n    // 输出为\n    // Son's ~\n    // Father's ~\n    return 0;\n}\n```\n\n\n\n### 构造函数\n\n之前已经看到过了，如果要使用基类的特定构造函数，要显式写明\n\n下面是调用拷贝构造函数和其他构造函数的写法：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    int a;\n    A(){cout << \"A's A()\" <<endl;}\n    A(int a):a(a){cout << \"A's A(int)\" << endl;}\n    A(const A& a){cout<<\"A's copy constructor\"<<endl;}\n};\n\nclass B: public A{\npublic:\n    B(){}\n    // 指定调用父类的某个构造函数\n    B(int a):A(a){}\n};\n\nclass C:public A{\npublic:\n    C(){}\n    C(const C& c){ cout << \"C's copy constructor\"<<endl;}\n};\n\nclass D:public A{\npublic:\n    D(){}\n    D(const D& d):A(d){ \n        cout << \"D's copy constructor\"<<endl;\n    }\n};\n\nint main(){\n    // 如果子类没有指明调用父类的哪个构造函数\n    // 那么调用默认构造函数\n    B b0;\n    B b(100);\n    cout << endl;\n    // 如果子类没有自己定义拷贝构造函数\n    // 那么会自动调用父类的拷贝构造函数\n\n\n    // 使用子类合成拷贝构造函数\n    // 将调用父类的拷贝构造函数\n    B b2(b);\n    cout << endl;\n\n    // 如果子类自定义了拷贝构造函数\n    // 而没有指定基类部分如何拷贝\n    // 那么默认掉用父类的默认构造函数\n    C c;\n    C c2(c);\n    cout << endl;\n\n    // 如果在初始化列表中指明调用了基类的拷贝构造函数\n    // 那么会正确拷贝基类部分\n    D d0;\n    D d1(d0);\n    return 0;\n}\n```\n\n析构函数的执行顺序和构造函数相反：派生类的析构函数首先执行，然后是基类的析构函数；基类的构造函数先执行，然后是派生类的构造函数\n\n\n\n### 拷贝控制\n\n合成的拷贝控制成员负责本类的赋值操作，还要负责直接基类中对应的操作。即要负责直接基类部分的复制\n\n上面已经看了拷贝构造函数的写法，下面看赋值运算符的写法\n\n同样也要显式写出：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    A& operator=(A& a){ cout << \"A's =\" << endl;return *this;}\n};\n\nclass B:public A{\npublic:\n    B & operator=(B& a){ cout << \"B's =\" << endl;return *this;}\n};\n\nclass C:public A{\npublic:\n    C & operator=(C& a){ \n        // 注意写法\n        A::operator=(a);\n        cout << \"C's =\" << endl;return *this;\n    }\n};\n\nint main(){\n    // 默认不会调用基类的赋值操作\n    // 因此不会拷贝基类部分\n    B b1;\n    B b2;\n    b1 = b2;\n    cout << endl;\n\n    // 需要显式写出调用基类的赋值运算符\n    C c1;\n    C c2;\n    c1 = c2;\n    return 0;\n}\n```\n\n注意这里调用赋值运算符的特殊写法\n\n上面传递给基类的赋值运算符的时候，基类只会释放掉基类部分的空间，并且进行赋值，因此不会有问题\n\n无论基类的构造函数或赋值运算符是定义一的还是合成的，派生类的对应操作都能使用它们\n\n\n\n### 番外：在构造函数和析构函数中调用虚函数\n\n执行虚构的时候，部分已经被销毁\n\n执行构造的时候，还未完成对象创建\n\n为了能够正确处理这种未完成状态，编译器认为对西那个的类型在构造或析构的过程中反复发生了改变一样（即类型是不确定的，按照当前构造或是析构的程度来确定当前的状态）\n\n也就是说，当我们构建一个对象时，需要把对象的类和构造函数的类看作是同一个：对虚构函数的调用绑定真好符合这种把对象的类和构造函数的类看成同一个的要求，对析构函数也是同样的道理\n\n上述绑定不但对直接调用虚函数有效，对间接调用也是有效的\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass A{\npublic:\n    A(){f();}\n    virtual void f(){cout << \"A's f()\"<<endl;}\n    virtual ~A(){f();}\n};\n\nclass B:public A{\npublic:\n    void f(){cout << \"B's f()\"<<endl;}\n};\n\nint main(){\n    // 无论是构造过程还是析构过程\n    // 调用的都是A的f()\n    // 因为到A的时候\n    // 1. B还没有构造\n    // 2. B已经析构\n    // 因此调用的都是A的f\n    B b;\n    return 0;\n}\n```\n\n\n\n## \"继承\"构造函数\n\n类不能继承默认、拷贝和移动构造函数，因为编译器会为派生类合成默认的\n\n和\"继承\"别的函数一样，使用using即可，不过using完了之后，其他函数是直接照搬过来，但是对于构造函数，编译器会稍作修改\n\n![image](https://s2.ax1x.com/2019/12/18/QTqAUJ.png)\n\n还有一个区别就是，普通函数的using可以改变访问级别，例如我在private里面using，那么\"继承\"下来的函数就会是private的，但不是构造函数不一样，基类的私有构造函数在派生类中还是一个私有构造函数，而不管using出现在哪\n\n\n\n![image](https://s2.ax1x.com/2019/12/18/QTqBVg.png)\n\n![image](https://s2.ax1x.com/2019/12/18/QTqIIJ.png)\n\n\n\n## 容器与继承\n\n容器内要放同一个类型的对象\n\n不能放基类，否则会被切片\n\n因此要放指针\n\n\n\n当容器深拷贝时，不能直接push指针（否则就是浅拷贝），因此需要将一个clone函数处理成虚函数，这样就可以根据类型动态调用深拷贝\n\n对于数组来说，下标运算符其实是指针的偏移，而指针的偏移是按照静态类型来计算的，因此不要把数组看作是多态的\n\n![image](https://s2.ax1x.com/2019/12/18/QTXkVS.png)","tags":["c++"],"categories":["c++"]},{"title":"C++学习笔记（三）","url":"/2019/12/17/C-学习笔记（三）/","content":"\n# 拷贝赋值和销毁\n\n## 拷贝构造函数\n\n形式：\n\n![image](https://s2.ax1x.com/2019/12/17/QIVR9f.png)\n\n即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数\n\n合成的拷贝构造函数的默认行为：对于类类型的成员，会使用其拷贝构造函数来拷贝，内置类型直接拷贝，对于数组，一个一个拷贝数组类型的成员，如果数组类型是类类型，则使用元素的拷贝构造函数来进行拷贝。注意以上的拷贝为浅拷贝\n\n\n\n### 调用时机\n\n![image](https://s2.ax1x.com/2019/12/17/QIVXgU.png)\n\n\n\n## 拷贝赋值运算符\n\n形式：\n\n```c++\nclass Foo {\npublic:\n  Foo& operator=(const Foo&);\n}\n```\n\n通常应该返回一个指向其左侧对象的引用\n\n\n\n### 合成拷贝赋值运算符\n\n与拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为生成一个合成拷贝构造函数。行为和合成的拷贝构造函数一样\n\n\n\n## 析构函数\n\n与构造函数相反，销毁对象的非static数据成员\n\n\n\n### 形式\n\n```c++\nclass Foo {\npublic:\n  \t~Foo();\n}\n```\n\n\n\n### 合成析构函数\n\n如果没有定义自己的析构函数，那么会合成一个析构函数，默认函数体为空。析构函数体自身并不直接销毁成员。成员是在析构函数之后隐含的析构阶段中被销毁的，整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的\n\n\n\n## 三五法则\n\n![image](https://s2.ax1x.com/2019/12/17/QIe1oR.png)\n\n\n\n## =default\n\nhttps://stackoverflow.com/questions/6502828/what-does-default-mean-after-a-class-function-declaration\n\n```c++\nclass C {\n  C(const C&) = default;\n  C(C&&) = default;\n  C& operator=(const C&) & = default;\n  C& operator=(C&&) & = default;\n  virtual ~C() { }\n};\n```\n\n只能对具有合成版本的成员函数使用=default，来显式地要求编译器生成合成的版本\n\n\n\n## 阻止拷贝\n\n阻止拷贝行为，因为对于有些类来说拷贝没有意义，例如io\n\n\n\n### 定义删除的函数\n\n=delete关键字表明不希望定义这些成员\n\n但是注意析构函数不能是删除的成员，因为如果析构函数被喊出，就无法销毁此类型的对象了，但是可以动态分配这种类型的对象，只是无法释放\n\n\n\n### private\n\n通过将拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝\n\n\n\n## 自我赋值\n\n自我赋值处理不当可能会导致内存泄漏，正确的处理自我赋值的情况：\n\n![image](https://s2.ax1x.com/2019/12/17/QImrB4.png)\n\n![image](https://s2.ax1x.com/2019/12/17/QImfgK.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["c++"],"categories":["c++"]},{"title":"C++学习笔记（二）","url":"/2019/12/16/C-学习笔记（二）/","content":"\n# 模板\n\n两种：类属函数，类属类\n\n\n\n## 类属函数\n\n同一函数对不同类型的数据完成相同的操作\n\n宏实现的缺陷：\n\n1. 只能实现简单的功能\n2. 没有类型检查\n\n函数重载的缺陷：\n\n1. 需要定义的重载函数太多\n2. 定义不全\n\n函数指针：\n\n![image](https://s2.ax1x.com/2019/12/16/Q5Pwxs.png)\n\n\n\n1. 需要定义额外参数\n2. 大量指针运算\n3. 实现起来复杂\n4. 可读性差\n\n\n\n这就是template引入的目标：完全，清晰\n\n![image](https://s2.ax1x.com/2019/12/16/Q5Pfz9.png)\n\nT类型只要符合：重载>操作符，有=操作符（默认有），有拷贝构造函数（默认有）（尽量使用const &的方式，可以避免使用拷贝构造）。\n\n\n\n函数模版在编译的时候会根据传入的类型生成另一段代码，即编译系统自动实例化函数模板\n\n\n\n函数模板的参数可以是普通参数，不过调用的时候需要显式实例化，例如：\n\n![image](https://s2.ax1x.com/2019/12/16/Q5PvQA.png)\n\n\n\n调用顺序：\n\n1. 调用非模板函数\n2. 模板的显式化版本\n3. 调用模板\n\n\n\n其中模板的显式化版本的意思是 https://zh.cppreference.com/w/cpp/language/template_specialization\n\n对于某个模板，可以直接给定它的类型，将其实例化\n\n例如：\n\n显式特化必须出现在非特化模板声明后\n\n```c++\ntemplate<class T> class X { /*...*/ }; // 主模板\ntemplate<> class X<int> { /*...*/ }; // 同命名空间中的特化\ntemplate<class T> class Y { /*...*/ }; // 主模板\ntemplate<> class Y<double>; // 对 double 特化的前置声明\n```\n\n当特化函数模板时，若能从函数实参予以提供，则可忽略其实参：\n\n\n```c++\ntemplate<class T> class Array { /*...*/ };\ntemplate<class T> void sort(Array<T>& v); // 主模板\ntemplate<> void sort(Array<int>&); // 对 T = int 的特化\n// 不需要写为\n// template<> void sort<int>(Array<int>&);\n```\n\n\n\n## 类属类\n\n类属类必须显式实例化，因为类要做检查，例如push的时候就要保证每次push的都是同一个类型\n\n![image](https://s2.ax1x.com/2019/12/16/Q5FWuR.png)\n\n类模板中的静态成员属于实例化后的类而不是模板\n\n是否实例化模板的某个实例由使用点来决定；如果未使用到一个模板的某个实例，则编译系统不会生成相应实例的代码\n\n\n\nn如果在模块A中要使用模块B中定义的某模板的实例，而在模块B中未使用这个实例，则模块A无法使用这个实例（因为并没有生成对应代码）\n\n\n\n模板元编程\n\n![image](https://s2.ax1x.com/2019/12/16/Q5A201.png)\n\n\n\n# 异常处理\n\n常见处理方法：\n\n1. 函数参数（返回值或引用参数）\n2. 逐层返回\n\n缺点：程序结构不清楚\n\n\n\n## 类型转化\n\n*比重载严格，需要精确匹配*\n\n*只有三种情况可以转化：*\n\n*除了非**const**到**const*\n\n*从派生类到基类*\n\n*从数组或函数到指向数组或函数的指针*\n\n\n\n## 静态编译\n\n下面的代码的输出为\n\nderived f()\nBase\nbase f()\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass BaseException{\npublic:\n    int a;\n    BaseException():a(1){}\n    virtual void f(){cout << \"base f()\" << endl;}\n};\n\nclass DerivedException: public BaseException{\npublic:\n    int a;\n    DerivedException():a(100){}\n    void f(){cout << \"derived f()\" << endl;}\n};\n\nvoid f(){\n    DerivedException e;\n    throw e;\n};\n\nint main(){\n    try{\n        try{\n            f();\n            // 引用和切片的区别在于这个catch里面能否获得动态绑定的类型\n            // 抛出的时候都是基类（编译类型）\n        }catch(BaseException& a){\n            a.f();\n            throw a;\n        }\n    }catch(DerivedException a){\n        cout << \"Derived\" << endl;\n        a.f();\n    }\n    catch(BaseException a){\n        cout << \"Base\" << endl;\n        a.f();\n    }\n    return 0;\n}\n```\n\n\n\n# RAII\n\n资源获得即初始化，解决多出口、碎片问题\n\n例子：智能指针\n\n如下：\n\n![](https://s2.ax1x.com/2020/01/06/ly6hy8.png)\n\n\n\n# 非虚接口解决打印问题\n\n如果父类有打印的全局函数，想要子类也有自己的打印函数，可以再写一个，但是解决不了\n\n```c++\nFather &f = son;\ncout << f << endl;\n```\n\n因此需要用到非虚接口\n\n即在父类中写一个虚函数（子类有自己的版本），通过该虚函数可以调用到不同的版本的打印\n\n然后再重载操作符，非虚函数调用虚函数\n\n![](https://s2.ax1x.com/2020/01/06/lyc31P.png)\n\n\n\n# 原型模式解决复制问题\n\n用了一个父类的指针，又要具体的子类复制\n\n![](https://s2.ax1x.com/2020/01/06/lycD10.png)\n\n![](https://s2.ax1x.com/2020/01/06/lyc6nU.png)\n\n\n\n# 不要把数组处理成多态\n\n指针偏移会有问题，偏移量是静态编译计算好的，如果说子类的大小和父类一样，那么没有问题，否则不能正确偏移\n\n![](https://s2.ax1x.com/2020/01/06/lycWN9.png)\n\n","tags":["c++"],"categories":["c++"]},{"title":"操作系统PV问题汇总","url":"/2019/12/08/操作系统PV问题汇总/","content":"\n# 哲学家就餐问题\n\n![image](https://s2.ax1x.com/2019/12/08/QaQrmd.png)\n\n# 生产者-消费者问题\n\n![image](https://s2.ax1x.com/2019/12/08/QaldNq.png)\n\n![image](https://s2.ax1x.com/2019/12/08/QalrgU.png)\n\n生产者消费者问题中empty和full总是交替出现，和为定值，即为缓冲区大小\n\n\n\n# 读者-写者问题\n\n![image](https://s2.ax1x.com/2019/12/08/Qa1VP0.png)\n\n![image](https://s2.ax1x.com/2019/12/11/QsOYLT.png)\n\n上述方案不限制同时读的读者数量，可以在开头和结尾加入有初始值的P和V来限制同时读取的读者的数量\n\n\n\n# 理发师问题\n\n![image](https://s2.ax1x.com/2019/12/08/Qa1OL4.png)\n\n![image](https://s2.ax1x.com/2019/12/11/QsLTZF.png)\n\n必须要比较大小，不能用另一个PV操作来实现，因为人满了之后顾客要离开，而不是继续排队等待椅子\n\n\n\n# 前驱关系\n\n如果各个程序之间有前驱和后继的先后执行顺序关系，那么可以用PV操作来表达\n\n![image](https://s2.ax1x.com/2019/12/14/QRs7Bn.png)\n\n设置6个初始值为0的信号量，在此进程之前必须要完成的进程用P，此进程之后才能开始的进程用V\n\n![image](https://s2.ax1x.com/2019/12/14/QRypu9.png)\n\n\n\n\n\n# Reference\n\n1. 《操作系统教程（第五版）》--高等教育出版社出版","tags":["操作系统"],"categories":["操作系统"]},{"title":"C++学习笔记（一）","url":"/2019/12/06/C-学习笔记（一）/","content":"\n# 运算符重载\n\n## 条件\n\n不能重载内置类型的操作符，因此至少有一个运算分量是自定义类型\n\n\n\n## 分类\n\n从重载的形式来看：\n\n1. 作为成员函数重载\n2. 作为全局函数重载\n\n其中，如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的thi指针上\n\n\n\n从运算分量的数目来看：\n\n1. 单目\n2. 双目\n\n其中对于二元运算来说，左侧运算对象传递给第一个参数，而右侧对象传递给第二个参数\n\n\n\n## 不能被重载的操作符\n\n![image](https://s2.ax1x.com/2019/12/06/QYkIht.png)\n\n四个操作符不能被重载\n\n\n\n## 不推荐被重载的操作符\n\n逗号、取地址、逻辑与和逻辑或运算符\n\n因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。\n\n除此之外，&&和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值\n\n还有一个原因使得我们一般不重载逗号运算符和取地址运算符：C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应\n\n\n\n## 基本原则\n\n遵循原有的语法：单目/双目、优先级、结合性\n\n\n\n## 选择成员还是非成员重载\n\n![image](https://s2.ax1x.com/2019/12/06/QYAWvT.png)\n\n对于第一条：\n\n原因是：编译器如果遇到内置类型作为运算分量的操作符，那么无法识别，会先去类内找有无重载版本，然后再在全局找有无重载版本，这四个函数有内部合成的函数，例如=对应的是赋值操作，类内已有合成的默认行为，因此如果是全局重载，编译器根本不会找到，优先找类内部的重载版本\n\n\n\n一个错误的示例：\n\n![image](https://s2.ax1x.com/2019/12/06/QYEFRP.png)\n\n这里产生错误的原因是有一对矛盾冲突：即类内操作符重载要求第一个参数必须是本类本对象的this指针，而双目运算要求第一个参数是必须是双目操作符左边的运算分量\n\n同样的一个例子是<<操作符的重载版本只能是全局重载\n\n\n\n## 双目操作符重载\n\n### 重载形式\n\n两种形式：\n\n![image](https://s2.ax1x.com/2019/12/06/QYEuIs.png)\n\n![image](https://s2.ax1x.com/2019/12/06/QYENdJ.png)\n\n全局函数重载，写成友元函数friend\n\n双目运算符为了支持对称调用，一般做如下处理\n\n![image](https://s2.ax1x.com/2019/12/06/QYEbwQ.png)\n\n\n\n### 返回值\n\n一般来说双目运算返回的是一个临时变量（右值）\n\n而单目运算符如果需要改变自身状态的话，返回引用（左值）\n\n\n\n### 返回值的编译优化\n\n一个例子：\n\n![image](https://s2.ax1x.com/2019/12/06/QYViTJ.png)\n\n\n\n## 单目操作符重载\n\n### 重载形式\n\n![image](/Users/cengshaoxun/Library/Application Support/typora-user-images/image-20191209213530405.png)\n\n## 例子和特殊例子\n\n### 输出运算符<<\n\n```c++\nclass A{\nprivate:\n    int a;\npublic:\n    A(int a):a(a){}\n    friend ostream& operator<<(ostream &os, const A& a);\n};\n\nostream& operator<<(ostream &os, const A& a){\n    os << a.a;\n    return os;\n}\n```\n\n第一个形参四一个非常量ostream对象的引用，因为要修改它的值\n\n第二个形参为常量引用\n\n返回的是ostream的引用，这样可以链式调用\n\n必须是非成员函数\n\n一般声明成friend友元\n\n\n\n### 输入运算符>>\n\n```c++\nclass A{\npublic:\n    int a;\n    friend istream& operator>>(istream &is, A& a);\n};\n\nistream& operator>>(istream &is, A& a){\n    is >> a.a;\n    return is;\n}\n```\n\n和<<运算符不同的是第二个形参是非const的，因为要改变它的值\n\n\n\n### 算数和关系运算符\n\n一般定义成非成员函数，这样可以对类型进行转化\n\n形参一般都是const，因为不需要改变值\n\n结果常常位于一个局部变量之内，返回该局部变量的副本作为结果\n\n\n\n#### ==运算符\n\n返回的是bool值\n\n```c++\nclass A{   \npublic:\n    int a;\n    friend bool operator==(const A& a1, const A& a2);\n};\n\nbool operator==(const A& a1, const A& a2){\n    return a1.a==a2.a;\n}\n```\n\n\n\n#### <运算符\n\n形式和和==基本上一样\n\n```c++\nclass A{   \npublic:\n    int a;\n    friend bool operator<(const A& a1, const A& a2);\n};\n\nbool operator<(const A& a1, const A& a2){\n    return a1.a<a2.a;\n}\n```\n\n\n\n#### +运算符\n\n这里不采用全局重载的形式，而是类内重载\n\n```c++\nclass A{\npublic:\n    int a;\n    const A operator+(const A& a) const;\n};\n\nconst A A::operator+(const A& a) const{\n    A ta;\n    ta.a = this->a;\n    ta.a += a.a;\n    return ta;\n}\n```\n\n形参为const &，返回类型为const，不需要引用\n\n末尾加上const，这样即使是const对象也可以调用\n\n\n\n如果要和内置类型做加法，那么可以这样写\n\n```c++\nclass A{\npublic:\n    int a;\n    A(){}\n    // 可以定义包含一个参数的构造函数\n    // 这样int可以自动转化成A对象\n    // 然后+函数为全局重载\n    // 这样无论int在前还是在后\n    // 都可以自动转化成A，然后调用该运算符\n    A(int a):a(a){}\n    friend A const operator+(const A& a1, const A& a2);\n};\n\nA const operator+(const A& a1, const A& a2){\n    A ta;\n    ta.a = a1.a;\n    ta.a += a2.a;\n    return ta;\n}\n```\n\n构造函数只有一个int参数，这样int就会自动转化成A类型，无论是在+前还是后，都可以正确计算\n\n也可以使用()类型转化运算符进行转化，如果()和只有一个参数的构造函数共存的时候，有可能会产生冲突，见下面的()运算符\n\n\n\n### +=运算符\n\n不是一定要类内重载，也可以全局重载\n\n```c++\nclass A{\npublic:\n    int a;\n    A& operator+=(const A& a);\n};\n\nA& A::operator+=(const A& a){\n    this->a += a.a;\n    return *this;\n}\n```\n\n\n\n\n\n### 前缀++和后缀++\n\n主要区别在返回值和参数上\n\n![image](https://s2.ax1x.com/2019/12/09/Q08Wfs.png)\n\n### 赋值操作符\n\n默认是浅拷贝\n\n例如如果对象在heap上有分配空间，拷贝的时候会指向同一块内存空间，那么就会导致一个对象析构的时候另一个对象的指针飞了\n\n但是就算重载了赋值操作，例如下面这段代码，如果是自我赋值的话，仍然会出现问题，因此还要避免自我赋值\n\n![image](https://s2.ax1x.com/2019/12/09/Q0JQr6.png)\n\n可以自我赋值的版本：\n\n```c++\nclass MString{\npublic:\n    string *p;\n    // 可以自我赋值的一种写法\n    MString& operator=(const MString& s){\n        // 临时拷贝底层的指针\n        string *ts = new string(*(s.p));\n        // 释放内存\n        delete p;\n        // 拷贝到自己\n        this->p = ts;\n        // 返回自己\n        return *this;\n    }\n};\n```\n\n接受的参数为const &，返回的是&\n\n注意四个步骤的顺序不能打乱，否则自我赋值会有问题\n\n\n\n### 下标运算符\n\n[]运算符只能在类内重载，不能作为全局函数重载\n\n一般都要重载两个版本（const的和非const的）\n\n非const版本返回引用，可以作为左值被修改\n\nconst版本的返回值可以不是引用\n\n![image](https://s2.ax1x.com/2019/12/09/Q0YWfH.png)\n\n多维数组的情况：\n\n如果是二维的数组，那么其实只要返回指针，第二次的[]操作其实用的是指针的[]\n\n如果是多维的数组，那么可以嵌套一个内部类\n\n如下：\n\n![image](https://s2.ax1x.com/2019/12/09/Q0UUk8.png)\n\n这样就可以实现多个维度的嵌套\n\n\n\n### ( )运算符\n\n只能是成员函数\n\n既是函数调用，也是类型转化（也可以通过带有一个参数的构造函数重载，然后直接赋值，同样也可以达到隐式转化的目的；两个转化的方向不同，一个是将本类转为其他——（）运算符，一个是将其他转为本类—— 构造函数）\n\n#### 作为类型转化操作符\n\n可以减少混合计算中需要定义的操作符重载函数的数量（也可以通过写成构造函数的形式，将传入的参数转为本类型）\n\n如下：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Rational { \npublic:\n    Rational(int n1, int n2) { n = n1; d = n2; } \n    // 重载构造函数也可以达到隐式类型转化的目的\n    Rational(double d){cout << \"constructor\" << endl;}\n    operator double() { cout << \"operator ()\" << endl; return  (double)n/d; }\n    // 可以和()共存，最佳匹配，直接匹配到这个函数\n    double operator+(double d){cout << \"operator +\" << endl; return d + n/d;}\n    // 当调用的时候有Rational+double的时候不能和()共存\n    // 因为都要进行类型转化，无法确定是调用这个函数，将double转为Rational，还是调用()，将Rational转为都变了\n    // 两个都可以转化，产生歧义\n    // 但是如果调用的情况是double+Rational，那么则可以，因为只能是Rational通过()运算符转化为double\n    // double operator+(Rational d){cout << \"operator +\" << endl; return 0;} \nprivate:\n    int  n, d;\n};\n\nint main(){\n    Rational  rr = 1.1;\n    Rational  r(1,2);  \n    // 调用()进行类型转化\n    double x = r;  \n    // 如果参数和operator +匹配的话那么优先调用operater +\n    // 否则调用()\n    x = r + x; \n    cout << x << endl;\n    return 0;\n}\n```\n\n#### 其他类型转化二义性冲突汇总\n\n可以看到上面这个例子中有潜在的冲突（见注释）\n\n还有一种冲突如下：\n\n```c++\nstruct B;\nstruct A{\n  A() = default;\n  A(const B&);  // B转化成A\n};\nstruct B{\n  operator A() const;  // B转化成A\n};\nA f(const A&e);\nB b;\nA a = f(b);  // 冲突，有两种转化方式！！！\n```\n\n上面代码中有两种B转化成A的方式，因此就存在二义性，会冲突\n\n\n\n还有一种冲突如下：\n\n```c++\nstruct A{\n  A(int = 0);\n  A(double);\n  operator int() const;\n  operator double() const;\n}\n\nvoid f2(long double);\nA a;\nf2(a);\n\nlong lg;\nA a2(lg);\n```\n\n当参数无法精确匹配的时候，且int转化为long double和double转化为long double转化的优先级一致，因此产生了冲突\n\n同样，初始化a2的时候，long转化为double和long转化为int也是没有优先级的，因此产生了错误\n\n如果有优先级，那么其实是可以的：\n\n```c++\nshort s = 42;\nA a3(s);\n```\n\n因为short优先转化成int，所以没问题\n\n\n\n还有一种冲突如下：\n\n```c++\nstruct C{\n  C(int);\n};\nstruct D{\n  D(int);\n}\n\nvoid manip(const C&e);\nvoid manip(const D&e);\nmanip(10);\n```\n\n两个函数都可以匹配\n\n\n\n#### 作为函数调用重载\n\n可以实现函数对象，在标准库中广泛使用\n\n![image](https://s2.ax1x.com/2019/12/09/Q00B5V.png)\n\n![image](https://s2.ax1x.com/2019/12/09/Q00fV1.png)\n\n![image](https://s2.ax1x.com/2019/12/09/Q00456.png)\n\n![image](https://s2.ax1x.com/2019/12/09/Q00bKH.png)\n\n函数对象也有局限性，即如果定义的接口是指针，那么不能传入函数对象，因为类型不同\n\n![image](https://s2.ax1x.com/2019/12/09/Q00XVI.png)\n\n于是可以使用function类型，这个类型的接口可以传入所有可调用类型\n\n![image](https://s2.ax1x.com/2019/12/09/Q0BpRS.png)\n\n但是有个缺点就是重载函数不行，还得用函数指针或是lambda对象\n\n![image](https://s2.ax1x.com/2019/12/09/Q0BPMQ.png)\n\n### -> 操作符\n\n![image](https://s2.ax1x.com/2019/12/16/Q5CwB6.png)\n\n智能指针\n\n![image](https://s2.ax1x.com/2019/12/16/Q5C7CQ.png)\n\n![image](https://s2.ax1x.com/2019/12/16/Q5Cqvn.png)\n\nNew有两个作用：不确定数目的情况下，用new动态新建对象；跨越作用域，全生命周期\n\n问题就是**new**出来的对象会跨越作用域，但是如果是如果包装成一个对象，那么就会失去长生命周期\n\n\n\n### new、delete\n\n![](https://s2.ax1x.com/2020/01/06/lyD4UI.png)\n\n![](/Users/cengshaoxun/Library/Application Support/typora-user-images/image-20200106225006478.png)\n\n![](https://s2.ax1x.com/2020/01/06/lyrURf.png)\n\n定位new：除了size有其他的参数，特殊版本就是：传入地址，在制定地址分配空间\n\nhttps://blog.csdn.net/zhangxiangDavaid/article/details/43899351\n\n需要定义一个对应的delete\n\nhttps://www.cnblogs.com/lidan/archive/2012/02/19/2358706.html\n\n\n\n","tags":["c++"],"categories":["c++"]},{"title":"我的日程安排表III","url":"/2019/11/27/我的日程安排表III/","content":"\n# 题目\n\n实现一个 MyCalendar 类来存放你的日程安排，你可以一直添加新的日程安排。\n\nMyCalendar 有一个 book(int start, int end)方法。它意味着在start到end时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start <= x < end。\n\n当 K 个日程安排有一些时间上的交叉时（例如K个日程安排都在同一时间内），就会产生 K 次预订。\n\n每次调用 MyCalendar.book方法时，返回一个整数 K ，表示最大的 K 次预订。\n\n请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n\n来源：力扣（LeetCode）\n\n链接：https://leetcode-cn.com/problems/my-calendar-iii\n\n\n\n# 思路\n\n区间覆盖问题\n\n一个区间的开始就加一下，表示进入一个区间\n\n一个区间的结束就减一下，表示离开一个区间\n\n用一个变量从头到尾遍历，路过的所有值都加上，过程中取最大值\n\n\n\n# 题解\n\n```c++\n#include <iostream>\n#include <map>\nusing namespace std;\n\nclass MyCalendarThree {\npublic:\n    map<int, int> record;\n    MyCalendarThree() {\n        \n    }\n    \n    int book(int start, int end) {\n        if(record.find(start) == record.end()){\n            record.insert(pair<int, int>(start, 1));\n        } else {\n            record[start]++;\n        }\n        if(record.find(end) == record.end()){\n            record.insert(pair<int, int>(end, -1));\n        } else {\n            record[end]--;\n        }\n        int ans = 0;\n        int t = 0;\n        for(auto p: record){\n            t += p.second;\n            if(t > ans) ans = t;\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["刷题"],"categories":["算法"]},{"title":"滑动谜题","url":"/2019/11/24/滑动谜题/","content":"\n# 题目\n\n在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.\n\n一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.\n\n最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。\n\n给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/sliding-puzzle\n\n\n\n# 思路\n\n要求最短路径，想到dfs或者bfs，bfs求出的答案直接就是最短路径\n\n考虑一个棋盘，搜索就是将0滑动到其他方块，走到下一个状态。因此可以将棋盘当前的状态用一个string唯一记录，0滑动到下一个状态就可以用另一个string表示，用一个map来记录走过的所有棋盘状态以免重复\n\n最终状态是可以确认的，因此就可以判断是否可以搜索到结果\n\n\n\n# 题解\n\n```c++\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <map>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int slidingPuzzle(vector<vector<int>>& board) {\n        string dest = \"123450\";\n        vector<vector<int>> pos{{1,3},{0,2,4},{1,5},{0,4},{1,3,5},{2,4}};\n        string start = \"\";\n        for(int i = 0; i < 2; i++){\n            for(int j = 0; j < 3; j++){\n                start += to_string(board[i][j]);\n            }\n        }\n        map<string, int> memory;\n        memory.insert(pair<string, int>{start, 1});\n        queue<pair<string, int>> q;\n        q.push(pair<string, int>{start,0});\n        int found = -1;\n        while(!q.empty()){\n            pair<string,int> now = q.front();\n            q.pop();\n            if(now.first == dest){\n                found = now.second;\n                break;\n            }\n            int index = now.first.find('0');\n            for(int i = 0; i < pos[index].size(); i++){\n                string temp = now.first;\n                temp[index] = temp[pos[index][i]];\n                temp[pos[index][i]] = '0';\n                if(memory.find(temp) == memory.end()){\n                    memory.insert(now);\n                    q.push(pair<string, int>{temp, now.second+1});\n                }\n            }\n        }\n        return found;\n    }\n};\n```\n\n","tags":["刷题","暴搜"],"categories":["算法"]},{"title":"编辑距离","url":"/2019/11/24/编辑距离/","content":"\n# 题目\n\n给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n插入一个字符\n删除一个字符\n替换一个字符\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/edit-distance\n\n\n\n# 思路\n\n暴力搜索很难表示三种情况\n\n考虑利用动态规划\n\n长的字符串的编辑距离依赖于短的字符串的编辑距离\n\n利用一个二维数组DP\\[i][j]，表示word1从0开始长度为i的子串和word2从0开始长度为j的子串的编辑距离\n\n如何求当前位置DP\\[i][j]？对于这一题，只要考虑一个字符的改变（三个操作都是改变一个字符）即可，因此要根据DP\\[i-1][j-1]以及DP\\[i][j-1]和DP\\[i-1][j]来求\n\n根据两个字符串最后一个字符相同与否，可以分为两种情况\n\n![image](https://s2.ax1x.com/2019/11/24/MLsec8.png)\n\n容易知道初始情况是两个维度中有一个是0的情况，其他情况都可以递归到这里\n\n迭代计算的方向是两个维度都从1开始，往上慢慢加\n\n\n\n# 题解\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int dp[1000][1000];\n        for(int i = 0; i <= word2.length(); i++){\n            dp[0][i] = i;\n        }\n        for(int i = 0; i <= word1.length(); i++){\n            dp[i][0] = i;\n        }\n        for(int i = 1; i <= word1.length(); i++){\n            for(int j = 1; j <= word2.length(); j++){\n                if(word1[i-1] == word2[j-1]){\n                    dp[i][j] = min(min(dp[i-1][j-1], dp[i][j-1]+1), dp[i-1][j]+1);\n                } else {\n                    dp[i][j] = min(min(dp[i-1][j-1]+1, dp[i][j-1]+1), dp[i-1][j]+1);\n                }\n            }\n        }\n        return dp[word1.length()][word2.length()];\n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"戳气球","url":"/2019/11/23/戳气球/","content":"\n# 题目\n\n有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。\n\n现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。\n\n求所能获得硬币的最大数量。\n\n说明:\n\n你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。\n0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100\n示例:\n\n输入: [3,1,5,8]\n输出: 167 \n解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\n     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/burst-balloons\n\n\n\n# 思路\n\n容易想到逐个枚举气球来戳爆，时间复杂度是O(n!)\n\n当逐个选择气球戳爆的时候，左右两边发生了变化，因此后一个要依赖前一个\n\n当逐个枚举气球不戳爆的时候，这个气球将整个数组分成了左右两个部分，分别求这两边戳爆的最大值，再加上戳爆这个气球的值，就是最后的答案\n\n这样有个好处就是实际上会变成枚举区间，加上记忆化，那么最终复杂度就是O(n^2)\n\n\n\n# 题解\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\n    int memory[600][600];\npublic:\n    int maxCoins(vector<int>& nums) {\n        memset(memory, 0, sizeof(memory));\n        return dfs(0, nums.size()-1, nums);\n    }\n\n    int dfs(int start, int end, const vector<int>& nums){\n        if(start >= 0 && end < nums.size() && start <= end && memory[start][end] != 0) return memory[start][end];\n        int left = (start == 0) ? 1 : nums[start-1];\n        int right = (end == (nums.size() - 1)) ? 1 : nums[end+1];\n        if(start == end) {\n            memory[start][end] = left * nums[start] * right;\n            return left * nums[start] * right;\n        }\n        int max = 0;\n        for(int i = start; i <= end; i++){\n            int temp = left * nums[i] * right + dfs(start, i-1, nums) + dfs(i+1, end, nums);\n            if(max < temp){\n                max = temp;\n                memory[start][end] = max;\n            }\n        }\n        return max;\n    }\n};\n```\n\n","tags":["刷题","暴搜"],"categories":["算法"]},{"title":"N皇后II","url":"/2019/11/19/N皇后/","content":"\n# 题目\n\nn 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。\n\n每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\n\n示例:\n\n输入: 4\n输出: [\n [\".Q..\",  // 解法 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // 解法 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/n-queens\n\n\n\n# 思路\n\n容易想到可以省略行，因为每一行都只能放一个皇后。只要维护一个一维数组column，第i个位置放position表示第position行，i列有皇后。这样其实就已经可以计算出两条对角线了。\n\n但是为了方便，还引入两个一维数组，分别是position-i和position+i，因为对角线上这两个值相同。\n\n\n\n# 题解\n\n```c++\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> ans;\n    set<int> plus;\n    set<int> sub;\n    vector<vector<string>> solveNQueens(int n) {\n        vector<int> column;\n        for(int i = 0; i < n; i++){\n            column.push_back(-1);\n        }\n        plus.clear();\n        sub.clear();\n        dfs(column, 0);\n        return ans;\n    }\n\n    void make_ans(vector<int>& column){\n        vector<string> one;\n        for(int i = 0; i < column.size(); i++){\n            for(int j = 0; j < column.size(); j++){\n                if(i == column[j]){\n                    string s(column.size(), '.');\n                    s[j] = 'Q';\n                    one.push_back(s);\n                }\n            }\n        }\n        ans.push_back(one);\n    }\n\n    void dfs(vector<int>& column, int now){\n        if(now == column.size()){\n            make_ans(column);\n        }\n        for(int i = 0; i < column.size(); i++){\n            if(column[i] == -1){\n                if((plus.find(i+now) == plus.end()) && (sub.find(now-i) == sub.end())){\n                    column[i] = now;\n                    plus.insert(i+now);\n                    sub.insert(now-i);\n                    dfs(column, now+1);\n                    column[i] = -1;\n                    plus.erase(i+now);\n                    sub.erase(now-i);\n                }\n            }\n        }\n    }\n};\n```\n\n","tags":["刷题","暴搜"],"categories":["算法"]},{"title":"N皇后II","url":"/2019/11/14/N皇后II/","content":"\n# 题目\n\nn 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n给定一个整数 n，返回 n 皇后不同的解决方案的数量。\n\n示例:\n\n输入: 4\n\n输出: 2\n\n解释: 4 皇后问题存在如下两个不同的解法。\n\n[\n\n [\".Q..\",  // 解法 1\n\n  \"...Q\",\n\n  \"Q...\",\n\n  \"..Q.\"],\n\n [\"..Q.\",  // 解法 2\n\n  \"Q...\",\n\n  \"...Q\",\n\n  \".Q..\"]\n\n]\n\n\n\n来源：力扣（LeetCode）\n\n链接：https://leetcode-cn.com/problems/n-queens-ii\n\n\n\n## 思路\n\n暴力搜索+回溯\n\n不需要用二维数组来记录，因为每个皇后必不在一行，因此只要一个一维数组，然后可以再对应的列记录下每一层皇后的信息（例如行号或者转换成一维数组后的position）\n\n搜索的时候，重点在于检验交叉是否有皇后，向上层搜索，限制住深度和宽度就行\n\n\n\n# 题解\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\nprivate:\n    int res;\npublic:\n    int totalNQueens(int n) {\n        res = 0;\n        vector<int> column;\n        for(int i = 0; i < n; i++){\n            column.push_back(-1);\n        }\n        dfs(column, 1, n);\n        return res;\n    }\n\n    void dfs(vector<int>&column, int now, int n){\n        if(now <= n){\n            for(int i = 0; i < column.size(); i++){\n                if(column[i] == -1){\n                    // 尝试放一下\n                    int position = (now - 1) * n + i;\n                    if(check(position, column, n)){\n                        // 确实可以放\n                        column[i] = position;\n                        // 递归\n                        dfs(column, now+1, n);\n                    }\n                    // 回溯\n                    column[i] = -1;\n                }\n            }\n        } else {\n            res++;\n        }\n    }\n\n    bool check(int position, const vector<int>& column, int n){\n        // 约束住宽度\n        int column_num = position % n;\n        int bias = 1;\n        // 约束住深度\n        int times = position / n;\n\n        while((column_num-bias>=0 || column_num+bias<n) && bias <= times){\n            for(int i = 0; i < column.size(); i++){\n                // 两边搜索\n                if(column_num-bias>=0){\n                    if(column[i] == position - (n+1)*bias) return false;\n                }\n                if(column_num+bias<n){\n                    if(column[i] == position - (n-1)*bias) return false;\n                }\n            }\n            bias++;\n        }\n        return true;\n    }\n};\n\nint main(){\n    Solution s;\n    cout << s.totalNQueens(8) << endl;\n    return 0;\n}\n```\n\n","tags":["刷题","暴搜"],"categories":["算法"]},{"title":"寻找两个有序数组的中位数","url":"/2019/10/14/寻找两个有序数组的中位数/","content":"\n# 题目\n\n给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\n\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\n\n你可以假设 nums1 和 nums2 不会同时为空。\n\n示例 1:\n\nnums1 = [1, 3]\nnums2 = [2]\n\n则中位数是 2.0\n示例 2:\n\nnums1 = [1, 2]\nnums2 = [3, 4]\n\n则中位数是 (2 + 3)/2 = 2.5\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays\n\n\n\n# 思路\n\n如果不考虑时间复杂度，可以一个一个删除，直到找到中位数。\n\n考虑时间复杂度的话，那么就要一批一批删除，每次尝试删除k/2，更新k\n\n\n\n# 题解\n\n作者：windliang\n链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/\n来源：力扣（LeetCode）\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std; \n\nclass Solution {\npublic:    \n\tdouble findMedianSortedArrays(vector<int> nums1, vector<int> nums2) {\n        int n = nums1.size();\n        int m = nums2.size();\n        int left = (n + m + 1) / 2;\n        int right = (n + m + 2) / 2;\n        //将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。\n        return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) + getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;\n    }\n\n    int getKth(vector<int> nums1, int start1, int end1, vector<int> nums2, int start2, int end2, int k) {\n        int len1 = end1 - start1 + 1;\n        int len2 = end2 - start2 + 1;\n        //让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1\n        if (len1 > len2) return getKth(nums2, start2, end2, nums1, start1, end1, k);\n        if (len1 == 0) return nums2[start2 + k - 1];\n\n        if (k == 1) return min(nums1[start1], nums2[start2]);\n\n        int i = start1 + min(len1, k / 2) - 1;\n        int j = start2 + min(len2, k / 2) - 1;\n\n        if (nums1[i] > nums2[j]) {\n            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));\n        }\n        else {\n            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));\n        }\n    }\n};\n```\n\n","tags":["刷题"],"categories":["算法"]},{"title":"无重复字符的最长子串","url":"/2019/10/13/无重复字符的最长子串/","content":"\n# 题目\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n示例 2:\n\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n示例 3:\n\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\n\n\n\n# 思路\n\n本来想用动态规划，但是写起来太麻烦莫名其妙的错误太多就放弃了。\n\n用双指针比较方便。\n\n\n\n# 题解\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int ans = 0;\n        int l=0,r=0;\n        int window[256] = {0};\n        while(r<s.size()){\n            window[s[r]]++;\n            while(window[s[r]]>1){\n                window[s[l]]--;\n                l++;\n            }\n            ans = max(r-l+1, ans);\n            r++;\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["刷题","双指针"],"categories":["算法"]},{"title":"找到字符串中所有字母异位词","url":"/2019/10/13/找到字符串中所有字母异位词/","content":"\n# 题目\n\n给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。\n\n字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。\n\n说明：\n\n字母异位词指字母相同，但排列不同的字符串。\n不考虑答案输出的顺序。\n示例 1:\n\n输入:\ns: \"cbaebabacd\" p: \"abc\"\n\n输出:\n[0, 6]\n\n解释:\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词。\n 示例 2:\n\n输入:\ns: \"abab\" p: \"ab\"\n\n输出:\n[0, 1, 2]\n\n解释:\n起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的字母异位词。\n起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-all-anagrams-in-a-string\n\n\n\n# 思路\n\n双指针。\n\n注意一下这里每个字符的数量要完全匹配。\n\n\n\n注意一下基本上连续的子串可以考虑动态规划，各个答案着的情况可以考虑双指针。\n\n\n\n# 题解\n\n两种写法。\n\n第一种考虑当某个字符变多的时候。\n\n例如窗口中有两个a，但是p中只有一个a，这时需要缩小窗口，直到只有一个a，同时注意更新match\n\n当match达到要求，直接就可以得到结果\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int count[256] = {0};\n        int diff = 0;\n        int match = 0;\n        for(auto c: p){\n            if(count[c]==0) diff++;\n            count[c] += 1;\n        }\n        int window[256] = {0};\n        int r = 0, l = 0;\n        vector<int> ans;\n        while(r < s.size()){\n            window[s[r]]++;\n            if(window[s[r]] == count[s[r]]){\n                match++;\n            } else {\n                while(window[s[r]] > count[s[r]]){\n                    window[s[l]]--;\n                    if(window[s[l]] == count[s[l]]-1) match--;\n                    l++;\n                }\n            }\n\n            if(match == diff){\n               ans.push_back(l);\n            }\n\n            r++;\n        }\n        return ans;\n    }\n};\n```\n\n\n\n第二种是不管字符数目超过，一直累加到match达到要求，此时要注意窗口中字符种类虽然达到要求，但是个数不一定符合。所以需要缩小窗口，直到窗口大小如果等于p的长度，且match仍然符合要求，那么得到一个结果。\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int count[256] = {0};\n        int diff = 0;\n        int match = 0;\n        for(auto c: p){\n            if(count[c]==0) diff++;\n            count[c] += 1;\n        }\n        int window[256] = {0};\n        int r = 0, l = 0;\n        vector<int> ans;\n        while(r < s.size()){\n            window[s[r]]++;\n            if(window[s[r]] == count[s[r]])\n                match++;\n\n            while(match == diff){\n                if(r-l+1 == p.size()){\n                    ans.push_back(l);\n                }\n                window[s[l]]--;\n                if(window[s[l]] == count[s[l]]-1) {\n                    match--;\n                }\n                l++;\n            }\n\n            r++;\n        }\n        return ans;\n    }\n}\n```\n\n","tags":["刷题","双指针"],"categories":["算法"]},{"title":"c++容器库（二）","url":"/2019/10/12/c-容器库（二）/","content":"\n# 顺序容器\n\n![image-20191013105905432](https://s2.ax1x.com/2019/10/13/uj7zmn.png)\n\n## 添加元素\n\n容器元素是拷贝。即容器中的元素与提供值的对象之间没有任何关联，修改容器的值不会影响到原始对象，反之亦然。\n\n1. push_back\n\n   追加元素到尾部。array和forward_list不支持此操作。（string支持此操作）\n\n2. push_front\n\n   在头部插入。\n\n   list, forward_list, deque支持此操作\n\n   vector不支持此操作。\n\n3. insert单一插入\n\n   任意位置插入\n\n   接受一个迭代器\n\n   在迭代器之前插入\n\n   vector不支持push_front，但是可以用insert来在前面插入\n\n4. insert范围插入\n\n   ![image-20191013104103186](https://s2.ax1x.com/2019/10/13/ujHMtK.png)\n\n   插入10个\"Anna\"\n\n   \n\n   ![image-20191013104147612](https://s2.ax1x.com/2019/10/13/ujHm01.png)\n\n   **注**：insert会返回指向第一个新加入元素的迭代器。\n\n   ![image-20191013104502458](https://s2.ax1x.com/2019/10/13/ujH1pD.png)\n\n5. emplace\n\n   emplace可以构造元素，而不单单是拷贝\n\n   参数必须与元素的构造参数相匹配\n\n\n\n## 访问元素\n\n包括array在内的每个顺序容器都有一个front函数，除了forward_list之外所有顺序容器都有一个back函数。分别返回首元素和尾元素的引用。\n\n访问容器内容还可以通过解引用迭代器来完成。\n\n![image-20191013110337127](https://s2.ax1x.com/2019/10/13/ujbSjH.png)\n\n注意这里的end迭代器要先递减，然后再解引用。\n\n![image](https://s2.ax1x.com/2019/10/13/ujOA4x.png)\n\n注意访问容器中的元素都是引用访问，因此可以更改值。\n\n如果容器是const的，那么返回的是const的引用。\n\n**注1**：如果用auto c = a.back()，那么返回引用，但是auto自动推断不是引用。要写成auto &c = a.back()\n\n**注2**：下标安全性问题。用下标运算符不会检查越界问题，可以使用at函数，会抛出异常。\n\n![image](https://s2.ax1x.com/2019/10/15/KCGoes.png)\n\n\n\n## 删除元素\n\n1. pop_front和pop_back\n\n   分别删除首元素和尾元素。\n\n   vector和string不支持push_front，也不支持pop_front。\n\n   forward_list不支持pop_back。\n\n   这两个函数的返回值都是void，因此如果需要弹出元素的值，那么需要提前取出。\n\n2. erase\n\n   允许从容器中的指定位置删除元素。","tags":["c++","容器","stl"],"categories":["c++"]},{"title":"最小覆盖子串","url":"/2019/10/12/最小覆盖子串/","content":"\n# 题目\n\n给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。\n\n示例：\n\n输入: S = \"ADOBECODEBANC\", T = \"ABC\"\n输出: \"BANC\"\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-window-substring\n\n\n\n# 思路\n\n用一个数组记录一下要搜索的子串对应字符出现的次数。\n\n然后用两个指针l和r，一个指针r向右，一直搜索到l到r之间的子串包含要搜索的子串，然后再递增l，直到窗口最小。\n\n注意包含要搜索的子串不必遍历查找，只要维持一个match变量，指示当前匹配了多少个不同的字符，如果match等于要搜索的子串的不同字符数，那么则说明包含。\n\n\n\n# 题解\n\nc++代码如下：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        int match = 0;\n        int count[256] = {0};\n        int diff = 0;\n        for(auto c: t)  {\n            if(count[c] == 0) diff++;\n            count[c]++;\n        }\n        int r = 0, l = 0;\n        int window[256] = {0};\n        string ans = \"\";\n        while(r < s.size()){\n            window[s[r]]++;\n            if(window[s[r]]==count[s[r]]){\n                match++;\n            }\n            while(match == diff){\n                window[s[l]]--;\n                if(window[s[l]]<count[s[l]]){\n                    window[s[l]]++;\n                    if(ans.size() > (r - l + 1) || ans.size() == 0){\n                        ans = s.substr(l, r - l + 1);\n                    }\n                    break;\n                }\n                l++;\n            }\n            r++;\n        }\n        return ans;\n    }\n};\n```\n\n","tags":["刷题","滑动窗口"],"categories":["算法"]},{"title":"最长有效括号","url":"/2019/10/06/最长有效括号/","content":"\n# 题目\n\n给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。\n\n示例 1:\n\n输入: \"(()\"\n输出: 2\n解释: 最长有效括号子串为 \"()\"\n示例 2:\n\n输入: \")()())\"\n输出: 4\n解释: 最长有效括号子串为 \"()()\"\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-valid-parentheses\n\n\n\n# 思路\n\n最开始想到用栈模拟。\n\n题解里面用的是动态规划感觉还是比较容易些。\n\n\n\n# 题解\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/\n来源：力扣（LeetCode）\n\n\n\n定义一个dp数组。第i个位置为以i结尾的最长括号的长度。\n\n那么可以得到递推关系：\n\n![image](https://s2.ax1x.com/2019/10/12/uXqRC8.png)\n\n```java\npublic class Solution {\n    public int longestValidParentheses(String s) {\n        int maxans = 0;\n        int dp[] = new int[s.length()];\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) == ')') {\n                if (s.charAt(i - 1) == '(') {\n                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {\n                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                }\n                maxans = Math.max(maxans, dp[i]);\n            }\n        }\n        return maxans;\n    }\n}\n```\n\n\n\n用栈模拟\n\n注意一下整个栈清空时候能正确计算。即()()可以算出4。\n\n这样就要保留一下前一个位置的信息，且用下标直接减，不要用pop出来的数字+1。\n\n![image](https://s2.ax1x.com/2019/10/12/uXL8xg.png)\n\n```java\npublic class Solution {\n    public int longestValidParentheses(String s) {\n        int maxans = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();  // 直接舍弃\n                if (stack.empty()) {\n                    stack.push(i);  // 处理的就是)()()这种情况\n                } else {  // 计算舍弃之后的前一位到目前的距离\n                    maxans = Math.max(maxans, i - stack.peek());\n                }\n            }\n        }\n        return maxans;\n    }\n}\n\n```\n\n","tags":["动态规划","刷题","栈"],"categories":["算法"]},{"title":"不同路径","url":"/2019/10/06/不同路径/","content":"\n# 题目\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/unique-paths\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n\n# 思路\n\n一开始想用DFS，写起来容易，就是超时了。\n\nDFS重复计算了很多，即经过一个格子的时候其实早就经过了，当然可以用记忆化搜索来优化，用一个二维数组来存储一下即可。\n\n考虑用动态规划，用一个二维数组来表示某位置到终点的情况数，(x,y)位置的次数等于(x+1,y) + (x, y+1)，这样就有递推关系了，然后原始条件就是右下角的那几个。\n\n其实二维数组套两层循环，一次也只是用到了一维数组，因此可以稍微优化一下。这里稍微画一个图看着写就行了。\n\n\n\n# 题解\n\n优化前：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Solution {\nprivate:\n    int ans;\n    int m;\n    int n;\npublic:\n    int uniquePaths(int m, int n) {\n        int dp[m+1][n+1];\n        for(int i=1;i<=n;i++) dp[m][i] = 1;\n        for(int j=1;j<=m;j++) dp[j][n] = 1;\n        for(int i=m-1;i>=1;i--){\n            for(int j=n-1;j>=1;j--){\n                dp[i][j] = dp[i+1][j] + dp[i][j+1];\n            }\n        }\n        return dp[1][1];\n    }\n}\n```\n\n\n\n优化后：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Solution {\nprivate:\n    int ans;\n    int m;\n    int n;\npublic:\n    int uniquePaths(int m, int n) {\n        int dp[m+1];\n        for(int j=1;j<=m;j++) dp[j] = 1;\n        for(int i=n-1;i>=1;i--){\n            for(int j=m-1;j>=1;j--){\n                dp[j] = dp[j] + dp[j+1];\n            }\n        }\n        return dp[1];\n    }\n}   \n```\n\n","tags":["动态规划","刷题","暴搜"],"categories":["算法"]},{"title":"括号生成","url":"/2019/10/06/括号生成/","content":"\n# 题目\n\n给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。\n\n例如，给出 n = 3，生成结果为：\n\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/generate-parentheses\n\n\n\n# 思路\n\nDFS，每次考虑一个位置放左括号还是右括号。为了防止垃圾情况过多，预先剪枝，即只有合理的时候才会继续，那么只要是能到最后（所有括号都被用完），就可以得到一个解。\n\n\n\n具体来说就是：\n\n用一个栈（一个整数就够了）来维护当前栈中的左括号数量，来实时判断是否可以放右括号；还需要左右括号的数量；还需要当前的字符串\n\n\n\n对于每一个位置，左括号可以随便放，右括号要考虑一下，如果栈中有左括号，那么可以放，否则不行。这样预先剪枝，到最后如果左右括号都用完，自然就形成一个解，而不用最后判断。\n\n\n\n# 题解\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<string> ans;    \npublic:\n    vector<string> generateParenthesis(int n) {\n      int left = n, right = n;\n      int stack = 0;\n      string s = \"\";\n      DFS(stack, left, right, s);\n      return ans;\n    }\n\n    /*\n    stack表示栈中左括号的数量\n    left表示剩余的左括号数量\n    right表示剩余的右括号数量\n    s表示当前的字符串情况\n     */    \n    void DFS(int stack, int left, int right, string s){\n      if(left == right && left == 0){  // 括号全都用上了表示得到一个结果\n        ans.push_back(s);\n        return;\n      }\n      if(left != 0){  // 左括号随便放\n        DFS(stack+1, left-1, right, s+\"(\");\n      }\n      if(stack != 0 && right != 0){  // 右括号有条件地放\n        DFS(stack-1, left, right-1, s+\")\");\n      }\n      return ;\n    }\n};\n```\n\n","tags":["刷题","暴搜"],"categories":["算法"]},{"title":"全排列","url":"/2019/10/06/全排列/","content":"\n# 题目\n\n给定一个没有重复数字的序列，返回其所有可能的全排列。\n\n示例:\n\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/permutations\n\n\n\n# 思路\n\n回溯即可。\n\n注意一下vector的引用问题。\n\n\n\n# 题解\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<vector<int>> ans;\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<int> left(nums.size(), 0);  // 初始化为全0\n        vector<int> now;\n        DFS(nums, now, left);\n        return ans;\n    }\n\n    /*\n    now表示现在加到结果中的vector\n    left表示还可以加入的位置。1表示已经加入，0表示还可以加入\n    */\n    void DFS(vector<int>& nums, vector<int> now, vector<int> left){  // 这里的now不能是引用\n        int full = true;\n        for(int i=0; i<left.size(); i++){  // 遍历left，如果还有0，那么表示还可以加入\n            if(left[i] != 1){\n                full = false;\n                now.push_back(nums[i]);  // 加入\n                left[i] = 1;\n                DFS(nums, now, left);  // 回溯\n                now.erase(now.end()-1);\n                left[i] = 0;\n            }\n        }\n        if(full){  // 不可以再加入，就加入答案集合中\n            ans.push_back(now);\n        }\n        return ;\n    }\n};\n```\n\n\n\n","tags":["刷题","暴搜"],"categories":["算法"]},{"title":"c++容器库（一）","url":"/2019/10/06/c-容器库（一）/","content":"\n# 容器库操作层次\n\n- 所有容器类型都提供的\n- 仅针对三大容器类型中的一种：顺序容器、关联容器、无需容器\n- 仅适用于一小部分容器\n\n\n\n# 所有容器类型通用操作\n\n## 头文件\n\n容器一般在和容器同名的头文件中声明。\n\n\n\n## 类型\n\n所有的容器类型都是模版类，因此可以限定类型\n\n\n\n## 通用操作\n\n![image](https://s2.ax1x.com/2019/10/06/u62jyj.png)\n\n\n\n## 迭代器\n\n### 迭代器的范围\n\n[begin, end)\n\n\n\n### 迭代器大小\n\n只有能够随机访问的容器的迭代器才可以比较大小，例如vector；list因为不是随机的，因此只能比较是否相等：\n\nhttp://www.cplusplus.com/reference/iterator/\n\n![image](https://s2.ax1x.com/2019/10/06/u6RMtK.png)\n\n即这个写法是错的：\n\n![image](https://s2.ax1x.com/2019/10/06/u6RLAx.png)\n\n\n\n### 正向反向迭代器\n\niterator和reverse_iterator。\n\n反向迭代器的所有操作都会相反。\n\n```c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n    vector<int> v;\n    v.push_back(1);\n    v.push_back(2);\n    vector<int>::reverse_iterator rit;\n    for(auto rit = v.rbegin(); rit != v.rend(); rit++) {  // rbegin和reverse_iterator是配套的\n        cout << *rit << endl;  // 注意这里要解引用\n    }\n\n    return 0;\n}\n```\n\n\n\n### const迭代器\n\n当使用begin的时候，会根据容器的内容来决定是否是一个const_iterator。\n\n![image](https://s2.ax1x.com/2019/10/06/u6fXlD.png)\n\n如果使用begin而且是一个const_iterator，那么就会报错：（报错）\n\n```c++\nconst vector<int> cv;\nvector<int>::iterator cvi = cv.begin();\n```\n\n\n\n## 其他容器类型\n\n容器定义了很多类型，这些类型和具体的容器类型以及他的模版类型都有关系，例如迭代器类型和size_type。\n\n元素类型：value_type\n\n元素类型的一个引用：reference或const_reference\n\n迭代器距离：difference_type\n\n\n\n## 容器初始化\n\n![image](https://s2.ax1x.com/2019/10/06/u64oPx.png)\n\narray并不适用于 C c(b,e) 这种初始化，这一点和数组比较像。\n\n如果提供的值小于容量，那么其余的都是0，例如：\n\n```c++\narray<int, 10> a = {42};  // 第一个元素为42，其余为0\n```\n\n不提供值，那么里面的值是不确定的。\n\n注意：\n\n```c++\narray<int, 10> a{};\n```\n\n这样会初始化为全0。\n\n\n\n### PS：数组初始化\n\n数组中如果：\n\n```c++\nint a[100] = {0};\n```\n\n是全0，如果改成非0的数就只有第一个数赋值了，剩余的都是0\n\n如果:\n\n```c++\nint a[100];\n```\n\n那么如果是全局或者静态变量，是0，否则是随机值。\n\n注意：\n\n```c++\nint a[100]{};\n```\n\n也会初始化为全0\n\n\n\n\n\n注意虽然array没有迭代器，但是仍然可以用指针来初始化，例如：\n\n```c++\nint arr[3];\narr[0] = 1;\narr[1] = 2;\narr[2] = 3;\nvector<int> v(arr, arr+3);\n```\n\n\n\n### 初始化和拷贝\n\n创建一个容器为另一个容器拷贝时，类型必须严格匹配；\n\n用迭代器参数来指定拷贝范围时，不需要严格匹配。\n\n例如：\n\n![image](https://s2.ax1x.com/2019/10/06/u65zm4.png)\n\n注：容器的拷贝不管是容器本身还是里面的元素，都是深度拷贝，不会影响原来的值。\n\n\n\n### array的初始化\n\narray不是数组，但是很像数组。也有固定大小，初始化必须指定array大小。\n\n数组可以直接赋值给array。\n\n\n\n## 交换和赋值\n\n![image](https://s2.ax1x.com/2019/10/06/uc3or9.png)\n\nassign的两种形式：\n\n```c++\nnames.assign(oldstyle.cbegin(), oldstyle.cend())\n```\n\n```c++\nslist1.assign(10, \"Hiya!\");\n```\n\n注意assign的参数类型不必严格匹配，但是用=赋值必须保证参数类型严格匹配。\n\nassign之后指向原来容器的所有指针都会失效，例如迭代器等。\n\n\n\nswap可以高效交换两个相同类型的容器，除了array外，只是交换和数据结构，而不是真实的内存，所有指针不会失效，但是仍然指向原来的元素。\n\narray特殊，真正交换了元素，交换时间与个数成正比，而且指针指向的内容也发生了变化。\n\n\n\n## 容器大小操作\n\nempty方法判断容器是否为空\n\nsize返回个数\n\nmax_size返回该容器所能容纳的最大元素个数\n\nforward_list不支持size方法\n\n\n\n## 容器比较大小\n\n容器要完全相同才能比较大小。\n\n比较的是容器里面的元素。\n\n具体规则如下：\n\n![image](https://s2.ax1x.com/2019/10/06/ucddPA.png)\n\n因为比较的是容器内的元素，所以要容器中的元素定义了比较，容器才可以比较。\n\n\n\n# 参考资料：\n\n1. 《Primer c++ 第五版》\n2. http://www.cplusplus.com/reference/iterator/","tags":["c++","容器","stl"],"categories":["c++"]},{"title":"按递增顺序显示卡牌","url":"/2019/10/05/按递增顺序显示卡牌/","content":"\n# 题目\n\n牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。\n\n最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。\n\n现在，重复执行以下步骤，直到显示所有卡牌为止：\n\n从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。\n如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。\n如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。\n返回能以递增顺序显示卡牌的牌组顺序。\n\n答案中的第一张牌被认为处于牌堆顶部。\n\n \n\n示例：\n\n输入：[17,13,11,2,3,5,7]\n输出：[2,13,3,11,5,17,7]\n解释：\n我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。\n重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。\n我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。\n我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。\n我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。\n我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。\n我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。\n我们展示 13，然后将 17 移到底部。牌组现在是 [17]。\n我们显示 17。\n由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/reveal-cards-in-increasing-order\n\n\n\n# 思路\n\n直接模拟即可\n\n先对于数组排序，得到排序好的，然后按照位置安插进去即可\n\n重要的是得到位置和次序的对应关系。可以用一个队列来模拟这个过程，自然就可以得到关系\n\n\n\n## 题解\n\n```c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> deckRevealedIncreasing(vector<int>& deck) {\n        int len = deck.size();\n        int order[1001];\n        queue<int> q;\n        for(int i=0;i<len;i++){\n            q.push(i);\n        }\n        int now = 0;\n        while(!q.empty()){\n            int front = q.front();\n            q.pop();\n            order[now] = front;\n            if(!q.empty()){\n                front = q.front();\n                q.pop();\n                q.push(front);\n            }\n            now++;\n        }\n        sort(deck.begin(), deck.end());\n        int ans[1001];\n        for(int i=0;i<len;i++){\n            ans[order[i]] = deck[i];\n        }\n        vector<int> ret(ans, ans+len);\n        return ret;\n    }\n};\n\n```\n\n","tags":["刷题","队列"],"categories":["算法"]},{"title":"tmux使用简易入门","url":"/2019/10/05/tmux使用简易入门/","content":"\n为了使得断开SSH也能继续运行命令，下次继续返回现场，可以使用tmux\n\n参考 [gist.github.com/MohamedAlaa/2961058](https://gist.github.com/MohamedAlaa/2961058)\n\n\n\n## 键入tmux即可进入tmux环境\n\n在tmux环境中 按住 control-b 然后松开 再按 ？即可查看所有快捷键\n\n\n\n## 如何查看当前tmux的窗口状态呢？\n\n键入tmux ls可以列出所有的windows\n\n输入c-b w可以看到所有的windows，可以看出一组window表示一个一个tmux环境（用于返回到某个工作环境中），里面有多个bash（一个工作环境同时有多个bash，一个bash就是一个window），而一个bash可以有多个面板panel（用于同时显示多个命令行界面，即分屏功能）\n\n\n\n## 如何退出tmux环境呢？\n\nc-b d即可退出tmux进入到正常的bash中\n\n\n\n## 如何新建tmux环境呢？\n\n退出再进入即可新建一个新的tmux环境，即一组bash\n\n\n\n## 如何在一个环境中新建bash呢？\n\nc-b c即可在当前环境中新建bash\n\n\n\n## 如何杀死一个tmux环境呢？即如何杀死一组bash\n\n再进入tmux然后查看所有windows即可发现之前的环境并没有杀死，而是还在后台继续，那么如何杀死windows呢\n\ntmux用session来标示一组windows或者bash，可以杀死一组windows来杀死它的所有bash，windows前面的数字就是他的session号\n\n命令 tmux kill-session -t 8 就可以杀死session号为8的windows组\n\n\n\n## 如何在一个tmux环境中删除某个bash呢？\n\n在某个bash的panel中键入 c-b x 即可删除掉当前panel\n\n注意删除的粒度是panel级别的，因此如果在一个bash里面有多个panel，那么只会删除掉当前的panel\n\n\n\n## 如何分屏？即如何新建panel\n\nc-b % 竖直分屏\n\nc-b “ 水平分屏\n\n\n\n## 如何在一个bash的多个panel之间切换？\n\nc-b o 即可按顺序在多个panel之间切换\n\n\n\n## 如何在多个bash之间切换\n\n1.\t可以用 c-b w 手动选择\n\n2.\t也可以直接 c-b 加上bash的数字即可","tags":["linux","tmux"],"categories":["linux"]},{"title":"二叉搜索树的迭代器","url":"/2019/10/05/二叉搜索树的迭代器/","content":"\n# 题目\n\n实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。\n\n调用 next() 将返回二叉搜索树中的下一个最小的数。\n\n \n\n示例：\n\n\n\nBSTIterator iterator = new BSTIterator(root);\niterator.next();    // 返回 3\niterator.next();    // 返回 7\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 9\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 15\niterator.hasNext(); // 返回 true\niterator.next();    // 返回 20\niterator.hasNext(); // 返回 false\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/binary-search-tree-iterator\n\n\n\n# 思路\n\n初始化的时候中序遍历一次，然后每次取下一个即可\n\n\n\n# 题解\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n };\n\nclass BSTIterator {\nprivate:\n    vector<int> v;\n    int index;\npublic:\n    BSTIterator(TreeNode* root) {\n        inOrder(root);\n        index = 0;\n    }\n\n    void inOrder(TreeNode* root){\n        if(root == NULL) return;\n        preOrder(root -> left);\n        v.push_back(root -> val);\n        preOrder(root -> right);\n        return;\n    }\n    \n    /** @return the next smallest number */\n    int next() {\n        int ans = v[index];\n        index += 1;\n        return ans;\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return index!=v.size();\n    }\n};\n```\n\n\n\n题解中还有一种比较巧妙，用了栈来做中序遍历，可以容易控制进度。\n\n每一次先找到最小值，寻找路上经过的节点依次压栈，栈顶保留当前最小值。然后每次取出最小值的时候，弹栈，并且压入下一个最小值。如何找最小值？如果当前节点的右子节点为空，那么最小值已经在栈中；如果不为空，那么压入右子节点，并且一路在它的左子树寻找下去。\n\n作者：offercomeon-2\n链接：https://leetcode-cn.com/problems/binary-search-tree-iterator/solution/zhong-xu-bian-li-de-die-dai-fen-jie-jie-ti-by-offe/\n\n```c++\nclass BSTIterator {\n    stack<TreeNode*> tree_stack;\npublic:\n    BSTIterator(TreeNode* root) {\n        while(root){\n            tree_stack.push(root);\n            root = root->left;\n        }\n    }\n    \n    /** @return the next smallest number */\n    int next() {\n        TreeNode* cur = tree_stack.top();\n        tree_stack.pop();\n        int res = cur->val;\n        cur = cur->right;\n        while(cur){\n            tree_stack.push(cur);\n            cur = cur->left;\n        }\n        return res;\n    }\n    \n    /** @return whether we have a next smallest number */\n    bool hasNext() {\n        return !tree_stack.empty();\n    }\n};\n```\n\n\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"N叉树的前序遍历","url":"/2019/10/05/N叉树的前序遍历/","content":"\n# 题目\n\n给定一个 N 叉树，返回其节点值的前序遍历。\n\n例如，给定一个 3叉树 :\n\n![image](https://s2.ax1x.com/2019/10/05/us9c4S.png)\n\n返回其前序遍历: [1,3,5,6,2,4]。\n\n \n\n说明: 递归法很简单，你可以使用迭代法完成此题吗?\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal\n\n\n\n# 思路\n\n1. 递归\n2. 迭代\n\n\n\n递归因为只需要处理一下当前节点即可，所以返回void即可；不需要全局数据，只要传入一个引用参数，修改引用参数即可。\n\n迭代要用栈，注意压栈顺序是从右往左。\n\n\n\n# 题解\n\n```c++\n#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> preorder(Node* root) {\n        vector<int> ans;\n        if(root == NULL) return ans;\n        stack<Node*> n;\n        n.push(root);\n        while(!n.empty()){\n            root = n.top();\n            n.pop();\n            ans.push_back(root -> val);\n            vector<Node*> c = root -> children;\n            for(int i=c.size()-1;i>=0;i--)\n                n.push(c[i]);\n        }\n        return ans;\n    }\n};\n```\n\n\n\n```c++\n#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> preorder(Node* root) {\n        vector<int> ans;\n        DFS(ans, root);\n        return ans;\n    }\n\n    void DFS(vector<int>& ans, Node* node){\n         if(node == NULL) return;\n         ans.push_back(node -> val);\n         for(auto n: node -> children){\n             DFS(ans, n);\n         }\n    }\n};\n```\n\n\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"二叉树的最大深度","url":"/2019/10/05/二叉树的最大深度/","content":"\n# 题目\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n   3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回它的最大深度 3 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree\n\n\n\n# 思路\n\n必然是DFS。\n\n如果将深度放在参数列表里面，统计的是总的深度，而不是最深。\n\n放在返回值里面，即每层递归返回自身深度，等于下一层深度+1，下一层深度有两个，取大的那个。\n\n\n\n# 题解\n\n```c++\n#include <vector>\nusing namespace std;\n\nstruct TreeNode { \n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        return 1 + max(maxDepth(root -> left), maxDepth(root -> right));\n    }\n};\n```\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"二叉树剪枝","url":"/2019/10/05/二叉树剪枝/","content":"\n# 题目\n\n给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。\n\n返回移除了所有不包含 1 的子树的原二叉树。\n\n( 节点 X 的子树为 X 本身，以及所有 X 的后代。)\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/binary-tree-pruning\n\n\n\n# 思路\n\nDFS即可。\n\n不修改放在参数列表中的参数，而是直接返回节点，然后在DFS中组装一下左右子树\n\n这一题仔细分类讨论一下即可\n\n\n\n# 题解\n\n```c++\n#include <vector>\nusing namespace std;\n\nstruct TreeNode { \n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        if(root == NULL) return NULL;\n        if(root -> val == 0 && root -> left == NULL && root -> right == NULL) return NULL;\n        TreeNode* leftChild = pruneTree(root -> left);\n        TreeNode* rightChild = pruneTree(root -> right);\n        if(root -> val == 0 && leftChild == NULL && rightChild == NULL) return NULL;\n        root -> left = leftChild;\n        root -> right = rightChild;\n        return root;\n    }\n};\n```\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"先序遍历构造二叉树","url":"/2019/10/04/先序遍历构造二叉树/","content":"\n# 题目\n\n返回与给定先序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。\n\n(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 < node.val，而 node.right 的任何后代，值总 > node.val。此外，先序遍历首先显示节点的值，然后遍历 node.left，接着遍历 node.right。）\n\n \n\n示例：\n\n输入：[8,5,1,7,10,12]\n输出：[8,5,10,1,7,null,12]\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal\n\n\n\n# 思路\n\n因为是先序遍历，且是二叉搜索树\n\n所以第一个节点必然是根节点，然后找到第一个大于根节点的树，划分左右子树，递归建树\n\n\n\n# 题解\n\n```c++\n#include <vector>\nusing namespace std;\n\nstruct TreeNode { \n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\n        return buildTree(preorder, 0, preorder.size()-1);\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, int left, int right){\n        if(left > right) return NULL;\n        if(left == right) return new TreeNode(preorder[left]);\n        TreeNode* root = new TreeNode(preorder[left]);\n        int border = findBorder(preorder, left, right);\n        TreeNode* leftChild = buildTree(preorder, left+1, border-1);\n        TreeNode* rightChild = buildTree(preorder, border, right);\n        root -> left = leftChild;\n        root -> right = rightChild;\n        return root;\n    }\n\n    int findBorder(vector<int>& preorder, int left, int right){\n        int num = preorder[left];\n        for(int i=left+1; i<=right; i++){\n            if(preorder[i] > num) return i;\n        }\n        return right+1;\n    }\n};\n```\n\n特别注意一下findBorder方法里面，如果没有找到大于根节点的数，那么返回right+1，递归到下一层会自动返回一个NULL节点","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"翻转二叉树","url":"/2019/10/04/翻转二叉树/","content":"\n# 题目\n\n翻转一棵二叉树。\n\n示例：\n\n输入：\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n输出：\n\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/invert-binary-tree\n\n# 思路\n\nDFS递归处理即可\n\n\n\n# 题解\n\n```c++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n };\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root == NULL) return NULL;\n        TreeNode* temp = root -> left;\n        root -> left = root -> right;\n        root -> right = temp;\n        invertTree(root -> left);\n        invertTree(root -> right);\n        return root;\n    }\n};\n```\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"二叉搜索树的范围和","url":"/2019/10/04/二叉搜索树的范围和/","content":"\n# 题目\n\n给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。\n\n二叉搜索树保证具有唯一的值。\n\n \n\n示例 1：\n\n输入：root = [10,5,15,3,7,null,18], L = 7, R = 15\n输出：32\n示例 2：\n\n输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10\n输出：23\n\n\n提示：\n\n树中的结点数量最多为 10000 个。\n最终的答案保证小于 2^31。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/range-sum-of-bst\n\n# 思路\n\n分三种情况DFS\n\n当前节点比最小值还小，那么只考虑右子树\n\n当前节点比最大值还大，那么只考虑左子树\n\n介于两者之间，那么加上当前节点，且考虑左右子树\n\n\n\n# 题解\n\n```c++\n#include <vector>\nusing namespace std;\n\nstruct TreeNode { \n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int L, int R) {\n        int sum = 0;\n        DFS(sum, root, L, R);\n        return sum;\n    }\n\n    void DFS(int &sum, TreeNode* node, int L, int R){\n        if(node == NULL) return;\n        if(node -> val<L) DFS(sum, node->right, L, R);\n        else if(node -> val>R) DFS(sum, node->left, L, R);\n        else {\n            sum += (node -> val);\n            DFS(sum, node->right, L, R);\n            DFS(sum, node->left, L, R);\n        }\n    }\n};\n```\n\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"最大二叉树","url":"/2019/10/04/最大二叉树/","content":"\n# 题目\n\n给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：\n\n二叉树的根是数组中的最大元素。\n左子树是通过数组中最大值左边部分构造出的最大二叉树。\n右子树是通过数组中最大值右边部分构造出的最大二叉树。\n通过给定的数组构建最大二叉树，并且输出这个树的根节点。\n\n \n\n示例 ：\n\n输入：[3,2,1,6,0,5]\n输出：返回下面这棵树的根节点：\n\n      6\n    /   \\\n   3     5\n    \\    / \n     2  0   \n       \\\n        1\n\n\n提示：\n\n给定的数组的大小在 [1, 1000] 之间。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximum-binary-tree\n\n# 思路\n\n直接暴力搜索即可\n\n找出最大节点，DFS左右递归建树，然后拼起来，返回即可\n\n\n\n# 题解\n\nc++如下\n\n```c++\n#include <vector>\nusing namespace std;\n\nstruct TreeNode { \n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        return DFS(nums, 0, nums.size()-1);\n    }\n\n    TreeNode* DFS(vector<int>& nums, int left, int right){\n        if(left>right) return NULL;\n        if(left == right) return new TreeNode(nums[left]);\n        int maxIndex = findMaxPosition(nums, left, right);\n        TreeNode* leftChild = DFS(nums, left, maxIndex-1);\n        TreeNode* rightChild = DFS(nums, maxIndex+1, right);\n        TreeNode* root = new TreeNode(nums[maxIndex]);\n        root -> left = leftChild;\n        root -> right = rightChild;\n        return root;\n    }\n\n    int findMaxPosition(vector<int>& nums, int left, int right){\n        int max = nums[left];\n        int index = left;\n        for(int i=left+1; i<=right; i++){\n            if(nums[i]>max){\n                max = nums[i];\n                index = i;\n            }\n        }\n        return index;\n    }\n};\n```\n\n\n\n题解中有一个正向遍历一次的方法思路蛮巧妙的：\n\n遍历一次数组并随时将新的节点插入树的相应位置，如果当前遍历的值大于树的根节点，则将当前节点作为新的根节点，将原来的树当作新根节点的左子树，否则的话，将其递归的交给根节点的右子树处理（因为从左向右遍历，新的节点一定在右边）。\n\n作者：ruo-shui-qing-ying\n链接：https://leetcode-cn.com/problems/maximum-binary-tree/solution/czi-xia-er-shang-by-ruo-shui-qing-ying/\n","tags":["刷题","暴搜","树"],"categories":["算法"]},{"title":"买卖股票的最佳时机含手续费","url":"/2019/10/04/买卖股票的最佳时机含手续费/","content":"\n# 题目\n\n给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。\n\n你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n\n返回获得利润的最大值。\n\n示例 1:\n\n输入: prices = [1, 3, 2, 8, 4, 9], fee = 2\n输出: 8\n解释: 能够达到的最大利润:  \n在此处买入 prices[0] = 1\n在此处卖出 prices[3] = 8\n在此处买入 prices[4] = 4\n在此处卖出 prices[5] = 9\n总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n注意:\n\n0 < prices.length <= 50000.\n0 < prices[i] < 50000.\n0 <= fee < 50000.\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee\n\n\n\n# 思路\n\n回想一下没有手续费的情况。只要每次比上次多，就可以卖出，比上次少，就忽略。其实隐含着比上次少，更新最小值，比上次多，那么加上股票价格，并且更新最小值为当前值。\n\n因此有手续费的情况下，维护一个最小值，当有值比最小值小，更新最小值；若大，差值超过手续费，则加上，并且更新当前最小值为当前值减去手续费，否则不做任何处理。更新当前最小值为当前值减去手续费可以保证连续递增的情况下正确计算，且当作最小值也是正确的，因为如果值比这个最小值大且没有大得超过手续费，那么说明不值得更新。\n\n\n\n# 题解\n\n参考：\n\n作者：rancho628\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/ti-hao-122mei-you-shou-xu-fei-jia-yi-dian-dong-xi-/\n\n```c++\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int profit = 0;\n        int inhand = prices[0];\n        for(int i=1;i<prices.size();i++){\n            if(prices[i]-inhand>fee) {\n                profit += (prices[i]-inhand-fee);\n                inhand = prices[i]-fee;\n            }\n            else if(prices[i]<inhand){\n                inhand = prices[i];\n            }\n        }\n        return profit;\n    }\n};\n```\n\n另外评论区有其他解法也值得参考：\n\n\n作者：labuladong\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-2/\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"回文子串","url":"/2019/10/04/回文子串/","content":"\n# 题目\n\n给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。\n\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。\n\n示例 1:\n\n输入: \"abc\"\n输出: 3\n解释: 三个回文子串: \"a\", \"b\", \"c\".\n示例 2:\n\n输入: \"aaa\"\n输出: 6\n说明: 6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/palindromic-substrings\n\n# 思路\n\n动态规划好像有点难想，就放弃了\n\n朴素的想法是用中心扩展来判断是否是回文串，在中心扩展时顺便可以计算出所有回文串的数量，因此复杂度可以低一点（边判断边累加求和）\n\n遍历每个字符，作为中心点中心扩展，省去了确定范围的麻烦，以及在判断的时候就可以顺便求和\n\n\n\n# 题解\n\n```c++\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        int num=0;\n        for(int i=0;i<s.size();i++){\n            num += count(s, i, i);\n            num += count(s, i, i+1);\n        }\n        return num;\n    }\n\n    int count(string s, int left, int right){\n        int num = 0;\n        while(left>=0 && right<s.size() && s[left]==s[right]){\n            num++;\n            left--;\n            right++;\n        }\n        return num;\n    }\n};\n```\n\n","tags":["刷题","字符串"],"categories":["算法"]},{"title":"两个字符串的最小ASCII删除和","url":"/2019/10/04/两个字符串的最小ASCII删除和/","content":"\n# 题目\n\n给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。\n\n示例 1:\n\n输入: s1 = \"sea\", s2 = \"eat\"\n输出: 231\n解释: 在 \"sea\" 中删除 \"s\" 并将 \"s\" 的值(115)加入总和。\n在 \"eat\" 中删除 \"t\" 并将 116 加入总和。\n结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。\n示例 2:\n\n输入: s1 = \"delete\", s2 = \"leet\"\n输出: 403\n解释: 在 \"delete\" 中删除 \"dee\" 字符串变成 \"let\"，\n将 100[d]+101[e]+101[e] 加入总和。在 \"leet\" 中删除 \"e\" 将 101[e] 加入总和。\n结束时，两个字符串都等于 \"let\"，结果即为 100+101+101+101 = 403 。\n如果改为将两个字符串转换为 \"lee\" 或 \"eet\"，我们会得到 433 或 417 的结果，比答案更大。\n注意:\n\n0 < s1.length, s2.length <= 1000。\n所有字符串中的字符ASCII值在[97, 122]之间。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings\n\n# 思路\n\n1. 思路的转化\n\n2. dp数组含义的确定\n\n\n\n将减法转为加法：因为两个字符串是固定的，因此其实求的是最大的公共子串。\n\ndp数组是一个二维数组，dp\\[i][j]表示s1[0…i]和s2[0…j]的最大公共子串的ASCII和\n\n因此递推关系如下\n\n如果s1[i] == s2[j]，那么dp\\[i][j] = dp\\[i-1][j-1] + ASCII(s1[i])\n\n否则，因为最后两个字符不相等，可以随意去掉一个（同时出现并不会影响到最大子串）即 dp\\[i][j] = max(dp\\[i-1][j], dp\\[i][j-1])\n\n初始条件：可以容易看出初始条件为dp\\[0][0…s2.length()]和dp\\[0…s1.length()][0]\n\n\n\n# 题解\n\n```c++\nclass Solution {\npublic:\n    int minimumDeleteSum(string s1, string s2) {\n        int dp[1001][1001];\n        int N1 = s1.size(), N2 = s2.size();\n        int totalSum = 0;\n        for(int i=0;i<N1;i++) totalSum += s1[i];\n        for(int j=0;j<N2;j++) totalSum += s2[j];\n        for(int i=0;i<N1;i++) for(int j=0;j<N2;j++) dp[i][j]=0;\n        for(int j=0;j<N2;j++){\n            if(s1[0]==s2[j]){\n                while(j<N2){\n                    dp[0][j] = s1[0];\n                    j++;\n                }\n                break;\n            }\n        }\n        for(int i=0;i<N1;i++){\n            if(s1[i]==s2[0]){\n                while(i<N1){\n                    dp[i][0] = s2[0];\n                    i++;\n                }\n                break;\n            }\n        }\n        for(int i=1;i<N1;i++) \n            for(int j=1;j<N2;j++) {\n                if(s1[i]==s2[j]) dp[i][j] = dp[i-1][j-1] + s1[i];\n                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n\n        return totalSum - dp[N1-1][N2-1]*2;    \n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"不同的二叉搜索树II","url":"/2019/10/04/不同的二叉搜索树II/","content":"\n# 题目\n\n给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。\n\n示例:\n\n输入: 3\n输出:\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\n解释:\n以上的输出对应以下 5 种不同结构的二叉搜索树：\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii\n\n# 思路\n\n这一题和 不同的二叉搜索树 第一题不同，要求全部列出来，用DFS比较简单。\n\n因为是二叉搜索树，所以在start到end范围内，选择每一个点作为root，然后分别构造左右子树的所有情况的vector，然后再遍历组合，返回即可。\n\n注意start>end的时候加入NULL。\n\n以及C++里面一些特殊写法，例如：\n\n用auto自动推断变量类型\n\n用new来声明结构体，这样分配在堆上，不会在函数结束时销毁\n\n->运算符用来解引用去除成员变量\n\n\n\n# 题解\n\nc++实现如下\n\n```c++\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n };\n\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        vector<TreeNode*> ans;\n        if(n==0) return ans;\n        ans = dfs(1, n);\n        return ans;\n    }\n\n    vector<TreeNode*> dfs(int start, int end){\n        vector<TreeNode*> ans;\n        if(start > end){ \n            ans.push_back(NULL);\n            return ans;\n        }\n        for(int i=start; i<=end; i++){\n            vector<TreeNode*> left = dfs(start, i-1);\n            vector<TreeNode*> right = dfs(i+1, end);\n            for(auto l: left){\n                for(auto r: right){\n                    TreeNode* root = new TreeNode(i);\n                    root -> left = l;\n                    root -> right = r;\n                    ans.push_back(root);\n                }\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n","tags":["刷题","暴搜"],"categories":["算法"]},{"title":"不同的二叉搜索树","url":"/2019/10/04/不同的二叉搜索树/","content":"\n# 题目\n\n给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？\n\n示例:\n\n输入: 3\n输出: 5\n解释:\n给定 n = 3, 一共有 5 种不同结构的二叉搜索树:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/unique-binary-search-trees\n\n# 思路\n\n可以依次选择1，2，3…n为根节点建树\n\n选出i为根时，分成两边，1，2，3…i-1和i+1,i+2,i+3…n\n\n分别建子树\n\n因为是二叉搜索树，所以和具体元素无关，只需要考虑节点个数。即节点个数相同，构造出来的树的情况数也相同\n\n\n\n因此dp[i]表示i个节点的二叉树数目\n\n递推为一个乘积的求和式子\n\n注意dp[0]=dp[1]=1，否则若dp[0]=0，则乘法会全部变成0\n\n\n\n## 题解\n\nc++实现如下\n\n```c++\nclass Solution {\npublic:\n    int numTrees(int n) {\n        int dp[1000];\n        for(int i=0;i<=n;i++) dp[i] = 0;\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i=2;i<=n;i++){\n            for(int j=0;j<i;j++){\n                dp[i] += dp[j]*dp[i-j-1];\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"石子游戏","url":"/2019/10/04/石子游戏/","content":"\n# 题目\n\n亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。\n\n游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。\n\n亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。\n\n假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/stone-game\n\n# 思路\n\n有个题解写的蛮好，就直接参考了他的思路\n\n\n\n1. 先找方程\n\n   需要起始位置，还有能区别两个人的first和second\n\n   ![image](https://s2.ax1x.com/2019/10/04/uBc72q.png)\n\n2. 再找递推关系\n\n   ![image](https://s2.ax1x.com/2019/10/04/uBcqMV.png)\n\n   就是先收后手的转化以及比较\n\n3. 找原始递推条件\n\n   一路递推下去起始就是i=j的时候\n\n   ![image](https://s2.ax1x.com/2019/10/04/uBgZIH.png)\n\n4. 画出矩阵图\n\n   ![image](https://s2.ax1x.com/2019/10/04/uBgGdg.png)\n\n   这一步主要是为了写起来更直观\n\n   \n\n# 题解\n\n参考题解：\n\n作者：labuladong\n链接：https://leetcode-cn.com/problems/stone-game/solution/jie-jue-bo-yi-wen-ti-de-dong-tai-gui-hua-tong-yong/\n来源：力扣（LeetCode）\n\n\n\nc++代码如下\n\n```c++ \nclass Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        int N = piles.size();\n        pair<int, int> dp[1000][1000];\n        for (int i = 0; i < N; i++) \n            for (int j = i; j < N; j++){\n            dp[i][j].first = 0;\n            dp[i][j].second = 0;\n        }\n        for(int i=0;i<N;i++){\n            dp[i][i].first = piles[i];\n            dp[i][i].second = 0;\n        }\n        for(int i=0;i<N;i++){\n            for(int j=1;j<N;j++){\n                if(i+j<N) {\n                    int left = piles[i] + dp[i+1][i+j].second;\n                    int right = piles[j] + dp[i][i+j-1].second;\n                    dp[i][i+j].first = max(left, right);\n                    if(left > right){\n                        dp[i][i+j].second = dp[i+1][i+j].first;\n                    } else\n                        dp[i][i+j].second = dp[i][i+j-1].second;\n                }\n            }\n        }\n        return dp[0][N-1].first > dp[0][N-1].second;\n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"软件架构实践翻译&&笔记（三）--可修改性","url":"/2019/10/04/软件架构实践翻译&&笔记（三）--可修改性/","content":"\n### 可修改性\n\n#### Tactics\n\n##### 1. Reduce the Size of a Module\n\n- Split module：如果一个被修改的模块包含了大量职责，那么修改的代价就会很高。将大的模块细化成许多小的模块可以减少未来修改的平均代价。\n\n##### 2. Increase Cohesion\n\n增加内聚。将职责移交给另一个模块的目的是减少修改原模块职责的副作用 —— 使其不会影响到其他模块。\n\n- Increase semantic coherence：如果A和B的职责不是为了**服务同一个目的而存在**，那么它们应该被放在不同的模块中。可以新建一个模块或是移入一个已经存在的模块。识别需要迁移的职责的一个方法是假设可能发生的变化是如何影响模块的。如果一些职责不会被这些变化影响，那么这些职责应该被迁移。\n\n##### 3. Reduce Coupling\n\n- Encapsulate：封装赋予一个模块显式的接口。**此接口包括了应用编程接口API和它有关的职责**，例如\"对于输入的参数进行语法转化，使之转化成内部的表示\"。封装是最常见的一种可修改性策略，减少了修改一个模块而影响其他模块的可能性。耦合的强度现在转移到了接口上。这些强度大大减少了，因为接口限制了外部职责和内部模块的交互。外部的职责现在只要直接访问外部的接口就可以和模块交互（间接交互，但是，有些情况是不会改变的，例如依赖服务本身是不会改变的）。接口被设计来增加可修改性，它们应该是抽象的，屏蔽了模块可能改变的细节 —— 隐藏了这些细节。\n- Use an intermediary：**使用一个中介打破了依赖**。假设职责A和B之间有依赖关系（例如执行A之前要求先执行B），但是这种依赖关系可以由引入一个中介而被打破。中介的类型取决于依赖的类型。例如，发布订阅中介将会移除数据生产者对于消费者所必要的认知。数据仓库也是同样如此，它分离了数据的读取者和写入者。在面向服务的架构中，服务在一个动态的查找中互相发现，服务的目录就是一个中介。\n- Restrict dependencies：**限制一个模块依赖其他的模块。实践中是限制模块的可见性**（当开发者不能看见一个接口的时候，他们不能使用这些接口）**以及权限**。（限制权限，只供有权限的模块使用）这种策略被用于分层的架构中，每层只被允许调用下面的层。（有时仅仅是相邻的下一层）；以及用于包裹器中，外部的实体尽能见到（因此智能依赖）包裹器而不能见到它内部的功能。\n- Refactor：如果受到同一个变化影响的两个模块是相同的（至少部分相同），那么就要进行重构。代码重构是敏捷软件开发的一个重要支撑。**作为一个对于多余代码或者过度复杂的代码的清理**，这一思想也被用于软件架构中。常见的职责（以及实现它们的代码）被重构到模块之外并且分配到一个适当的位置。将相同职责的放在一起 —— 也就是让他们成为一个父模块的子模块 —— 可以减少耦合。\n- Abstract common services：**两个模块提供的不是相同的服务，但是是相似的服务，那么一个经济的方法是将它们实现一次**，实现成一个抽象的方式。任何一个对于此服务的修改只需要出现在一个地方，减少了修改的代价。一个引入抽象的方法是将描述（和实现）变成模块行为的参数。这种参数是足够简单的（例如关键变量的值），或复杂的（特定语言的复杂语句）。","tags":["读书笔记","架构","翻译"],"categories":["读书笔记","翻译"]},{"title":"素数筛法","url":"/2019/09/26/素数筛法/","content":"\n1. 判断单个数字n是否是素数，只需要依次从2判断到根号n即可\n\n2. 判断小于n有几个素数，就可以用筛法\n\n3. 判断[a, b]之间有几个素数，也可以转化成问题2\n\n\n\n![image-20190926200125757](/Users/cengshaoxun/Library/Application Support/typora-user-images/image-20190926200125757.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint prime[1000000];\nbool is_prime[1000000];\n\nint sieve(int n){\n    int p = 0;\n    for(int i = 0; i <= n; i++) is_prime[i] = true;\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i <= n; i++){\n        if(is_prime[i]){\n            prime[p++] = i;\n            for(int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n        }\n    }\n    return p;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    cout << sieve(n);\n    return 0;\n}\n```\n\n","tags":["数学问题"],"categories":["算法"]},{"title":"c++默认实参和重载","url":"/2019/09/24/c-默认实参和重载/","content":"\nc++函数的默认实参和重载混合之后的一些情况\n\n编程环境：\n\nApple clang version 11.0.0 (clang-1100.0.20.17)\n\n\n\n## 重复定义\n\n``` c++\n#include <iostream>\nusing namespace std;\n\nint func(int a,int b, int c = 1);\n\nint main()\n{\n    cout << \"func(1,2): \" << func(1,2) << endl;\n\n    return 0;\n}\n\nint func(int a,int b,int c = 1)  // 这种是错误的，重复定义了默认参数\n{\n    return a*b*c;\n}\n```\n\n函数声明中定义了c的默认实参，这时候如果在定义中又给了c默认实参，即使值相等，编译器也是会报错\n\n\n\n##无效重载\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint func(int a,int b, int c);\n\nint main()\n{\n    cout << \"func(1,2): \" << func(1,2,3) << endl;\n\n    return 0;\n}\n\nint func(int a,int b,int c = 0)  // 这种是无效的，因为声明是三个，所以参数必须是三个，默认参数不会用上\n{\n    return a*b*c;\n}\n```\n\n这种写法虽然不会报错，但是因为函数的使用要严格按照函数声明，所以实际上默认参数永远不会被用到\n\n\n\n## 头文件\n\n``` c++\n#include <iostream>\n#include \"c.h\"\nusing namespace std;\n\nint func(int a,int b=1, int c);\n\nint main()\n{\n    cout << \"func(1,2): \" << func(1) << endl;\n\n    return 0;\n}\n\nint func(int a,int b,int c)  // 这种是可以的，因为头文件中c是默认参数\n{\n    return a*b*c;\n}\n\n```\n\nc.h:\n\n```c++\nint func(int a,int b, int c = 3);\n```\n\n这种写法可以，在头文件中给c默认实参，cpp文件中给b默认实参，可以正确调用和赋值\n\n\n\n## 顺序颠倒\n\n```c++\n#include <iostream>\nusing namespace std;\n\n\nint func(int a,int b=1, int c);\nint func(int a,int b, int c=0);\n\nint main()\n{\n    cout << \"func(1,2): \" << func(1) << endl;\n\n    return 0;\n}\n\nint func(int a,int b,int c)  // 这种是不行的，因为放在最开头的那一个函数声明最右边是没有值的；调换顺序之后才可以\n{\n    return a*b*c;\n}\n```\n\n考虑到头文件其实是拷贝到文件的开头替换掉 #include，因此实际上第三个例子中c的默认实参是在b之前就给出了，如果颠倒了顺序，就报错\n\n\n\n## 总结\n\n1. 默认实参是要从右往左定义的，即右边的一定是默认实参\n2. 可以多次声明函数，多次声明的时候，不能再此定义同一个默认实参，即使值相同\n3. 多次声明的函数可以增加新的实参，但是也是遵循靠右原则，不能重复，顺序也不能颠倒\n4. 函数的定义中不需要写默认实参，写了也没用（会被声明覆盖）","tags":["c++","语法"],"categories":["c++"]},{"title":"软件架构实践翻译&&笔记（一）--可用性","url":"/2019/09/19/软件架构实践翻译&&笔记（一）可用性/","content":"\n### 可用性\n\n系统的可用时间占总时间的百分比\n\n#### Tactics\n\n##### 1. Detect Faults（检测错误）\n\n- Ping/echo：指的是一对节点之间异步的请求/相应信息，用来检测在相关联的网络路径上的的**可达性**和**延迟。**也用来决定被ping的组件（component）存活并且正确响应。ping通常是由一个系统监控器（monitor）发出。Ping/echo 要求设置一个**时间期限**(threshold)；这个时限告诉发出ping信号的组件要等待echo信号多久，否则就认为被ping的组件失效（超时）。一个ping/echo的标准实现是通过IP的节点互连。\n\n- Monitor：一个监视器（monitor）是一个用于**监视系统其他部分**（例如处理器，进程，IO，内存等）健康状态的组件。系统监视器可以**检测错误**或者**网络拥塞**，或者**其他共享资源**，例如拒绝服务攻击等。它使用这个分类中的**其他方法**检测故障组件，保证整个系统的协调运行。例如，系统监视器可以初始化自检测（self-tests），或者检测错误的时间戳、失常的心跳（heartbeats）。\n\n- Heartbeat：通过**在系统监视器（monitor）和被监视进程之间周期性的信息交换**来实现的一个错误检测机制。心跳的一个特殊例子是被监视进程周期性地重置系统监视器上的监视定时器（watchdog timer）来防止自身被认为失效（引发错误）。当一个系统的可扩展性是一个关注点的时候，传送和提前处理（心跳信息）可以通过如下方式来减少：**将心跳信息放在其他控制信息中**，在被监视进程和分布式系统控制器之间交换。心跳和ping/echo的一个极大的不同点是：谁来发起初始化心跳检测，是系统监视器还是组件自身（如果是monitor发起，那么是ping/echo；反之则是heartbeat）。\n\n  > watchdog：当一个检测机制是采用周期性地重制一个计数器或者计时器时，这个特殊的系统监视器就被称为watchdog。在一个流程中，被监视进程会周期性地重置此计数器或计时器来说明它正常工作，这有时被称作petting the watchdog。\n\n- Time stamp：这个策略（tactic）被用来**测检不正确的时间序列**，主要用在分布式的消息传送系统中。事件的时间戳可以用如下方式来建立：在事件发生后，立即设置一个**本地时钟的状态**给该事件。一串简单的**顺序数字**也可以被用作这个目的（如果时间信息不重要的话）。\n\n- Sanity checking：检查一个组件特定操作或者输出的**合理性和正确性**。这个策略基于内部设计—**系统的状态**或者**正常情况下的信息特性**。主要用于接口检测特定的信息流。\n\n- Condition monitoring：检查一个设备或者进程的**状态**，或者**验证**设计过程中的猜想。通过检测状态（condition），此策略防止系统产生出错误的行为。计算检验和（checksums）是一个典型的例子。但是，监视器（monitor）本身必须是足够**简单的（形式完美的（ideally），可被证明的（provable））**来确保它不会引发新的错误。（*PS（译者注）*：例如检验和的算法必须是数学上证明正确的）。\n\n- Voting：这个策略最普遍的实现是三模块冗余（TMR）——用三个模块来做相同的事情，每一个模块接收相同的输入，并将他们产生的结果输入投票逻辑（logic），用来检测三个输出是否一致。如果不一致，那么投票机制会**报告一个错误**，而且它也必须**决定采取哪一个输出**。采用多数原则，或者计算不同输出的平均值。这个策略严重依赖于具体的投票逻辑，这个逻辑通常是简单的，被严格检验和测试过的，以确保发生错误的概率尽量低。\n\n- Replication：投票（voting）机制的简单形式。**组件互相复制**（clones）。有多个组件的拷贝可以有效地**防止硬件的随机错误**，但是这**不能保证软件或者硬件中设计或者实现的错误**，因为这个策略没有多样性。（*PS（译者注）*：其实是同一个组件，不过有好几份，所以如果组件本身逻辑有错误，那么错误依然会发生；投票机制中多个组件可以是不同实现的，只不过期望的功能相同。）\n\n- Functional redundancy：投票策略的一个形式，用来解决软件或者硬件中**设计或者实现的错误**。基于相同的输入，组件必须给出相同的输出，但是他们设计和实现上是不同的。（*PS（译者注）*：这个就是上面那种情况的升级版，即几个组件只是**功能上的冗余**，实现并不相同）。\n\n- Analytic redundancy：不仅允许设计和实现的不同，还**允许组件输入输出不同**。这个策略容忍规格上的的错误——通过使用不同的需求规格（？？？）。在嵌入式系统中，分析冗余（analytic redundancy）用于**输入资源不可获得**的情况下。例如航空程序有多种方法可以计算飞机海拔，例如气压方法，雷达方法或者通过直线距离和仰角等来计算。这种使用分析冗余的投票机制相比于多数原则或计算平均值需要考虑得更多。它可能需要理解哪一个传感器是可靠的，而且有可能需要给出一个**比任何组件具有更高可信度**的值 —— 通过分析和综合各个不同的结果。\n\n- Exception detection：检测系统中改变正常执行流程的状态，可被进一步细分：\n\n  1. System exceptions：处理器硬件架构，除0错误，总线错误，地址错误，非法程序指令等。\n  2. Parameter fence：采用一个预先确定好的数据格式来替换一个对象的可变长参数。这允许运行时检查重写对象可变长参数的内存分配的错误。\n  3. Parameter typing：用一个基础的类型来定义一些功能和数据长度、格式等。派生的类型用基础类型的功能来实现其他功能。用强类型来传递信息有更高的可用性——相比于弱类型看待任何类型都是字节流。当然任何设计都有权衡，当使用强类型时，获得了更高的可用性，但是丧失了部分演化（evolution）的便捷。 \n  4. Timeout：当一个组件检测到它或者其他组件超过规定的**时间期限**时，抛出一个异常。例如，当一个组件等待另一个组件响应的时候，当等待时间超过一个确定的值时，抛出一个异常。\n\n- Self-test：组件（或者整个子系统）可以运行一个程序来检测自身是否执行正确的操作。自测程序可以由**组件自己发起**，或者时不时地由一个**系统监视器发起**。它们可能会用一些条件监控中的策略，例如检验和等。\n\n##### 2. Recover from Faults（从错误状态恢复）\n\n**2.1 Preparation-and-repaire**\n\n这种策略包含了大量重试以及冗余策略。\n\n- Active redundancy(hot spare)：在一个保护组（见注解）所有节点（主节点或者冗余节点）**同时接收并且处理相同的输入**，这保证了冗余节点和主节点保持同步状态。由于冗余备份和主节点有着相同的状态，所以在主节点失效时，它可以很快地接替主节点。一个简单的情况是一个主节点配备一个冗余节点 —— 这被称为1+1冗余。Active redundancy也可以被用作设备保护，主要的网络连接和备用的网络连接一同确保网络连接的高可用性。\n\n  注：protection group指的是一群工作节点，这些节点中有一个或者多个节点是\"active\"（主节点），剩下的节点是冗余备份。\n\n- Passive redundancy(warm spare)：在一个保护组中，**只有主节点处理输入**，它们周期性地给冗余节点提供更新。因为冗余节点的状态和主节点的状态并**不是完全同步**（loosely coupled），这种冗余节点也被叫做warm spares。取决于系统的可用性需求程度，**被动的冗余提供了一个折衷方案**，即在高可用但是计算更加密集的active redundancy和低可用但是更简单的cold spare中做权衡。\n\n- Spare(cold spare)：Cold sparing指的是在一个保护组中，冗余节点完全不工作，直到一个错误发生。这时，**在冗余节点能提供服务之前，必须要执行一个启动程序**。由于恢复的性能低下，cold sparing更适用于只有高可靠的需求而不适用于有高可用的需求的系统。\n\n- Exception handling：一旦检测到一个异常，系统必须以某种方式来处理异常。**最简单的情况是崩溃，但是从可用性，易用性，可测试性和直觉上考虑，这是一个糟糕的主意**。处理异常的机制很大程度上取决于所使用的**编程环境**，从简单地返回错误码到复杂的异常类。软件可以用异常类包含的各种信息来检查错误。\n\n- Rollback：**这个策略允许系统返回到前一个已知的正确状态**，在检测到错误的时候进行时间的回滚。一旦达到了正确状态，那么程序就可以继续运行。**这个策略常常和active或者passive redundancy一起使用，这样的话，当回滚发生的时候，备用版本就可以替换主版本**。回滚依赖于前一个正确状态的**备份（检查点）是可获得的**。检查点可以存储在一个**固定的位置并且被定期更新，或者在一些方便或者重要的时候更新**，例如一个复杂操作完成的时候。\n\n- Software upgrade：**在系统运行的时候更新可执行代码而不影响正常的服务**。实现方式可以是一个函数的补丁，或者类的补丁，或者无中断运行中软件更新（ISSU）。函数补丁用于结构化编程中，使用一个增加的linker或者loader来将更新后的函数装载到预先分配好的目标内存位置中。**新版本的函数会使用弃用函数的入口和出口**。而且，装载新函数的时候，符号表必须被更新，并且之前的指令缓存也要被认为是非法的。**类补丁用于面向对象设计中**。类的定义中包含了一个后门，这可以用来在运行中加入新的成员函数和函数。（PS*译者注：*例如java中的反射）ISSU利用了active或者passive redundancy策略来达到更新但是不影响软件正常提供服务。在实践中，函数补丁和类补丁用于修复bug，而ISSU用于提供新功能。\n\n- Retry：重试策略假设引起失效的错误是**瞬时**的，并且**重试这个操作可能可以成功**。这个策略用于网络和服务器，在这些地方失效被认为是常态。应该**限制重试的次数**，超过这个次数就认为永久失效。\n\n- Ignore faulty behavior：这个策略**忽略特定来源**的信息，这些信息被认为是伪造的。例如，我们会忽略来自引发拒绝服务访问的外部组件的信息，这可以通过建立访问控制列表来完成。\n\n- Degradation：此策略在系统失效的时候，只维持**最为重要的系统功能**，而放弃次要的功能。当某个组件的失效**只是降低了系统的功能而不是导致整个系统失效**的时候，我们可以采用此功能。\n\n- Reconfiguration：此策略通过给仍在发挥作用的资源（很可能是受限的）**重新分配职责**，尝试从组件的错误中恢复。以此来维持尽可能多的功能可用。（PS*译者注：例如windows的安全模式*）\n\n**2.2 Reintroduction**\n\n这种策略用于失效组件在被修正后重新引入。\n\n- Shadow：这个策略指的是运行一个**先前失效**的或是**服务中更新(in-service upgraded)**的组件在一个\"影子模式\"中，持续一段预先定好的时间后，让组件重新回到正常的工作状态。在这段持续时间中，组件的行为会被监视，并且它可以重新恢复它的状态。\n- State resynchronization：此策略适用于active redundancy和passive redundancy这两种preparation-and-repair策略的重引入。当使用active redundancy策略的时候，状态重同步有组织地发生，因为主组件和备用组件同时各自接收和处理相同的输入。**在实践中，主组件和备用组件周期性地互相比较来确保同步**。这种比较可能是基于循环冗余校验或者系统提供的安全服务，例如一种信息摘要计算(message digest calculation)。当使用passive redundancy策略时，**状态的重同步只是基于主组件周期性地给备用组件传递信息，通常是通过检查点的方式**。这种策略的一个特殊例子是无状态服务，任何一种资源可以响应一个已经失效的资源的请求。\n- Escalating restart：此策略允许系统**调整组件重启的粒度**，**减小受影响的服务范围**来从一个失效中恢复过来。例如，假设一个系统支持4个等级的重启。最低等级的重启（等级0），对服务有最小的影响，使用passive redundancy，错误组件的所有子线程被杀死和重新创建。通过这种方法，只有关联于子线程的数据会被释放和重新初始化。下一个等级（等级1）的重启会释放和初始化所有不受保护的内存（保护中的内容不受影响）。再下一个等级（等级2）释放和重新初始化所有的内存，包括所有受保护和不受保护的部分，强迫所有的应用重新加载并重新初始化。最后一个等级（等级3）完全重新加载和重新初始化可执行映像和所有有关的数据段。**支持范围重启策略对降级(graceful degradation)特别有用**。系统能够减少它提供的服务，并且维持一些重要的任务和安全相关的应用。\n- Non-stop forwarding(NSF)：这个概念来源于路由器设计。在这个设计中，功能被分为两个部分：**监视，或控制通路（管理着连通性和路由信息），和数据通路（在发送者和接收者之间交换包）**如果路由的监控部分失效，那么它仍然可以在已知的路由器（邻居路由器）中继续传输包；当控制通路被重启时——有时被称为是\"graceful restart\" —— 增量重建路由协议数据库，此时数据通路仍然在继续工作。\n\n##### 3. Prevent Faults（预防错误）\n\n- Removal from service：次策略指的是**暂时将一个系统组件从工作状态切换成非工作状态，为了减轻潜在的系统失效**。一个例子是终止和重启一个组件，使得潜在的错误（例如内存泄漏，碎片化，或在不受保护的缓存中的软错误（soft errors））不会累积从而影响正常服务。此策略的另一个名称是软件再生（software rejuvenation）。\n- Transactions：高可用的系统服务降低事务的语义来保证在分布式的组件中传递的同步信息是**原子的(atomic)、一致的(consistent)、分离(isolated)的和可持久(durable)的**。这四个属性被称为ACID属性。最常见的实现是\"two-phase commit\"协议。这个策略阻止了竞争情况，这种情况是由两个进程同时试图更新相同的数据引起的。\n- Predictive model：一个预测模型，和一个监视器结合，用来监视系统进程的健康状态，**确保系统的操作是基于预定的操作参数，并且当预测到发生错误的可能性时，可以采取正确的措施**。被监视的操作性能指标用来预测错误的发生，这样的例子包括session建立的频率（在一个HTTP server中），跨越阈值（对一些约束检测预警线的高低），或是维持进程状态的数据（服务中，不在服务中，维修中，等待中），消息队列长度数据等等。\n- Exception prevention：此策略预防系统发生异常。**异常类的使用**，允许系统从异常状态恢复而不被用户感知，这之前已经讨论过了。另一个阻止异常的例子包括**一些抽象数据类型**，例如智能指针，以及用包裹器来预防错误，例如野指针和信号量反问违规。智能指针通过指针边界检查和确保资源被正确回收来预防错误发生。\n- Increase competence set：**一个程序的功能集合指的是状态的集合，这种状态是它能够进行操作的**。例如，分母为0的情况超出了大部分除法程序的功能范围。当一个组件抛出一个异常时，表明它发现情况超出了它的功能范围；本质上，它并不知道如何解决，因此抛出了异常。**增加一个组件的功能集合意味着将它设计地能处理更多情况 —— 错误 —— 也成为了正常操作的一部分**。例如，一个组件假设它有权限访问共享资源，当它发现它的权限被阻止的时候，它可能会抛出一个异常；另一个组件可能只是会一直等待授予权限，或者立即返回，并带有一个提示 —— 下次它有权限的时候，它将完成此操作。在这个例子中，第二个组件相比第一个有着更大的功能集合。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["读书笔记","架构","翻译"],"categories":["读书笔记","翻译"]},{"title":"乘积最大子序列","url":"/2019/09/10/乘积最大子序列/","content":"\n# 题目\n\n给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。\n\n示例 1:\n\n输入: [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n示例 2:\n\n输入: [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximum-product-subarray\n\n# 思路\n\n连续最大的乘积序列，可以考虑什么时候连乘会变小—有时候是0，有时候是负数\n\n对于负数而言，他会让之前正数连乘的积变成最小；同时也会让之前的负数连乘变成最大。因此我们要保留两个值：之前连乘的最大和最小值\n\n对于可能出现0的情况，其实不用考虑，因为此时连乘的最大最小值都是0\n\n为了保证每次都可以得到连乘的max和min，在每次计算乘积的时候，都要取计算的结果和当前位置的max或者min。例如，计算连乘max的时候，MAX = max(MAX*nums[i], nums[i])\n\n遇到负数，交换最大最小，再计算\n\n\n\n# 题解\n\n参考：https://leetcode-cn.com/problems/maximum-product-subarray/solution/hua-jie-suan-fa-152-cheng-ji-zui-da-zi-xu-lie-by-g/\n\n\n``` c++\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int result = -100000;\n        int Max = 1;\n        int Min = 1;\n        for(int i=0; i<nums.size(); i++){\n            if(nums[i]<0) {\n                int temp = Max;\n                Max = Min;\n                Min = temp;\n            }\n            Max = max(Max*nums[i], nums[i]);\n            Min = min(Min*nums[i], nums[i]);\n            \n            result = max(result, Max);\n        }\n        return result;\n    }\n};\n```\n\n\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"单词拆分","url":"/2019/09/06/单词拆分/","content":"\n# 题目\n\n给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n\n说明：\n\n拆分时可以重复使用字典中的单词。\n你可以假设字典中没有重复的单词。\n示例 1：\n\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。\n示例 2：\n\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。\n     注意你可以重复使用字典中的单词。\n示例 3：\n\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/word-break\n\n# 思路\n\n刚开始只想到了暴力搜索\n\n可以用DFS、BFS还有剪枝之后的DFS\n\n\n\n如果用动态规划的话，可以这样考虑：\n\n首先令dp数组的第i项表示从0开始到位置i的串可以被拆分，这样只要取出最后一个位置就是题解\n\n其次为了利用前面的dp数组位置，可以将串拆分为两部分，一部分必然被前面的情况包含，另一部分再判断即可\n\n\n\n# 题解\n\n参考了官方题解\n\n这个方法的想法是对于给定的字符串（s）可以被拆分成子问题 s1 和 s2。如果这些子问题都可以独立地被拆分成符合要求的子问题，那么整个问题 s 也可以满足。也就是，如果 \"\ncatsanddog\" 可以拆分成两个子字符串 \"catsand\" 和 “dog\" 。子问题 \"catsand\" 可以进一步拆分成 \"cats\" 和 \"and\" ，这两个独立的部分都是字典的一部分，所以 \"catsand\" 满足题意条件，再往前， \"catsand\" 和 ”dog\" 也分别满足条件，所以整个字符串 \"catsanddog\" 也满足条件。\n\n现在，我们考虑 dp 数组求解的过程。我们使用 n+1 大小数组的 dp ，其中 n 是给定字符串的长度。我们也使用 2 个下标指针 i 和 j ，其中 i 是当前字符串从头开始的子字符串（s ′ ）的长度， j 是当前子字符串（s ′ ）的拆分位置，拆分成 s ′ (0,j) 和 s′(j+1,i)。为了求出 dp 数组，我们初始化 dp[0] 为 true ，这是因为空字符串总是字典的一部分。 dp 数组剩余的元素都初始化为 false 。我们用下标 i 来考虑所有从当前字符串开始的可能的子字符串。对于每一个子字符串，我们通过下标 j 将它拆分成 s1 ′ 和 s2 ′（注意 i 现在指向 s2 ′  的结尾）。为了将dp[i] 数组求出来，我们依次检查每个 dp[j] 是否为 true ，也就是子字符串 s1 ′ 是否满足题目要求。如果满足，我们接下来检查 s2 ′ 是否在字典中。如果包含，我们接下来检查 s2 ′ 是否在字典中，如果两个字符串都满足要求，我们让 dp[i] 为 true ，否则令其为 \nfalse 。\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/word-break/solution/dan-ci-chai-fen-by-leetcode/\n来源：力扣（LeetCode）\n\n\n\nc++代码如下\n\n``` c++ \nclass Solution {\nprivate:\n    bool contain(string s, vector<string> v){\n        for(string ss: v){\n            if(ss == s){\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        bool dp[s.size()+1];\n        dp[0] = true;\n        for(int i=1; i<=s.size(); i++){\n            for(int j=0; j<i; j++){\n                dp[i] = false;\n                if(dp[j] && contain(s.substr(j, i-j), wordDict)){\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.size()];\n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"三角形最小路径和","url":"/2019/09/05/三角形最小路径和/","content":"\n# 题目\n\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n\n例如，给定三角形：\n\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/triangle\n\n# 思路\n\n注意两点：\n\n1. 不能从上往下的贪婪，而是要从下往上的贪婪\n2. 从下而上的贪婪可以保证当前位置到最低点的路径和是最大的。自然到了最高点，就可以求出最大值\n\n这是因为，基于当前的最优并不是全局最优，而从后往前则可以考虑全局\n\n\n\n用一位数组存储即可，边计算边保存，恰好不会被覆盖\n\n```\ndp[j] = min(dp[j], dp[j+1]) + triangle[i][j]\n```\n\n\n\n# 解法\n\n``` c++\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int dp[triangle.size()];\n        for(int k=0; k<triangle.size(); k++){\n            dp[k] = triangle[triangle.size()-1][k];\n        }\n        for(int i=triangle.size()-2; i>=0; i--){\n            for(int j=0; j<triangle[i].size(); j++){\n                dp[j] = min(dp[j], dp[j+1]) + triangle[i][j];\n            }\n        }\n        return dp[0];\n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"解码方法","url":"/2019/09/05/解码方法/","content":"\n# 题目\n\n一条包含字母 A-Z 的消息通过以下方式进行了编码：\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n给定一个只包含数字的非空字符串，请计算解码方法的总数。\n\n示例 1:\n\n输入: \"12\"\n输出: 2\n解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。\n示例 2:\n\n输入: \"226\"\n输出: 3\n解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/decode-ways\n\n# 思路\n\n这个和走楼梯的那题很像\n\n一段楼梯，一次可以走一个台阶，或者两个台阶，一共有多少种走法\n\n```\ndp[i] = dp[i-1] + dp[i-2]\n```\n\n这一题多了一个判断，即不是每个dp[i-1]和dp[i-2]都可以累加到dp[i]中，因为有可能有以下两种情况：\n\n1. 对于两个字符的情况\n\n   超过26的不行\n\n   04这种0开头的不行\n\n2. 对于一个字符的情况\n\n   0不行\n\n因此可以容易写出解\n\n\n\n# 解法\n\n``` c++\nclass Solution {\nprivate:\n    bool judge(string s){\n        return stoi(s)>0 && stoi(s)<27 && s[0] != '0';\n    }\npublic:\n    int dp[10000];\n    int numDecodings(string s) {\n        if(s.size()==1) return judge(s);\n        dp[0] = judge(s.substr(0, 1));\n        dp[1] = judge(s.substr(0, 2)) + (judge(s.substr(1, 1)) && judge(s.substr(0, 1)));\n        for(int i=2; i<s.size(); i++){\n            if(judge(s.substr(i, 1)) && s[i]!='0') dp[i] += dp[i-1];\n            if(judge(s.substr(i-1, 2))) dp[i] += dp[i-2];\n        }\n        return dp[s.size()-1];\n    }\n};\n```\n\n\n\n简化的写法来自网上：\n\n``` python\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        pp, p = 1, int(s[0] != '0')\n        for i in range(1, len(s)):\n            pp, p = p, pp * (9 < int(s[i-1:i+1]) <= 26) + p * (int(s[i]) > 0)\n        return p\n```\n\n\ni 从索引 1 开始逐渐遍历 s，当前位置对应结果 = 上上次结果(如果 i 位置字符和 i-1 位置字符的组合满足条件；即满足在9-27之间) + 上次结果(如果 s[i] 不为 0)\n\n作者：QQqun902025048\n链接：https://leetcode-cn.com/problems/decode-ways/solution/4-xing-python-dp-onshi-jian-o1kong-jian-by-qqqun90/\n来源：力扣（LeetCode）\n\n\n\n\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"最小路径和","url":"/2019/09/05/最小路径和/","content":"\n# 题目\n\n给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n示例:\n\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/minimum-path-sum\n\n# 思路\n\n思路和https://leetcode-cn.com/problems/min-cost-climbing-stairs一致\n\n```c++\ndp[i][j] = min(dp[i-1][j], dp[i][j-1]) + arr[i][j]\n```\n\n # 解法\n\n``` c++\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int a = grid.size();\n        int b = grid[0].size();\n        int dp[a][b];\n        dp[0][0] = grid[0][0];\n        for(int i=0; i<a; i++){\n            for(int j=0; j<b; j++){\n                if(i>0 && j>0) dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n                else if(j>0) dp[i][j] = dp[i][j-1] + grid[i][j];\n                else if(i>0) dp[i][j] = dp[i-1][j] + grid[i][j];\n            }\n        }\n        return dp[a-1][b-1];\n    }\n};\n```\n\n还可以用一维数组优化一下，只需要用到上面一行和前一个位置即可","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"最长回文子串","url":"/2019/09/04/最长回文子串/","content":"\n# 题目\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n示例 1：\n\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n示例 2：\n\n输入: \"cbbd\"\n输出: \"bb\"\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring\n\n# 思路\n\n首先能想到的一个思路是获得所有子串，判断是否是回文，再取最长的\n\n稍微优化一下就是，遍历每一个字符，作为中心点，向两边扩展，这样可以直接判断是否是回文，然后长度也可以直接求出\n\n注意这里中心点可以是一个，例如aba；也可以是两个，例如abba\n\n\n\n# 解法\n\n这里因为两种情况的扩展是相似的，所以可以抽象成一个函数，不同的是传入的参数来控制中心点是一个还是两个\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode/\n来源：力扣（LeetCode）\n\n``` java\npublic String longestPalindrome(String s) {\n    if (s == null || s.length() < 1) return \"\";\n    int start = 0, end = 0;\n    for (int i = 0; i < s.length(); i++) {\n        int len1 = expandAroundCenter(s, i, i);\n        int len2 = expandAroundCenter(s, i, i + 1);\n        int len = Math.max(len1, len2);\n        if (len > end - start) {\n            start = i - (len - 1) / 2;\n            end = i + len / 2;\n        }\n    }\n    return s.substring(start, end + 1);\n}\n\nprivate int expandAroundCenter(String s, int left, int right) {\n    int L = left, R = right;\n    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {\n        L--;\n        R++;\n    }\n    return R - L - 1;\n}\n```\n\n\n\n评论下面还有两个方法可以优化\n\n1. 字符中间插入特殊字符，来同一个两种中心点\n\n2. 马拉车算法\n\n   https://segmentfault.com/a/1190000008484167","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"最大正方形","url":"/2019/09/04/最大正方形/","content":"\n# 题目\n\n在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。\n\n示例:\n\n输入: \n\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n\n输出: 4\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/maximal-square\n\n# 思路\n\n只想到一个暴力的思路就是先对每行遍历，找到连续的1就开始向每一列搜索，看看是否组成正方形，如果确实组成正方形，就更新最大边长\n\n\n\n# 解法\n\n参考leetcode官方题解：\n\n作者：LeetCode\n链接：https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode/\n来源：力扣（LeetCode）\n\n![image](https://s2.ax1x.com/2019/09/04/nZ53Of.png)\n\n对照着写的代码：\n\n``` c++\nclass Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if(matrix.size()==0) return 0;\n        int max = 0;\n        int dp[matrix.size()][matrix[0].size()];\n        for(int i=0; i<matrix.size(); i++){\n            for(int j=0; j<matrix[0].size(); j++){\n                if(i>0 && j>0 && matrix[i][j]=='1'){\n                    dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1;\n                    max = dp[i][j]>max?dp[i][j]:max;\n                } else if(matrix[i][j]=='1') {\n                    dp[i][j] = 1;\n                    max = dp[i][j]>max?dp[i][j]:max;\n                }\n                else dp[i][j] = 0;\n            }\n        }\n        return max*max;\n    }\n};\n```\n\n","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"使用最小花费爬楼梯","url":"/2019/09/04/使用最小花费爬楼梯/","content":"\n# 题目\n\n数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。\n\n每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。\n\n您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。\n\n示例 1:\n\n输入: cost = [10, 15, 20]\n输出: 15\n解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。\n 示例 2:\n\n输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n输出: 6\n解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。\n注意：\n\ncost 的长度将会在 [2, 1000]。\n每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs\n\n# 思路\n\n如果便利所有情况的话显然过于复杂，具体的情况数应该是斐波那契数列的某一项，复杂度太高。\n\n如果考虑用贪婪的话也不太对，因为存在一种情况是首选一个花费较大的，但是之后可能存在一个花费更小的，例如 [0, 1, 2, 2]，如果是贪婪的话选择0-1-2，但是最小的花费应该是0-2\n\n用贪婪的问题是，这实际上是一个累加的问题，不是基于当前情况就能判断的问题，必须要是前面所有的积累\n\n故而就想到遍历所有情况，因为若是不知道之后的情况，似乎也是没法确定是否选择当前的走法\n\n这时候就要转化一下思路，想一想dp的解法\n\ndp的解法是：\n\ndp[i] = min(dp[i-1],dp[i-2]) + cost[i] （第0和第1个位置是dp的初始值）\n\n即要走到第i个台阶，考虑它之前的两个台阶，取小的那个加上当前台阶的花费即可。这样当我们求出最后两个台阶的dp时，就可以取小的那个，然后走完全部台阶\n\n\n\n# 解法\n\n按照上面的想法翻译一下代码即可，需要注意的是最后还要判断一下dp的最后两个位置，取小的值作为结果返回\n\n``` c++\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        // dp[i] = min(dp[i-1],dp[i-2]) + cost[i]\n        int a = cost[0], b = cost[1];\n        int c = 0;\n        for(int i=2; i<cost.size(); i++){\n            c = a>b?b:a;\n            c += cost[i];\n            a = b;\n            b = c;\n        }\n        return a>c?c:a;\n    }\n};\n```\n\n\n\n# 总结\n\n写出状态转移方程就会清晰很多","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"判断子序列","url":"/2019/09/03/判断子序列/","content":"\n# 题目\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n\n你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。\n\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。\n\n示例 1:\ns = \"abc\", t = \"ahbgdc\"\n\n返回 true.\n\n示例 2:\ns = \"axc\", t = \"ahbgdc\"\n\n返回 false.\n\n后续挑战 :\n\n如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/is-subsequence\n\n# 思路\n\n原题没什么好说的，直接一个循坏找出来就行了\n\n``` c++\nclass Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        int i=0;\n        if(s.size()==0) return true;\n        bool flag = false;\n        for(char c: t){\n            if(c==s[i]){\n                i++;\n            }\n            if(i==s.size()){\n                flag = true;\n                break;\n            }\n        }\n        return flag;\n    }\n};\n```\n\n扩展部分没什么好的思路，就直接看题解了\n\n\n\n# 题解\n\n作者：zzzzzz-5\n链接：https://leetcode-cn.com/problems/is-subsequence/solution/cpan-duan-zi-xu-lie-hou-xu-tiao-zhan-by-zzzzzz-5/\n\n后续挑战，输入量大，小写字母创建25的二维数组，存储t的坐标，这样就可以把s的判断直接转为坐标的判断，\ndp[0]代表了存储了a出现在t的所有的位置,逐个字符判断s的字符顺序是否在t内，直接返回结果。\n时间复杂度O(t.size()+2000)：分别为创建数组需要O(t.size()),\n索引是递增的使用二分查找s的单个字符20次之内就可找到需要O(100*20)。\n适用大量的输入判断子序列。\n\n``` c++\nbool isSubsequence(string s, string t) {      \n  vector<vector<int>>dp(26);\n  int tag=-1;\n  for(int i=0;i<t.size();i++)\n    dp[t[i]-'a'].push_back(i);\n  for(int i=0;i<s.size();i++){\n    int now=s[i]-'a';\n    int left=0,right=dp[now].size()-1;            \n    if(right<0) return false;\n    while(left<right){\n      int mid=(left+right)/2;\n      if(dp[now][mid]>tag)\n        right=mid;\n      else\n        left=mid+1;\n    }\n    if(right<left || dp[now][left]<tag)return false;\n    tag=dp[now][left];\n  }\n  return true;\n}\n```\n\n不需要存储所有的字串，而是存下长字符串的坐标，然后对每个短的字串再判断\n对于每个短的串，一个小循环：对每个字符，先找到比前一个字符的坐标（tag）大的最小坐标（更新为下一个tag）；第一个字符只要初始化tag=-1即可找到第一个字符的最小坐标\n用二分查找，right对应的数设置为比mid大的数，这样如果存在比tag大的数，left最终会等于right，且那个位置一定是要找的那个数；如果不存在，那么最后left和right都会等于原来的right，最后判断一下dp[now][left]和tag的大小即可\n注意二分查找退出的时候，其实是不会出现right<left的情况的，只有可能是找到那个数或者dp[now][left]<tag，这时候即找不到比前一个tag大的位置，故而返回false","tags":["动态规划","刷题"],"categories":["算法"]},{"title":"Emacs Org-mode 笔记","url":"/2019/08/12/emacs笔记/","content":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">\n<head>\n<!-- 2019-08-12 Mon 11:24 -->\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" />\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n<title>Emacs Org-mode 笔记</title>\n<meta name=\"generator\" content=\"Org mode\" />\n<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/\n  .title  { text-align: center;\n             margin-bottom: .2em; }\n  .subtitle { text-align: center;\n              font-size: medium;\n              font-weight: bold;\n              margin-top:0; }\n  .todo   { font-family: monospace; color: red; }\n  .done   { font-family: monospace; color: green; }\n  .priority { font-family: monospace; color: orange; }\n  .tag    { background-color: #eee; font-family: monospace;\n            padding: 2px; font-size: 80%; font-weight: normal; }\n  .timestamp { color: #bebebe; }\n  .timestamp-kwd { color: #5f9ea0; }\n  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }\n  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }\n  .org-center { margin-left: auto; margin-right: auto; text-align: center; }\n  .underline { text-decoration: underline; }\n  #postamble p, #preamble p { font-size: 90%; margin: .2em; }\n  p.verse { margin-left: 3%; }\n  pre {\n    border: 1px solid #ccc;\n    box-shadow: 3px 3px 3px #eee;\n    padding: 8pt;\n    font-family: monospace;\n    overflow: auto;\n    margin: 1.2em;\n  }\n  pre.src {\n    position: relative;\n    overflow: visible;\n    padding-top: 1.2em;\n  }\n  pre.src:before {\n    display: none;\n    position: absolute;\n    background-color: white;\n    top: -10px;\n    right: 10px;\n    padding: 3px;\n    border: 1px solid black;\n  }\n  pre.src:hover:before { display: inline;}\n  /* Languages per Org manual */\n  pre.src-asymptote:before { content: 'Asymptote'; }\n  pre.src-awk:before { content: 'Awk'; }\n  pre.src-C:before { content: 'C'; }\n  /* pre.src-C++ doesn't work in CSS */\n  pre.src-clojure:before { content: 'Clojure'; }\n  pre.src-css:before { content: 'CSS'; }\n  pre.src-D:before { content: 'D'; }\n  pre.src-ditaa:before { content: 'ditaa'; }\n  pre.src-dot:before { content: 'Graphviz'; }\n  pre.src-calc:before { content: 'Emacs Calc'; }\n  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }\n  pre.src-fortran:before { content: 'Fortran'; }\n  pre.src-gnuplot:before { content: 'gnuplot'; }\n  pre.src-haskell:before { content: 'Haskell'; }\n  pre.src-hledger:before { content: 'hledger'; }\n  pre.src-java:before { content: 'Java'; }\n  pre.src-js:before { content: 'Javascript'; }\n  pre.src-latex:before { content: 'LaTeX'; }\n  pre.src-ledger:before { content: 'Ledger'; }\n  pre.src-lisp:before { content: 'Lisp'; }\n  pre.src-lilypond:before { content: 'Lilypond'; }\n  pre.src-lua:before { content: 'Lua'; }\n  pre.src-matlab:before { content: 'MATLAB'; }\n  pre.src-mscgen:before { content: 'Mscgen'; }\n  pre.src-ocaml:before { content: 'Objective Caml'; }\n  pre.src-octave:before { content: 'Octave'; }\n  pre.src-org:before { content: 'Org mode'; }\n  pre.src-oz:before { content: 'OZ'; }\n  pre.src-plantuml:before { content: 'Plantuml'; }\n  pre.src-processing:before { content: 'Processing.js'; }\n  pre.src-python:before { content: 'Python'; }\n  pre.src-R:before { content: 'R'; }\n  pre.src-ruby:before { content: 'Ruby'; }\n  pre.src-sass:before { content: 'Sass'; }\n  pre.src-scheme:before { content: 'Scheme'; }\n  pre.src-screen:before { content: 'Gnu Screen'; }\n  pre.src-sed:before { content: 'Sed'; }\n  pre.src-sh:before { content: 'shell'; }\n  pre.src-sql:before { content: 'SQL'; }\n  pre.src-sqlite:before { content: 'SQLite'; }\n  /* additional languages in org.el's org-babel-load-languages alist */\n  pre.src-forth:before { content: 'Forth'; }\n  pre.src-io:before { content: 'IO'; }\n  pre.src-J:before { content: 'J'; }\n  pre.src-makefile:before { content: 'Makefile'; }\n  pre.src-maxima:before { content: 'Maxima'; }\n  pre.src-perl:before { content: 'Perl'; }\n  pre.src-picolisp:before { content: 'Pico Lisp'; }\n  pre.src-scala:before { content: 'Scala'; }\n  pre.src-shell:before { content: 'Shell Script'; }\n  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }\n  /* additional language identifiers per \"defun org-babel-execute\"\n       in ob-*.el */\n  pre.src-cpp:before  { content: 'C++'; }\n  pre.src-abc:before  { content: 'ABC'; }\n  pre.src-coq:before  { content: 'Coq'; }\n  pre.src-groovy:before  { content: 'Groovy'; }\n  /* additional language identifiers from org-babel-shell-names in\n     ob-shell.el: ob-shell is the only babel language using a lambda to put\n     the execution function name together. */\n  pre.src-bash:before  { content: 'bash'; }\n  pre.src-csh:before  { content: 'csh'; }\n  pre.src-ash:before  { content: 'ash'; }\n  pre.src-dash:before  { content: 'dash'; }\n  pre.src-ksh:before  { content: 'ksh'; }\n  pre.src-mksh:before  { content: 'mksh'; }\n  pre.src-posh:before  { content: 'posh'; }\n  /* Additional Emacs modes also supported by the LaTeX listings package */\n  pre.src-ada:before { content: 'Ada'; }\n  pre.src-asm:before { content: 'Assembler'; }\n  pre.src-caml:before { content: 'Caml'; }\n  pre.src-delphi:before { content: 'Delphi'; }\n  pre.src-html:before { content: 'HTML'; }\n  pre.src-idl:before { content: 'IDL'; }\n  pre.src-mercury:before { content: 'Mercury'; }\n  pre.src-metapost:before { content: 'MetaPost'; }\n  pre.src-modula-2:before { content: 'Modula-2'; }\n  pre.src-pascal:before { content: 'Pascal'; }\n  pre.src-ps:before { content: 'PostScript'; }\n  pre.src-prolog:before { content: 'Prolog'; }\n  pre.src-simula:before { content: 'Simula'; }\n  pre.src-tcl:before { content: 'tcl'; }\n  pre.src-tex:before { content: 'TeX'; }\n  pre.src-plain-tex:before { content: 'Plain TeX'; }\n  pre.src-verilog:before { content: 'Verilog'; }\n  pre.src-vhdl:before { content: 'VHDL'; }\n  pre.src-xml:before { content: 'XML'; }\n  pre.src-nxml:before { content: 'XML'; }\n  /* add a generic configuration mode; LaTeX export needs an additional\n     (add-to-list 'org-latex-listings-langs '(conf \" \")) in .emacs */\n  pre.src-conf:before { content: 'Configuration File'; }\n\n  table { border-collapse:collapse; }\n  caption.t-above { caption-side: top; }\n  caption.t-bottom { caption-side: bottom; }\n  td, th { vertical-align:top;  }\n  th.org-right  { text-align: center;  }\n  th.org-left   { text-align: center;   }\n  th.org-center { text-align: center; }\n  td.org-right  { text-align: right;  }\n  td.org-left   { text-align: left;   }\n  td.org-center { text-align: center; }\n  dt { font-weight: bold; }\n  .footpara { display: inline; }\n  .footdef  { margin-bottom: 1em; }\n  .figure { padding: 1em; }\n  .figure p { text-align: center; }\n  .equation-container {\n    display: table;\n    text-align: center;\n    width: 100%;\n  }\n  .equation {\n    vertical-align: middle;\n  }\n  .equation-label {\n    display: table-cell;\n    text-align: right;\n    vertical-align: middle;\n  }\n  .inlinetask {\n    padding: 10px;\n    border: 2px solid gray;\n    margin: 10px;\n    background: #ffffcc;\n  }\n  #org-div-home-and-up\n   { text-align: right; font-size: 70%; white-space: nowrap; }\n  textarea { overflow-x: auto; }\n  .linenr { font-size: smaller }\n  .code-highlighted { background-color: #ffff00; }\n  .org-info-js_info-navigation { border-style: none; }\n  #org-info-js_console-label\n    { font-size: 10px; font-weight: bold; white-space: nowrap; }\n  .org-info-js_search-highlight\n    { background-color: #ffff00; color: #000000; font-weight: bold; }\n  .org-svg { width: 90%; }\n\n</style>\n<script type=\"text/javascript\">\n\nfunction CodeHighlightOn(elem, id)\n {\n   var target = document.getElementById(id);\n   if(null != target) {\n     elem.cacheClassElem = elem.className;\n     elem.cacheClassTarget = target.className;\n     target.className = \"code-highlighted\";\n     elem.className   = \"code-highlighted\";\n   }\n }\n function CodeHighlightOff(elem, id)\n {\n   var target = document.getElementById(id);\n   if(elem.cacheClassElem)\n     elem.className = elem.cacheClassElem;\n   if(elem.cacheClassTarget)\n     target.className = elem.cacheClassTarget;\n }\n\n</script>\n</head>\n<body>\n<div id=\"content\">\n<div id=\"table-of-contents\">\n<h2>Table of Contents</h2>\n<div id=\"text-table-of-contents\">\n<ul>\n<li><a href=\"#org6a7ea47\">1. Emacs 笔记</a>\n<ul>\n<li><a href=\"#orga44e949\">1.1. core 核心键位</a></li>\n<li><a href=\"#org7566de2\">1.2. buffer管理</a></li>\n<li><a href=\"#org6da97c2\">1.3. 在org大纲中移动 创建org大纲</a></li>\n<li><a href=\"#orgcd62c20\">1.4. style 样式</a>\n<ul>\n<li><a href=\"#orgf13ff98\">1.4.1. 各种格式</a></li>\n<li><a href=\"#orgdec8264\">1.4.2. ordered-list unordered-list description  各种列表（有序/无序/描述）</a></li>\n<li><a href=\"#orgcf79d1c\">1.4.3. checkbox 检查点</a></li>\n<li><a href=\"#org600f97f\">1.4.4. link 链接</a></li>\n<li><a href=\"#org96b580a\">1.4.5. 换行</a></li>\n</ul>\n</li>\n<li><a href=\"#org095b1fb\">1.5. codes 代码块和其他block</a>\n<ul>\n<li><a href=\"#orgfd6dd0f\">1.5.1. 普通代码块</a></li>\n</ul>\n</li>\n<li><a href=\"#orgac957b1\">1.6. table 表格</a>\n<ul>\n<li><a href=\"#org816a0e3\">1.6.1. 创建表格</a></li>\n<li><a href=\"#org92b3d0b\">1.6.2. 增加行列</a></li>\n<li><a href=\"#orgd96d6de\">1.6.3. 删除行列</a></li>\n<li><a href=\"#orge654cbc\">1.6.4. 移动行列</a></li>\n</ul>\n</li>\n<li><a href=\"#org28d2028\">1.7. calendar 日历</a>\n<ul>\n<li><a href=\"#org40cc6f0\">1.7.1. 进入日历</a></li>\n<li><a href=\"#org2a3d4f5\">1.7.2. 基本操作</a></li>\n<li><a href=\"#org92c4454\">1.7.3. 日记</a></li>\n</ul>\n</li>\n<li><a href=\"#orgbd7c803\">1.8. windows 窗口调整</a>\n<ul>\n<li><a href=\"#orgd99906b\">1.8.1. 新建窗口</a></li>\n<li><a href=\"#org0a8668e\">1.8.2. 移动窗口</a></li>\n<li><a href=\"#org0ceed61\">1.8.3. 调整窗口大小</a></li>\n<li><a href=\"#org44a1444\">1.8.4. 调整窗口位置</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"outline-container-org6a7ea47\" class=\"outline-2\">\n<h2 id=\"org6a7ea47\"><span class=\"section-number-2\">1</span> Emacs 笔记</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\n修订历史\n</p>\n<table border=\"2\" cellspacing=\"0\" cellpadding=\"6\" rules=\"groups\" frame=\"hsides\">\n\n\n<colgroup>\n<col  class=\"org-right\" />\n\n<col  class=\"org-left\" />\n</colgroup>\n<thead>\n<tr>\n<th scope=\"col\" class=\"org-right\">时间</th>\n<th scope=\"col\" class=\"org-left\">内容                               ;</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td class=\"org-right\">2019-07-15</td>\n<td class=\"org-left\">init，增加了一些基本样式和移动的说明</td>\n</tr>\n</tbody>\n<tbody>\n<tr>\n<td class=\"org-right\">2019-07-16</td>\n<td class=\"org-left\">增加了对日历使用说明</td>\n</tr>\n</tbody>\n</table>\n</div>\n\n\n<div id=\"outline-container-orga44e949\" class=\"outline-3\">\n<h3 id=\"orga44e949\"><span class=\"section-number-3\">1.1</span> core 核心键位</h3>\n<div class=\"outline-text-3\" id=\"text-1-1\">\n<ul class=\"org-ul\">\n<li><code>M-m</code> unlock the infinite power !!!</li>\n<li><code>C-x</code> some useful shortcuts !!!</li>\n<li><code>M-x</code> all functions and packages !!!</li>\n<li><code>M-x h d f</code> help to describe a function !!!</li>\n\n<li><code>C-f</code> 删除当前的命令（打错命令可以用这个来删除重新敲）</li>\n<li><code>C-c</code> org模式下面的prefix快捷键，可以查看常用的操作</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org7566de2\" class=\"outline-3\">\n<h3 id=\"org7566de2\"><span class=\"section-number-3\">1.2</span> buffer管理</h3>\n<div class=\"outline-text-3\" id=\"text-1-2\">\n<p>\n基本上有两种途径可以实现\n</p>\n</div>\n</div>\n\n<div id=\"outline-container-org6da97c2\" class=\"outline-3\">\n<h3 id=\"org6da97c2\"><span class=\"section-number-3\">1.3</span> 在org大纲中移动 创建org大纲</h3>\n<div class=\"outline-text-3\" id=\"text-1-3\">\n<ul class=\"org-ul\">\n<li><code>C-c C-n</code> 移动到下一个标题</li>\n<li><code>C-c C-p</code> 移动到上一个标题</li>\n\n<li><code>M-RET</code> 新建标题\n<code>注意</code> 如果是在： \n<b>之前</b> 那么会在之前新建\n<b>之中</b> 那么会切分成两半\n<b>之后</b> 那么会在之后新建</li>\n<li><code>C-RET</code> 在下面新建标题（跳过所有的子节点）</li>\n<li><code>M-up</code> 向上移动标题（同等级的移动）</li>\n<li><code>M-down</code> 向下移动标题（同等级的移动）</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orgcd62c20\" class=\"outline-3\">\n<h3 id=\"orgcd62c20\"><span class=\"section-number-3\">1.4</span> style 样式</h3>\n<div class=\"outline-text-3\" id=\"text-1-4\">\n</div>\n<div id=\"outline-container-orgf13ff98\" class=\"outline-4\">\n<h4 id=\"orgf13ff98\"><span class=\"section-number-4\">1.4.1</span> 各种格式</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-1\">\n<dl class=\"org-dl\">\n<dt>bold 粗体 </dt><dd><b>粗体</b></dd>\n<dt>Italy 斜体</dt><dd><i>斜体</i></dd>\n<dt>delete 删除线</dt><dd><del>delete</del></dd>\n<dt>underline 下划线</dt><dd><span class=\"underline\">下划线</span></dd>\n<dt>subscript 下标</dt><dd>H<sub>2</sub> O</dd>\n<dt>superscript 上标</dt><dd>E = mc<sup>2</sup></dd>\n<dt>monospace 等宽</dt><dd><code>git</code> 或者 <code>git</code> (btw, I love this color!!)</dd>\n</dl>\n</div>\n</div>\n\n<div id=\"outline-container-orgdec8264\" class=\"outline-4\">\n<h4 id=\"orgdec8264\"><span class=\"section-number-4\">1.4.2</span> ordered-list unordered-list description  各种列表（有序/无序/描述）</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-2\">\n<p>\n官网：<a href=\"https://orgmode.org/manual/Plain-lists.html\">https://orgmode.org/manual/Plain-lists.html</a>\n</p>\n<ol class=\"org-ol\">\n<li>有序列表\n直接标注 1. 或者 1) <code>注意</code> 要使用英文输入</li>\n<li>无序列表\n用 - + 或 *</li>\n<li>描述（类似于定义之类的）\n空格加上两冒号，例如：\nterm :: definition\n注意，如果此时是加载无序列表前面，还会自动加粗\n<ol class=\"org-ol\">\n<li>无序列表 :: definition</li>\n<li>无序列表 :: definition</li>\n<li>无序列表 :: definition</li>\n</ol></li>\n</ol>\n<p>\n<code>注意，所有层级关系都可以用以下快捷键</code>\n</p>\n<ul class=\"org-ul\">\n<li><code>M-RET</code> 来插入一个新行（可以自动增加序号）</li>\n\n<li><code>M-up</code> 向上移动标题（同等级的移动）</li>\n<li><code>M-down</code> 向下移动标题（同等级的移动）</li>\n\n<li><code>M-left</code> 不带子节点，让当前标示升级 <b>标题或者列表</b> 列表可以是无序列表，下同</li>\n<li><code>M-right</code> 不带子节点，让当前标示降级 <b>标题或者列表</b></li>\n<li><code>M-S-left</code>  带子节点，让当前标示升级 <b>标题或者列表</b></li>\n<li><code>M-S-right</code> 带子节点，让当前标示升级 <b>标题或者列表</b></li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orgcf79d1c\" class=\"outline-4\">\n<h4 id=\"orgcf79d1c\"><span class=\"section-number-4\">1.4.3</span> checkbox 检查点</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-3\">\n<ul class=\"org-ul\">\n<li><code>M-S-RET</code> 创建一个检查点（仅限于org模式）\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> 待办事项</li>\n</ul></li>\n<li><code>C-c C-c</code> 改变box的状态\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> 未完成</li>\n<li class=\"on\"><code>[X]</code> 已完成</li>\n</ul></li>\n<li><code>S-right</code> 用在标题上: 加上 TODO 或者 DONE 字样;\n用在列表上：改变列表样式（无序改为有序等）</li>\n<li><code>S-right</code> 同上</li>\n\n<li><code>[/]</code> 用来标记完成情况\n使用方法：先写成上面这样，然后创建检查点 <code>M-S-RET</code> ，然后用 <code>M-right</code> 或 <code>M-left</code>  缩进即可\n任务进度<code>[0/3]</code>\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n\n<li>[ ]<code>[0/2]</code>\n<ul class=\"org-ul\">\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n</ul></li>\n<li class=\"off\"><code>[&#xa0;]</code> </li>\n</ul></li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org600f97f\" class=\"outline-4\">\n<h4 id=\"org600f97f\"><span class=\"section-number-4\">1.4.4</span> link 链接</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-4\">\n<p>\n官网：<a href=\"https://orgmode.org/manual/Internal-links.html\">https://orgmode.org/manual/Internal-links.html</a>\n</p>\n\n\n<p>\n[[月亮宝石[英]威尔基·柯林斯.徐汝椿等译.上海译文出版社(1980).pdf][d]]\ncontrol x\ncontrol f\ncontrol b\n窗口调整\n全屏\n安装layers\n查看所有layers\noption m\noption x \n</p>\n</div>\n</div>\n\n<div id=\"outline-container-org96b580a\" class=\"outline-4\">\n<h4 id=\"org96b580a\"><span class=\"section-number-4\">1.4.5</span> 换行</h4>\n<div class=\"outline-text-4\" id=\"text-1-4-5\">\n<ul class=\"org-ul\">\n<li><code>M-m t l</code> 自动换行 toggle - truncate line</li>\n</ul>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-org095b1fb\" class=\"outline-3\">\n<h3 id=\"org095b1fb\"><span class=\"section-number-3\">1.5</span> codes 代码块和其他block</h3>\n<div class=\"outline-text-3\" id=\"text-1-5\">\n</div>\n<div id=\"outline-container-orgfd6dd0f\" class=\"outline-4\">\n<h4 id=\"orgfd6dd0f\"><span class=\"section-number-4\">1.5.1</span> 普通代码块</h4>\n<div class=\"outline-text-4\" id=\"text-1-5-1\">\n<p>\n例如c：\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-c\">int add(int a, int b){\n    return a + b;\n}\n</pre>\n</div>\n\n<p>\n例如java：\n</p>\n<div class=\"org-src-container\">\n<pre class=\"src src-java\">public static int add(int a, int b){\n    System.out.println()\n    return a + b;\n}\n</pre>\n</div>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-orgac957b1\" class=\"outline-3\">\n<h3 id=\"orgac957b1\"><span class=\"section-number-3\">1.6</span> table 表格</h3>\n<div class=\"outline-text-3\" id=\"text-1-6\">\n<p>\n<code>表格对中文支持很差，不建议在表格中使用中文</code>\n</p>\n</div>\n<div id=\"outline-container-org816a0e3\" class=\"outline-4\">\n<h4 id=\"org816a0e3\"><span class=\"section-number-4\">1.6.1</span> 创建表格</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-1\">\n<p>\norg模式下\n</p>\n<ul class=\"org-ul\">\n<li><code>| | |</code> 然后 <code>tab</code> ，可以新建对齐的列</li>\n</ul>\n<p>\n在第一步的基础上，可以用\n</p>\n<ul class=\"org-ul\">\n<li><code>|-</code> 然后 <code>tab</code> ，可以新建带横线的边框</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org92b3d0b\" class=\"outline-4\">\n<h4 id=\"org92b3d0b\"><span class=\"section-number-4\">1.6.2</span> 增加行列</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-2\">\n<ul class=\"org-ul\">\n<li><code>|-</code> 然后 <code>tab</code> 可以新建带横线的边框（新增一行）</li>\n<li><code>|</code> 然后 <code>tab</code> 可以新建一列</li>\n\n<li><code>M-S right</code> 新建一列</li>\n<li><code>M-S down</code> 新建一行</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orgd96d6de\" class=\"outline-4\">\n<h4 id=\"orgd96d6de\"><span class=\"section-number-4\">1.6.3</span> 删除行列</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-3\">\n<ul class=\"org-ul\">\n<li><code>M-S left</code> 删除一列</li>\n<li><code>M-S up</code> 删除一行</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-orge654cbc\" class=\"outline-4\">\n<h4 id=\"orge654cbc\"><span class=\"section-number-4\">1.6.4</span> 移动行列</h4>\n<div class=\"outline-text-4\" id=\"text-1-6-4\">\n<ul class=\"org-ul\">\n<li><code>M-left</code> 向左移动</li>\n<li><code>M-right</code> 向右移动</li>\n<li><code>M-up</code> 向上移动</li>\n<li><code>M-down</code> 向下移动</li>\n</ul>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-org28d2028\" class=\"outline-3\">\n<h3 id=\"org28d2028\"><span class=\"section-number-3\">1.7</span> calendar 日历</h3>\n<div class=\"outline-text-3\" id=\"text-1-7\">\n</div>\n<div id=\"outline-container-org40cc6f0\" class=\"outline-4\">\n<h4 id=\"org40cc6f0\"><span class=\"section-number-4\">1.7.1</span> 进入日历</h4>\n<div class=\"outline-text-4\" id=\"text-1-7-1\">\n<p>\n好多种方法可以打开日历\n</p>\n<ul class=\"org-ul\">\n<li><code>C-c &gt;</code> 直接进入</li>\n<li><code>M-x calendar</code> 搜索进入</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org2a3d4f5\" class=\"outline-4\">\n<h4 id=\"org2a3d4f5\"><span class=\"section-number-4\">1.7.2</span> 基本操作</h4>\n<div class=\"outline-text-4\" id=\"text-1-7-2\">\n<p>\n进入之后下面就有说明\n</p>\n<ul class=\"org-ul\">\n<li><code>?</code> 查看帮助手册</li>\n<li><code>.</code> 定位到当前日期</li>\n<li><code>o</code> 快速定位到其他日期</li>\n</ul>\n</div>\n</div>\n\n<div id=\"outline-container-org92c4454\" class=\"outline-4\">\n<h4 id=\"org92c4454\"><span class=\"section-number-4\">1.7.3</span> 日记</h4>\n<div class=\"outline-text-4\" id=\"text-1-7-3\">\n<p>\n<code>基本操作</code>\n</p>\n<ol class=\"org-ol\">\n<li>日记需要遵循一定的格式</li>\n<li>支持鼠标操作（右键日期）</li>\n</ol>\n\n<p>\n<code>查看操作</code>\n通过日历查看\n<code>M-x calendar</code> 进入日历\n</p>\n<ol class=\"org-ol\">\n<li><code>d</code> display 查看日记（不能编辑）</li>\n<li><code>s</code> 直接进入日记文件（可以编辑）</li>\n<li><code>m</code> mark所有有日记的日期</li>\n<li><code>u</code> unmark之前的标记</li>\n</ol>\n\n<p>\n直接查看diary\n</p>\n<ol class=\"org-ol\">\n<li><code>M-x diary</code> 直接查看diary</li>\n</ol>\n\n\n<p>\n<code>新建操作</code>\n</p>\n<ol class=\"org-ol\">\n<li><code>i d</code> 在选择的日期上添加一个日记入口（精确到日）</li>\n<li><code>i w</code> 在选择的星期上添加一个日记入口（精确到周）</li>\n<li><code>i m</code> 在选择的月份上添加一个日记入口（精确到月）</li>\n<li><code>i y</code> 在选择的年份上添加一个日记入口（精确到年）</li>\n<li><code>i u</code> 创建一个在指定日期之后的每年的纪念日（例如节日，生日等等）\n<code>注意是在指定日期之后</code></li>\n<li><code>i b</code> 创建一个指定范围内所有日期的日记入口（范围时间）</li>\n<li><code>i c</code> 创建循环的日记入口</li>\n</ol>\n\n<p>\n<code>消息通知</code>\n</p>\n<ol class=\"org-ol\">\n<li></li>\n\n<li></li>\n</ol>\n</div>\n</div>\n</div>\n\n<div id=\"outline-container-orgbd7c803\" class=\"outline-3\">\n<h3 id=\"orgbd7c803\"><span class=\"section-number-3\">1.8</span> windows 窗口调整</h3>\n<div class=\"outline-text-3\" id=\"text-1-8\">\n</div>\n<div id=\"outline-container-orgd99906b\" class=\"outline-4\">\n<h4 id=\"orgd99906b\"><span class=\"section-number-4\">1.8.1</span> 新建窗口</h4>\n</div>\n<div id=\"outline-container-org0a8668e\" class=\"outline-4\">\n<h4 id=\"org0a8668e\"><span class=\"section-number-4\">1.8.2</span> 移动窗口</h4>\n</div>\n<div id=\"outline-container-org0ceed61\" class=\"outline-4\">\n<h4 id=\"org0ceed61\"><span class=\"section-number-4\">1.8.3</span> 调整窗口大小</h4>\n</div>\n<div id=\"outline-container-org44a1444\" class=\"outline-4\">\n<h4 id=\"org44a1444\"><span class=\"section-number-4\">1.8.4</span> 调整窗口位置</h4>\n<div class=\"outline-text-4\" id=\"text-1-8-4\">\n<ul class=\"org-ul\">\n<li><code>M-x w .</code> 进入主控面板，可以做一切事情\n拥有对面板控制的最高权限\n包括调整窗口大小，位置，恢复，删除等</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div id=\"postamble\" class=\"status\">\n<p class=\"validation\"><a href=\"http://validator.w3.org/check?uri=referer\">Validate</a></p>\n</div>\n</body>\n</html>\n","tags":["Emacs","org-mode"],"categories":["Emacs"]},{"title":"建。。建站手册？🗝","url":"/2019/08/11/Hello-World/","content":"\n[TOC]\n\n# 修改历史\n\n| 时间      | 内容                       |\n| --------- | -------------------------- |\n| 2019-8-12 | 初稿                       |\n| 2019-8-29 | 完善图片显示和其他格式问题 |\n\n# 前言\n\n花了点时间捣鼓了个Hexo博客，顺便记录一下捣鼓过程，不想看过程的可以直接跳到[最后](#最后)\n\n**🕘 预计配置时间**： 3hours？Maybe fewer.\n\n**🖥 完成配之后将拥有：**\n\n1. 一个github仓库作为数据存储的静态博客\n\n2. 基本功能齐全，前端还算不错的个人博客，省得自己搭架子\n\n   ![blog](https://s2.ax1x.com/2019/08/29/mbAVyQ.png)\n\n3. 采用hexo博客框架，[Casper](https://github.com/xzhih/hexo-theme-casper)作为模板，自动渲染md，一键部署到github\n\n4. 模板自身支持发布文章，阅读文章，新建页面，分类，标签\n\n5. 自己添加了一些功能可以手动写md实现时间轴，增加了流量统计\n\n\n\n# 折腾过程实录\n\n**1. github page**\n\n​\t要部署到github的话，先搞一个github仓库，直接google一下[github page](https://www.google.com/search?q=github+page&oq=github+page&aqs=chrome..69i57j35i39j69i60l4.2108j0j4&sourceid=chrome&ie=UTF-8)咋整就行了，这一步注意仓库的名字有特殊的要求，不然后面会显示不出来东西。有手就行的东西就不展开了🙌\n\n**2. hexo**\n\n​\t同上，google一下[hexo](https://hexo.io/zh-cn/docs/)的安装过程，同有手就行🤞\n\n​\t这里可以稍微熟悉一下几个命令\n\n```shell\nhexo new post helloworld\nhexo clean  # 清空一下之前生成的文件，如果修改不生效可以试试这个命令，先清空一下\nhexo g      # generate，编译渲染\nhexo d      # deploy，自动部署\n```\n\n\n\n**3. hexo部署到github page上**\n\n​\tgoogle之[hexo整合github](https://hexo.io/zh-cn/docs/deployment)。。有手就行👀。。。\n\n​\t这里可以稍微注意一下，部署的分支和资源存储的分支是分开的，部署的分支github貌似要求是master，资源可以新建一个分支\n\n**4. pick一个主题**\n\n​\t这里我选了[Casper](https://github.com/xzhih/hexo-theme-casper)作为模板，另外有一个模板看起来也不错👉[icarus](https://blog.zhangruipeng.me/hexo-theme-icarus/about/)。下面的内容都是根据我选择的Casper展开。\n\n​\t更换主题就是直接把Casper的github repo（具体地址在上面链接👆）clone到**themes**文件夹下。\n\n​\t稍微解释一下这些个文件夹都是干啥的，之后有用。\n\n```\n├── README.md\n├── _config.yml          # 配置文件，可以配置很多东西，之后会介绍\n├── languages            # 语言包，直接在配置文件里面设置zh-CN就是中文了\n│   ├── default.yml\n│   ├── fr.yml\n│   ├── nl.yml\n│   ├── no.yml\n│   ├── ru.yml\n│   ├── zh-CN.yml\n│   └── zh-TW.yml\n├── layout               # 布局文件，自定义一些布局基本都在这里修改\n│   ├── _layout.swig\n│   ├── _partials\n│   ├── archive.swig\n│   ├── category.swig\n│   ├── index.swig\n│   ├── page.swig\n│   ├── post.swig\n│   └── tag.swig\n├── scripts\n│   └── index.js\n└── source               # 源文件，配合布局一起修改\n    ├── css\n    ├── fonts\n    ├── img\n    └── js\n```\n\n**5. 配置主题**\n\n​\t这一步主要是修改**_config**这个文件，这里有俩config，一个是博客根目录的config，一个是**themes/hexo-casper**里的config，都可以配置，重点说一下主题里面的那个config\n\n![_config](https://s2.ax1x.com/2019/08/29/mbAtm9.png)\n\n参考我这个稍微配置一下就行了，另外[Casper](https://github.com/xzhih/hexo-theme-casper)里面写的很清楚了，照着改改就差不多了\n\n\n\n**6. 增加流量统计**\n\n​\t提了issue问怎么统计流量，回答说有个评论系统自带了流量统计功能，但是注册过程比较麻烦，就放弃了。这里采用[不蒜子](http://ibruce.info/2015/04/04/busuanzi/)，很是方便，而且速度很快，只要简单配置一下就可以了。\n\n配置之前先详细解释一下layout的结构：\n\n```shell\n├── _layout.swig            # 页面总体布局（修改基本没用到它）\n├── _partials               # 小组件，方便复用\n│   ├── about.swig            # 这个就是ABOUT界面上面的那些小东西，见下面图例\n│   ├── footer.swig           # 注脚，见下面图例\n│   ├── head.swig\n│   ├── header.swig\n│   ├── index.swig\n│   ├── javascript.swig\n│   ├── page.swig\n│   ├── post.swig\n│   ├── public\n│   │   ├── fload-header.swig\n│   │   ├── icons\n│   │   ├── json-ld.swig\n│   │   ├── nav.swig\n│   │   ├── social.swig\n│   │   └── toc.swig\n│   ├── search.swig\n│   ├── widget                # 这三个就是分类、tag和recent\n│   │   ├── category.swig\n│   │   ├── recent_posts.swig\n│   │   └── tagcloud.swig\n│   └── widget.swig\n├── archive.swig              # archive页面的布局\n├── category.swig\n├── index.swig\n├── page.swig\n├── post.swig\n└── tag.swig\n```\n\n_partials/about.swig:\n\n![about](https://s2.ax1x.com/2019/08/29/mbAUT1.png)\n\n_partials/foot.swig:\n\n![foot](https://s2.ax1x.com/2019/08/29/mbAdFx.png)\n\n**7. 将分类写到导航栏上面**\n\n```\nhexo new page xxx\n```\n\n这个命令可以新建一个导航页面，但是只是单独的一页文章。如果要把categories的每个分类放到导航栏上面，可以稍作修改。\n\n方法一：\n\n在**config**里面修改：\n\n```\nmenu:\n  ABOUT: /about\n  ARCHIVES: /archives\n  TEST: /categories/test/\n```\n\n这样手动可以把某个分类添加到导航栏上面。\n\n方法二：\n\n观察**layout/_partails/widget/categories**中的写法，发现只要添加一行代码就可以添加link到指定分类的链接。故只要在**layout/_partails/public/nav.swig**中修改如下：（绿色的注释）\n\n![nav](https://s2.ax1x.com/2019/08/29/mbVkrQ.png)\n\n**8. 给页面加上阴影**\n\n因为项目中将css全部整合到**allinonecss.min.css**中，因此要直接修改这个css文件，修改其他的css文件不生效！！！\n\n全局搜索\n\n```\n.post-full-content\n```\n\n添加css\n\n```\nbox-shadow:0px 16px 16px #E0E0E0;\nborder-radius: 8px;\n```\n\n即可添加shadow和圆角\n\n**8. 添加时间线**\n\n这个可以通过手写markdown来手动实现时间线\n\n首先在**scripts/index.js**最后添加如下代码：（来自<http://channingsun.bid/2016/05/10/20160510_%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0Timeline/>）\n\n```js\n//timeline\nhexo.extend.tag.register('timeline', function(args, content){\n\tdate = args[0]\n\ttime = args[1]\n\tlogo = args[2]\n\tvar result = '';\n\tresult += '<blockquote>';\n\tlogo = '<span class=\"fa-stack fa-lg\"><i class=\"fa ' + logo + ' fa-stack-1x\"></i></span>';\n\tresult += hexo.render.renderSync({text: logo + content, engine: 'markdown'});\n\tfooter = '<span>' + date + ' ' + time + '</span>'\n\tresult += '<footer>' + footer + '</footer>';\n\tresult += '</blockquote>';\n\treturn result;\n}, {ends: true});\n```\n\n然后只要写\n\n```\n{% timeline 2015-01-23 18:38:26 fa-lg %} 第一篇博客 {% post_link hello-world hello-world %} {% endtimeline %}\n```\n\n即可跳转到对应的博客\n\n也可以适当调整一下js里面的内容，比如表情和time可以删掉\n\n# 最后\n\n最后就配置好了，嗯。想看配置过程的可以看[折腾过程实录](#%E6%8A%98%E8%85%BE%E8%BF%87%E7%A8%8B%E5%AE%9E%E5%BD%95)\n\n\n\n\n\n\n\n","tags":["Hello World"]},{"title":"hello-world","url":"/2019/08/10/hello-world/","content":"\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n```bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n```bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n```bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n```bash\n$ hexo deploy\n```\n\nMore info: [Deployment]("}]