<!DOCTYPE html>
<html lang="zh-cn">







<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="preconnect" href="//www.googletagmanager.com">
	<link rel="preconnect" href="//zz.bdstatic.com">
	<link rel="preconnect" href="//sp0.baidu.com">
	<link rel="preconnect" href="//www.google-analytics.com">
	<link rel="preconnect" href="//cdn1.lncld.net">
	<link rel="preconnect" href="//unpkg.com">
	<link rel="preconnect" href="//app-router.leancloud.cn">
	<link rel="preconnect" href="//9qpuwspm.api.lncld.net">
	<link rel="preconnect" href="//gravatar.loli.net">

	<title>C++学习笔记（五） | 羊男</title>

	<meta name="HandheldFriendly" content="True">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
	<meta name="generator" content="hexo">
	<meta name="author" content="CaesarRoot">
	<meta name="description" content>

	
	<meta name="keywords" content>
	

	
	<link rel="shortcut icon" href="https://avatars0.githubusercontent.com/u/35787647?s=400&u=84a9297891a0fe94cdd18ce2f80d2c3d825c15fb&v=4">
	<link rel="apple-touch-icon" href="https://avatars0.githubusercontent.com/u/35787647?s=400&u=84a9297891a0fe94cdd18ce2f80d2c3d825c15fb&v=4">
	

	
	<meta name="theme-color" content="#3c484e">
	<meta name="msapplication-TileColor" content="#3c484e">
	

	

	

	<meta property="og:site_name" content="羊男">
	<meta property="og:type" content="article">
	<meta property="og:title" content="C++学习笔记（五） | 羊男">
	<meta property="og:description" content>
	<meta property="og:url" content="https://caesarroot.github.io/2019/12/30/C-学习笔记（五）/">

	
	<meta property="article:published_time" content="2019-12-30T17:12:00+08:00"> 
	<meta property="article:author" content="CaesarRoot">
	<meta property="article:published_first" content="羊男, /2019/12/30/C-学习笔记（五）/">
	

	
	
	<link rel="stylesheet" href="/css/allinonecss.min.css">

	
	
	
</head>

<body class="post-template">
	<div class="site-wrapper">
		




<header class="site-header post-site-header outer">
    <div class="inner">
        
<nav class="site-nav"> 
    <div class="site-nav-left">
        <ul class="nav">
            <li>
                
                <a href="/" title="Home">HOME</a>
                
            </li>
            
            
            <li>
                <a href="/about" title="ABOUT">ABOUT</a>
            </li>
            
            <li>
                <a href="/archives" title="ARCHIVES">ARCHIVES</a>
            </li>
            
            
        </ul> 
    </div>
    
    <div class="search-button-area">
        <a href="#search" class="search-button">Search ...</a>
    </div>
     
    <div class="site-nav-right">
        
        <a href="#search" class="search-button">Search ...</a>
         
        
<div class="social-links">
    
    
    <a class="social-link" title="github" href="https://github.com/CaesarRoot" target="_blank" rel="noopener">
        <svg viewbox="0 0 1049 1024" xmlns="http://www.w3.org/2000/svg"><path d="M524.979332 0C234.676191 0 0 234.676191 0 524.979332c0 232.068678 150.366597 428.501342 358.967656 498.035028 26.075132 5.215026 35.636014-11.299224 35.636014-25.205961 0-12.168395-0.869171-53.888607-0.869171-97.347161-146.020741 31.290159-176.441729-62.580318-176.441729-62.580318-23.467619-60.841976-58.234462-76.487055-58.234463-76.487055-47.804409-32.15933 3.476684-32.15933 3.476685-32.15933 53.019436 3.476684 80.83291 53.888607 80.83291 53.888607 46.935238 79.963739 122.553122 57.365291 152.97411 43.458554 4.345855-33.897672 18.252593-57.365291 33.028501-70.402857-116.468925-12.168395-239.022047-57.365291-239.022047-259.012982 0-57.365291 20.860106-104.300529 53.888607-140.805715-5.215026-13.037566-23.467619-66.926173 5.215027-139.067372 0 0 44.327725-13.906737 144.282399 53.888607 41.720212-11.299224 86.917108-17.383422 131.244833-17.383422s89.524621 6.084198 131.244833 17.383422C756.178839 203.386032 800.506564 217.29277 800.506564 217.29277c28.682646 72.1412 10.430053 126.029806 5.215026 139.067372 33.897672 36.505185 53.888607 83.440424 53.888607 140.805715 0 201.64769-122.553122 245.975415-239.891218 259.012982 19.121764 16.514251 35.636014 47.804409 35.636015 97.347161 0 70.402857-0.869171 126.898978-0.869172 144.282399 0 13.906737 9.560882 30.420988 35.636015 25.205961 208.601059-69.533686 358.967656-265.96635 358.967655-498.035028C1049.958663 234.676191 814.413301 0 524.979332 0z"/></svg>
    </a>
    
    
    
    
    
    
</div>
    </div>
</nav>
    </div>
</header>


<div id="site-main" class="site-main outer" role="main">
    <div class="inner">
        <header class="post-full-header">
            <div class="post-full-meta">
                <time class="post-full-meta-date" datetime="2019-12-30T09:34:26.000Z">
                    2019-12-30
                </time>
                
                <span class="date-divider">/</span>
                
                <a href="/categories/c/">c++</a>&nbsp;&nbsp;
                
                
            </div>
            <h1 class="post-full-title">C++学习笔记（五）</h1>
            
        </header>
        <div class="post-full no-image">
            
            <div class="post-full-content">
                <article id="photoswipe" class="markdown-body">
                    <h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="为什么要有OO"><a href="#为什么要有OO" class="headerlink" title="为什么要有OO"></a>为什么要有OO</h2><p>解决名空间冲突问题</p>
<p>消除安全隐患（对成员的直接赋值和修改）</p>
<p>封装和信息隐藏</p>
<p>封装内部结构，提供统一接口，更多的类型检查</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="重载构造函数"><a href="#重载构造函数" class="headerlink" title="重载构造函数"></a>重载构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Default"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">int</span> i) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"int i"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">char</span> *p) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"char *p"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a1 = A(<span class="number">1</span>); <span class="comment">// 等价于A a1(1); A a1 = 1;</span></span><br><span class="line">    A a2 = A(); <span class="comment">// 等价于 A a2;</span></span><br><span class="line">    A a3 = A(<span class="string">"abcd"</span>); <span class="comment">// 调用A(char *p)</span></span><br><span class="line">    A a[<span class="number">4</span>]; <span class="comment">// 调用a[0]、a[1]、a[2]、a[3]的A()</span></span><br><span class="line">    A b[<span class="number">5</span>] = &#123; A(), A(<span class="number">1</span>), A(<span class="string">"abcd"</span>), <span class="number">2</span>, <span class="string">"xyz"</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员初始化表"><a href="#成员初始化表" class="headerlink" title="成员初始化表"></a>成员初始化表</h3><p>初始化表先于构造函数，因此const和引用要用初始化表初始化</p>
<p>初始化表式按照对象的声明次序初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">引用和常量必须在初始化列表中初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">int</span> &amp;w;</span><br><span class="line">    A():w(x),y(<span class="number">1</span>),z(x),x(<span class="number">0</span>)&#123; x = <span class="number">100</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CString</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 按声明顺序执行初始化表</span></span><br><span class="line">    <span class="comment">// 且初始化表是最先执行的</span></span><br><span class="line">    <span class="comment">// 而此时size还未初始化</span></span><br><span class="line">    CString(<span class="keyword">int</span> x):size(x),p(<span class="keyword">new</span> <span class="keyword">char</span>[size])&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.w &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 100，w设置成为了x的引用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.x &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 100</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.y &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.z &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0，初始化表先执行，且按照声明顺序，因此x先被赋值成0，然后z赋值成x</span></span><br><span class="line"></span><br><span class="line">    <span class="function">CString <span class="title">s</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要调用某个成员函数的非默认构造函数，也要在成员初始化表里面显式写出</p>
<p>要调用父类的特定构造函数，也要在成员初始化表里面显式写出</p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>RAII</p>
<p>resoure acquisition is initialization</p>
<p>对象获得即初始化</p>
<p>核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源</p>
<p>强制在堆上分配空间：将析构函数设为private</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// A a; // 将会报错，因为析构函数是私有的，因此不能在栈上创建</span></span><br><span class="line">    A* a = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="comment">// delete a; // 将会报错，因为delete默认调用析构函数</span></span><br><span class="line">    a -&gt; destroy();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了destroy，还可以写成一个静态方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(A* p)</span></span>&#123; <span class="keyword">delete</span> p; &#125;</span><br><span class="line">A::<span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>

<p>强制在栈上分配空间：将new操作符设为private</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;     <span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125; <span class="comment">// 重载了new就需要重载delete</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将new操作符访问级别设为private可以强制只能在栈上分配对象空间</span></span><br><span class="line">    <span class="comment">// A a = new A;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>调用时机：</p>
<ol>
<li>初始化的时候 A b = a;</li>
<li>函数参数传递</li>
<li>函数返回值</li>
</ol>
<p>默认的拷贝构造函数是浅拷贝，指针指向同一块内存区域，这样当一个对象析构的时候，指向同一块内存区域的指针就会变成悬挂指针（野指针）</p>
<p>如果定义了自己的拷贝构造函数，那么就覆盖掉了默认生成的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    A()&#123; x = y = <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123; x++; y++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    A a;</span><br><span class="line">    B()&#123; z = <span class="number">0</span>; &#125;</span><br><span class="line">    B(<span class="keyword">const</span> B&amp; b):a(b.a)&#123; z = b.z; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span></span>&#123; z++; a.inc(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b1;  <span class="comment">// b1.z = b1.a.x = b1.a.y = 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b1.z &lt;&lt; <span class="string">" "</span> &lt;&lt; b1.a.x &lt;&lt; <span class="string">" "</span> &lt;&lt; b1.a.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    b1.inc();  <span class="comment">// b1.z = b1.a.x = b1.a.y = 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b1.z &lt;&lt; <span class="string">" "</span> &lt;&lt; b1.a.x &lt;&lt; <span class="string">" "</span> &lt;&lt; b1.a.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(b1)</span></span>;  </span><br><span class="line">    <span class="comment">// 如果是默认的拷贝构造函数，那么 b2.z = b2.a.x = b2.a.y = 1</span></span><br><span class="line">    <span class="comment">// 如果是自己的拷贝构造函数但是没有初始化列表，那么 b2.z = 1 b2.a.x = b2.a.y = 0</span></span><br><span class="line">    <span class="comment">// 如果是自己的拷贝构造函数且有初始化列表，那么 b2.z = b2.a.x = b2.a.y = 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b2.z &lt;&lt; <span class="string">" "</span> &lt;&lt; b2.a.x &lt;&lt; <span class="string">" "</span> &lt;&lt; b2.a.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new-和-delete"><a href="#new-和-delete" class="headerlink" title="new 和 delete"></a>new 和 delete</h2><h3 id="为什么要有new和delete？"><a href="#为什么要有new和delete？" class="headerlink" title="为什么要有new和delete？"></a>为什么要有new和delete？</h3><p>会调用构造函数和析构函数</p>
<h3 id="new-vs-malloc"><a href="#new-vs-malloc" class="headerlink" title="new vs malloc"></a>new vs malloc</h3><p>和malloc不同的是，new返回的是有类型的指针，不用再强制类型转化；而malloc只返回void*</p>
<p>而且new可以重载，用于更加精细化内存管理，例如内存池模式</p>
<h3 id="调用重载构造函数"><a href="#调用重载构造函数" class="headerlink" title="调用重载构造函数"></a>调用重载构造函数</h3><p>new默认调用默认构造函数，如果要调用其他构造函数，要写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A p = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>new也可以用于内置基本类型</p>
<p>###动态数组</p>
<p>如果new申请的是一个数组，直接调用delete p而不是delete p[]，那么只会释放掉第一个对象的空间</p>
<p>delete void*会释放空间，因为分配的空间是和指针存放在一起的，但是不会调用析构函数</p>
<p>delete之后最好赋值成nullptr，可以防止二次delete（啥都不做）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A's default constructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">int</span> i)&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A's int"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A's de-constructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *p = <span class="keyword">new</span> A[<span class="number">10</span>]&#123;<span class="number">1</span>&#125;;  <span class="comment">// 调用1次带有参数的构造函数和9次默认的构造函数，且只能调用默认构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;p[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// delete p;  // 只调用一个析构函数，然后再调用delete []p会报错</span></span><br><span class="line">    <span class="keyword">delete</span> []p;  <span class="comment">// 调用10个析构函数，且是逆序delete的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* vp = <span class="keyword">new</span> A;</span><br><span class="line">    <span class="keyword">delete</span> vp;  <span class="comment">// 会有编译警告，且不会调用析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><p>实际上是this参数变为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(cosnt A* <span class="keyword">const</span> <span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>mutable关键字强调是可变的，因此可以在const成员函数里面修改mutable标记的变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">本质上是函数的参数变为了 const A* const this</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意const重载的时候</span></span><br><span class="line"><span class="comment">自身是否是const不会重载</span></span><br><span class="line"><span class="comment">只有指向的是const还是非const才会构成重载</span></span><br><span class="line"><span class="comment">类的const成员函数就会构成这样的重载</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> &amp;indirect_int;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> m;</span><br><span class="line">    A(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1):indirect_int(*<span class="keyword">new</span> <span class="keyword">int</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 非const和const形成了重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> A::f()&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定要写明到底有没有const</span></span><br><span class="line"><span class="keyword">void</span> A::show()&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not const"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定要写明到底有没有const</span></span><br><span class="line"><span class="keyword">void</span> A::show() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// 注意不能修改变量的值</span></span><br><span class="line">    <span class="comment">// x = 1;</span></span><br><span class="line">    <span class="comment">// 引用特殊，实际上引用就是const，修改的是引用指向的值</span></span><br><span class="line">    <span class="comment">// 事实上不存在const &amp;，没有意义</span></span><br><span class="line">    indirect_int = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 标记为mutable的变量永远可修改</span></span><br><span class="line">    m = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Const"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 调用的是非const的方法</span></span><br><span class="line">    a.show();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> A <span class="title">ca</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const对象不能调用非const的方法</span></span><br><span class="line">    <span class="comment">// ca.f();</span></span><br><span class="line">    ca.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>同一个类的不同对象如何共享变量？</p>
<ul>
<li><p>如果把这些共享变量定义为全局变量，则缺乏数据保护</p>
</li>
<li><p>名污染</p>
</li>
</ul>
<p>使用static成员可以解决这个问题</p>
<p>头文件中只是声明静态成员变量，因此不会调用静态成员变量的构造函数</p>
<p>static变量初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">引用、常量、静态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">引用和常量必须在初始化列表中初始化</span></span><br><span class="line"><span class="comment">静态成员变量在类外初始化且不能再带有static关键字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态成员不能在类内部初始化</span></span><br><span class="line">    <span class="comment">// static int a = 0;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是静态的常量可以在类内初始化</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A::b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::o = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="comment">// const static 如果直接在类内给出值，那么用到的时候是作为常量直接替换，不会分配存储空间</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &amp;a.a &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// 只有在类外定义才会有存储空间</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;a.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><h3 id="为什么要有友元？"><a href="#为什么要有友元？" class="headerlink" title="为什么要有友元？"></a>为什么要有友元？</h3><p>相对于c引入了访问权限，不能访问private成员，只能通过public方法，但是这会降低效率。既要有访问控制，又要有访问效率，因此就引入了友元，使得声明成友元的类或者方法可以直接使用该类的private成员</p>
<p>友元可以访问私有成员和私有方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> B::g()&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="comment">// 友元类的成员函数可以调用私有方法</span></span><br><span class="line">    a.f();</span><br><span class="line">    <span class="comment">// 友元类的成员函数可以调用私有成员</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.g();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不完全声明"><a href="#不完全声明" class="headerlink" title="不完全声明"></a>不完全声明</h3><p>下面这个例子不能通过编译，因为看不到Vector的声明</p>
<p>编译器要提前计算每个数据的大小，由于引用或者指针都是一样大的，因此编译器只要知道类型的确存在就行了，所以只要写 class Vector; 就可以通过编译</p>
<p>注意这里是因为是引用或者指针才能用不完全声明来解决，如果要用到具体类型的成员方法或者成员变量，还是要看到具体的完全声明。因此如果是两个友元类的方法互相声明，那将无法解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">		&#123;</span>    ......</span><br><span class="line"> 		     <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">(Matrix &amp;m, Vector &amp;v, Vector &amp;r)</span></span>;</span><br><span class="line">		&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span></span></span><br><span class="line"><span class="class">&#123;</span>    ......</span><br><span class="line">  	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">(Matrix &amp;m, Vector &amp;v, Vector &amp;r)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>友元不具有传递性，也和继承体系无关</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>protected：外部访问不到，子类能访问；子类的友元也访问不到，只能通过子类来访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A's func1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// 子类中可以直接通过A来调用protected</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A::func1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能通过A类型的对象来调用protected</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fg</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        <span class="comment">// a.func1();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在B类中可以使用B对象的protected</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(B b)</span></span>&#123;</span><br><span class="line">        b.func1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">gg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在友元中可以通过子类来使用protected</span></span><br><span class="line">    B b;</span><br><span class="line">    b.func1();</span><br><span class="line">    <span class="comment">// 友元中不能直接通过A来调用protected</span></span><br><span class="line">    <span class="comment">// A::func1();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="comment">// 在B类的外部无法使用protected</span></span><br><span class="line">    <span class="comment">// b.func1();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承权限"><a href="#继承权限" class="headerlink" title="继承权限"></a>继承权限</h3><p>不管是哪一种权限，对自己的类没有影响</p>
<p>如果写成private，那么相当于把父类的public和protected改成自己的private</p>
<p>因此如果是private，那么它的子类啥都使用不了</p>
<p>如果是pretocted，就是把父类中的public变成自己的protected</p>
<p>默认是private，一般情况下没有意义</p>
<p>私有继承目的是复用基类的数据和方法，类似于组合，但是可以重载virtual function，更加灵活一点</p>
<p>私有继承而且还可以节省派生对象的大小，如果私有继承的子类没有成员函数，那么大小是0，组合的话还有一个组合对象的指针</p>
<p>注意私有继承在设计上没有意义，只是实现上复用方法以及节省空间</p>
<p>在设计上没有意义是因为私有继承和protected继承不能转化成基类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A's func1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B's func1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 有两点需要注意</span></span><br><span class="line">    <span class="comment">// 1. 如果在某个时刻，通过B的对象不能访问A的公有方法，那么此时B不能转化成A，指针和引用也不行</span></span><br><span class="line">    <span class="comment">// 2. 一旦B的某个形式可以转化成A，那么即使在B中为private，只要它是虚函数，通过A都可以访问到这个函数（编译器期间确定访问权限）</span></span><br><span class="line">    A* a = <span class="keyword">new</span> B;</span><br><span class="line">    a -&gt; func1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不完全声明-1"><a href="#不完全声明-1" class="headerlink" title="不完全声明"></a>不完全声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误声明</span></span><br><span class="line">Class Undergraduated_Student:<span class="keyword">public</span> Student;</span><br><span class="line"><span class="comment">//正确声明</span></span><br><span class="line">Class Undergraduated_Student;</span><br><span class="line"><span class="comment">// 不完全声明不需要指出继承关系</span></span><br></pre></td></tr></table></figure>

<h3 id="继承成员"><a href="#继承成员" class="headerlink" title="继承成员"></a>继承成员</h3><p>如果子类中有同名的变量或者方法，会直接覆盖掉父类的</p>
<p>如果要保留父类的，那么要写明 A::f 或者 using A::f</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Father f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Father f(int)"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Father::f;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Son f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    s.f();</span><br><span class="line">    <span class="comment">// 使用了using就可以继承父类的所有同名方法了</span></span><br><span class="line">    <span class="comment">// 只会覆盖掉其中子类自定义的版本</span></span><br><span class="line">    s.f(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>using可以改变默认的访问权限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's f(int)"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">private</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// using 可以让private继承而来的函数变成public</span></span><br><span class="line">    <span class="keyword">using</span> A::f;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's f()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.f(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对构造函数的处理特殊，见下</p>
<h3 id="构造函数调用顺序"><a href="#构造函数调用顺序" class="headerlink" title="构造函数调用顺序"></a>构造函数调用顺序</h3><p>单继承：</p>
<p>从上往下调用构造函数</p>
<p>从下往上调用析构函数</p>
<h3 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h3><p>类不能继承默认、拷贝和移动构造函数，因为编译器会为派生类合成默认的</p>
<p>和”继承”别的函数一样，使用using即可，不过using完了之后，其他函数是直接照搬过来，但是对于构造函数，编译器会稍作修改</p>
<p><img alt="image" class="post-img b-lazy" data-img="https://s2.ax1x.com/2019/12/18/QTqAUJ.png" data-index="0" data-src="https://s2.ax1x.com/2019/12/18/QTqAUJ.png"></p>
<p>还有一个区别就是，普通函数的using可以改变访问级别，例如我在private里面using，那么”继承”下来的函数就会是private的，但不是构造函数不一样，基类的私有构造函数在派生类中还是一个私有构造函数，而不管using出现在哪</p>
<p><img alt="image" class="post-img b-lazy" data-img="https://s2.ax1x.com/2019/12/18/QTqBVg.png" data-index="1" data-src="https://s2.ax1x.com/2019/12/18/QTqBVg.png"></p>
<p><img alt="image" class="post-img b-lazy" data-img="https://s2.ax1x.com/2019/12/18/QTqIIJ.png" data-index="2" data-src="https://s2.ax1x.com/2019/12/18/QTqIIJ.png"></p>
<p>事实上，如果有private版本的重载函数（非构造函数），那么不能使用using</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A(<span class="keyword">int</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's f(int)"</span>&lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 如果有重载的版本为private的，那么不能继承，编译报错</span></span><br><span class="line">    <span class="comment">// 构造函数例外，编译不会报错，只是不会改变访问权限，仍然是private</span></span><br><span class="line">    <span class="comment">// using A::f;</span></span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's f()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="赋值相容，类型相容"><a href="#赋值相容，类型相容" class="headerlink" title="赋值相容，类型相容"></a>赋值相容，类型相容</h3><p>可以通过=赋值的就是赋值相容的，例如可以把子类对象赋值给父类，对象切片，对象的身份发生了变化</p>
<p>类型相容是指保留了派生类的类型，例如通过指针或者引用来将派生类赋值给基类</p>
<h3 id="前期绑定vs后期绑定"><a href="#前期绑定vs后期绑定" class="headerlink" title="前期绑定vs后期绑定"></a>前期绑定vs后期绑定</h3><p>前期绑定</p>
<ul>
<li>编译时刻</li>
<li>依据对象的静态类型</li>
<li>效率高、灵活性差</li>
</ul>
<p>动态绑定：</p>
<ul>
<li>运行时刻</li>
<li>依据对象的实际类型（动态）</li>
<li>灵活性高、效率低</li>
</ul>
<p>c++注重效率，因此默认前期绑定，后期绑定需要显式指出(virtual)</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li>累的成员函数才可以是虚函数</li>
<li>静态成员函数不能是虚函数</li>
<li>内联成员函数不能是虚函数</li>
<li>构造函数不能是虚函数</li>
<li>析构函数可以（往往）是虚函数</li>
</ul>
<p><strong>虚函数一定要有实现！！！纯虚函数例外</strong></p>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>如果析构函数不是虚函数，那么派生对象得到的资源可能不会被释放<br>所以析构函数应该定义成虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    ~A()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A's de-constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A's copy function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~B()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B's de-constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    B()&#123;&#125;</span><br><span class="line">    B(<span class="keyword">const</span> B&amp; b)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B's copy function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数也会层层调用</span></span><br><span class="line"><span class="comment">// 调用如下函数，函数退出的时候</span></span><br><span class="line"><span class="comment">// 会依次调用B的析构函数和A的析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> B;</span><br><span class="line">    <span class="comment">// 如果析构函数非虚，那么只会调用A的析构函数</span></span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>维护一张虚函数表</p>
<p>因此对对象做sizeof，除了成员变量的大小之外，还有虚函数表的指针大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>A&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="comment">// 大小比没有虚函数的大</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="到底调用哪个版本"><a href="#到底调用哪个版本" class="headerlink" title="到底调用哪个版本"></a>到底调用哪个版本</h3><p><strong>根据静态类型看能否调用；如果是virtual，且是通过指针和引用调用，根据动态类型找到调用哪个版本</strong></p>
<p>非虚调虚，行为变化（非虚接口）</p>
<p>虚调非虚，行为不变</p>
<p>注意如果是非指针的对象调用非虚函数，里面又调用了虚函数，仍然可以动态绑定。因为方法默认第一参数为*this是一个指针（非虚接口）</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"father's f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"father's f(int)"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"father's g()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"son's f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"son's g()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用非虚函数，调用的都是父类的</span></span><br><span class="line">    <span class="comment">// 只有虚函数会动态调用到子类的</span></span><br><span class="line">    Father *f = <span class="keyword">new</span> Son;</span><br><span class="line">    f-&gt;f(<span class="number">1</span>);</span><br><span class="line">    f-&gt;f();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是指针，那么即使是虚函数也不会动态调用</span></span><br><span class="line">    Father ff = Son();</span><br><span class="line">    ff.g();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father: f()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        g();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Father: f2(int a)"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Father: g()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nvf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Father: nvf()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        g();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// using Father::f;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son: f()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        g();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Son: g()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 虚函数调用非虚函数和虚函数的行为都是一致的</span></span><br><span class="line">    <span class="comment">// 前提是子类没有同名的非虚函数</span></span><br><span class="line">    Father *f = <span class="keyword">new</span> Son;</span><br><span class="line">    <span class="comment">// 会调用子类的g()</span></span><br><span class="line">    <span class="comment">// 无论此时g是否是virtual</span></span><br><span class="line">    f-&gt;f();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Father *ff = <span class="keyword">new</span> Father;</span><br><span class="line">    ff-&gt;f();</span><br><span class="line">    <span class="comment">// 会调用父类的g()</span></span><br><span class="line">    <span class="comment">// 无论此时g是否是virtual</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非虚函数调用虚函数和非虚函数是有区别的</span></span><br><span class="line">    <span class="comment">// 这也是模版方法的实现基础</span></span><br><span class="line">    <span class="comment">// 这时候如果g是virtual，那么可以调用到子类的g()</span></span><br><span class="line">    <span class="comment">// 否则调用的是父类的g</span></span><br><span class="line">    f-&gt;nvf();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是指针，那么只能调用父类的方法，与virtual无关</span></span><br><span class="line">    Father f2 = Son();</span><br><span class="line">    f2.f();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    Son s;</span><br><span class="line">    <span class="comment">// virtual与redefined无关</span></span><br><span class="line">    <span class="comment">// 如果有同名方法仍旧会被覆盖</span></span><br><span class="line">    <span class="comment">// 需要使用using</span></span><br><span class="line">    <span class="comment">// s.f(2);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别注意下面这个例子，权限检查是静态时完成的，一旦静态类型检查通过，运行时就会动态调用：</p>
<p><a href="https://www.zhihu.com/question/22526510" target="_blank" rel="noopener">https://www.zhihu.com/question/22526510</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> B;</span><br><span class="line">    <span class="comment">// 仍然可以调用B的私有方法</span></span><br><span class="line">    <span class="comment">// 权限检查是静态编译过程中就确定了的</span></span><br><span class="line">    a -&gt; f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数和析构函数中调用虚函数"><a href="#构造函数和析构函数中调用虚函数" class="headerlink" title="构造函数和析构函数中调用虚函数"></a>构造函数和析构函数中调用虚函数</h3><p>不会有虚函数的特性，构造和析构到哪一步，调用那一步类型的对应函数</p>
<p>构造函数中B（子类）的虚函数表还没构造</p>
<p>因此调用的还是A（父类）的f</p>
<p>也可以理解成B还没构造完的时候，仍然是A对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;f();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's f()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A()&#123;f();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's f()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 无论是构造过程还是析构过程</span></span><br><span class="line">    <span class="comment">// 调用的都是A的f()</span></span><br><span class="line">    <span class="comment">// 因为到A的时候</span></span><br><span class="line">    <span class="comment">// 1. B还没有构造</span></span><br><span class="line">    <span class="comment">// 2. B已经析构</span></span><br><span class="line">    <span class="comment">// 因此调用的都是A的f</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final-amp-amp-override"><a href="#final-amp-amp-override" class="headerlink" title="final &amp;&amp; override"></a>final &amp;&amp; override</h3><p>见例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span>final</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有虚函数才能被定义为final</span></span><br><span class="line"><span class="comment">// 不允许再被覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>:</span>A&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A&amp; <span class="title">fc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">fc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 非虚函数不能用final修饰</span></span><br><span class="line">    <span class="comment">// void f5(int) final;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">int</span>)</span> final</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span>:</span>B&#123;</span><br><span class="line">    <span class="comment">// 正确</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误，virtual重载的返回类型也要一致</span></span><br><span class="line">    <span class="comment">// int f1(int) const override;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确，虽然要求返回值相同</span></span><br><span class="line">    <span class="comment">// 但是协变也是可以的</span></span><br><span class="line">    <span class="comment">// https://blog.csdn.net/gjggj/article/details/72626794</span></span><br><span class="line">    <span class="function">C&amp; <span class="title">fc</span><span class="params">()</span>override</span>;</span><br><span class="line">    <span class="comment">// 基本类型没有协变</span></span><br><span class="line">    <span class="comment">// int fc2()override;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误，因为没有重载任何函数</span></span><br><span class="line">    <span class="comment">// 因为不是const</span></span><br><span class="line">    <span class="comment">// void f1(int) override;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这是重写的f1，而不是重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误，没有重载任何函数</span></span><br><span class="line">    <span class="comment">// void f2(int) override;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误，f3不是virtual修饰，不能重载</span></span><br><span class="line">    <span class="comment">// 只能重写</span></span><br><span class="line">    <span class="comment">// void f3() override;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为f5是final，因此不能重载</span></span><br><span class="line">    <span class="comment">// void f5(int);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外注意，如果子类中没有virtual，那么调用的还是父类的版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"father's f1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"son's f1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B *b = <span class="keyword">new</span> D;</span><br><span class="line">    b -&gt; f1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数也可以有实现，但是不能是在类中实现，只能写在类外</p>
<p>有默认实现的纯虚函数仍然不能实例化，派生类仍然需要重写</p>
<p>可以显式调用纯虚函数的默认实现</p>
<p>抽象类不能被实例化，因此抽象类作为接口的时候，只能传递指针和引用，不会有对象切片的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 纯虚函数不能直接写inline实现</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; "default A func1" &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 普通函数或普通虚函数可以直接写inline实现</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"default A func2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯虚函数可以有实现，但是实现只能在类定义的外部，不能inline</span></span><br><span class="line"><span class="keyword">void</span> A::func1()&#123;</span><br><span class="line">    <span class="comment">// 纯虚函数即使有默认实现，派生类仍然需要重写该方法</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"default A func1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这样就可以调用纯虚函数的默认实现了</span></span><br><span class="line">        A::func1();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B func1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.func1();</span><br><span class="line">    b.func2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚函数的默认参数"><a href="#虚函数的默认参数" class="headerlink" title="虚函数的默认参数"></a>虚函数的默认参数</h3><p>默认参数静态绑定，如果是动态绑定，那么调用的时候还要再查找一次默认参数的值<br>这样就要查表两次（找虚函数一次，找默认参数）效率低，因此编译的时候直接用值来替换默认参数，即对象中只记录虚函数的入口地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a = <span class="number">0</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A's f() "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a = <span class="number">1</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B's f() "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"C's f() "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 默认参数静态绑定</span></span><br><span class="line">    <span class="comment">// 下面全都是打印0</span></span><br><span class="line">    A *p_a;</span><br><span class="line">    B b;</span><br><span class="line">    p_a = &amp;b;</span><br><span class="line">    p_a -&gt; f();</span><br><span class="line"></span><br><span class="line">    A *p_a1;</span><br><span class="line">    C c;</span><br><span class="line">    p_a1 = &amp;c;</span><br><span class="line">    p_a1 -&gt; f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p><strong>非虚直线继承(单继承)</strong></p>
<p>B继承A，C继承B，那么C可以使用A中的成员变量和方法，但是不允许直接调用A的构造函数，<strong>即只能负责直接基类的构造函数调用</strong></p>
<p>构造函数调用顺序为：</p>
<p>对C实例化，要先实例化B，要先实例化A</p>
<p>因此可以看到下面的输出为：</p>
<p>A’s int a 2<br>B’s int a 1<br>C’s int a 0326696997（无意义的值）<br>A’s f()（这个是在C的构造方法里面调用的A的f）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> a)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's f()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;&#125;</span><br><span class="line">    B(<span class="keyword">int</span> a):A(<span class="number">2</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C()&#123;&#125;</span><br><span class="line">    <span class="comment">// 可以这样使用间接非虚拟基类的可访问的成员变量和成员方法（但是不能直接调用构造方法）</span></span><br><span class="line">    C(<span class="keyword">int</span> a):B(<span class="number">1</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"C's int a "</span> &lt;&lt; a &lt;&lt; A::a &lt;&lt; <span class="built_in">endl</span>;A::f();&#125;</span><br><span class="line">    <span class="comment">// 不允许使用间接非虚拟基类的构造函数</span></span><br><span class="line">    <span class="comment">// C(int a):A(1)&#123;cout &lt;&lt; "C's int a" &lt;&lt; endl;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数层层调用</span></span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非虚菱形继承</strong></p>
<p>构造函数的调用顺序为派生列表中基类的出现顺序保持一致</p>
<p>如果有同名变量要加上基类类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> a):a(a)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;&#125;</span><br><span class="line">    B(<span class="keyword">int</span> a):A(<span class="number">2</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C()&#123;&#125;</span><br><span class="line">    C(<span class="keyword">int</span> a):A(<span class="number">1</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"C's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> C, <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D()&#123;&#125;</span><br><span class="line">    <span class="comment">// 可以通过::来访问不同父类中的同名变量</span></span><br><span class="line">    <span class="comment">// 该同名变量可能是父类自身的，也可能是父类继承而来的</span></span><br><span class="line">    D(<span class="keyword">int</span> a):B(<span class="number">1</span>),C(<span class="number">2</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"D's int a in B is "</span> &lt;&lt; B::a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数层层调用</span></span><br><span class="line">    <span class="comment">// 顺序为派生类的继承列表顺序</span></span><br><span class="line">    <span class="comment">// 且此时因为B和C是非虚继承</span></span><br><span class="line">    <span class="comment">// 因此A会初始化两次</span></span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// D中的a不明确，二义性</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; d.a &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// 正确的是要加上明确的父类</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d.B::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数和析构函数的调用顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> a):a(a)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's constructor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's deconstructor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;&#125;</span><br><span class="line">    B(<span class="keyword">int</span> a):A(<span class="number">2</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's constructor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's deconstructor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C()&#123;&#125;</span><br><span class="line">    C(<span class="keyword">int</span> a):A(<span class="number">1</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"C's constructor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~C()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"C's deconstructor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> C, <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D()&#123;&#125;</span><br><span class="line">    D(<span class="keyword">int</span> a):B(<span class="number">1</span>),C(<span class="number">2</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"D's constructor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~D()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"D's deconstructor"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数层层调用</span></span><br><span class="line">    <span class="comment">// 顺序为派生类的继承列表顺序</span></span><br><span class="line">    <span class="comment">// 且此时因为B和C是非虚继承</span></span><br><span class="line">    <span class="comment">// 因此A会初始化两次</span></span><br><span class="line">    <span class="comment">// 析构函数是相反的顺序</span></span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>虚基类</strong></p>
<p>如果直接基类有公共的基类，则该公共基类中的成员变量，在多继承的派生类中有多个副本，<strong>为了消除这种多副本的情况，使用虚基类</strong></p>
<p>下面这两种都行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> A;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span>B, C;</span><br></pre></td></tr></table></figure>

<p>显然，整体设计好了之后才会知道哪些需要虚继承</p>
<p>is a关系变为has a关系，没有拷贝，B和C中只是有指向同一个A对象的指针，在没有实例化D时，虚基类不会构造，<strong>虚基类的构造函数是由最新派生出的类（D）的构造函数来调用的（其他类对该基类的构造函数调用完全不起作用），且虚基类的构造函数优先非虚基类的构造函数执行</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> a):a(a)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;&#125;</span><br><span class="line">    <span class="comment">// 此时B不会调用A的构造函数</span></span><br><span class="line">    B(<span class="keyword">int</span> a):A(<span class="number">2</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's f()"</span> &lt;&lt; A::a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C()&#123;&#125;</span><br><span class="line">    <span class="comment">// 此时C不会调用A的构造函数</span></span><br><span class="line">    C(<span class="keyword">int</span> a):A(<span class="number">1</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"C's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"C's f()"</span> &lt;&lt; A::a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> C, <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D()&#123;&#125;</span><br><span class="line">    <span class="comment">// 如果使用了虚继承，那么初始化A的责任就交到了D身上</span></span><br><span class="line">    <span class="comment">// 如果D没有调用A的构造函数，那么A不会被初始化，此时B::a因为是继承自A的，那么将会是任意值</span></span><br><span class="line">    <span class="comment">// 如果D指明调用A的构造函数，那么无论A在初始化列表中的位置如何，永远优先调用A的构造函数</span></span><br><span class="line">    <span class="comment">// B和C对于A的初始化完全没有作用</span></span><br><span class="line">    D(<span class="keyword">int</span> a):B(<span class="number">1</span>),C(<span class="number">2</span>),A(<span class="number">100</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"D's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="comment">// 可以使用A::a来访问A的成员变量和方法</span></span><br><span class="line">    <span class="comment">// 如果存在vitual和非virtual，或者两个非virtual继承，那么都认为同名的变量或者方法是不明确的，不能使用A::a</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"D's f()"</span> &lt;&lt; A::a &lt;&lt; <span class="built_in">endl</span>; B::f(); C::f();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// B和C公用同一个A，持有指向同一个a对象的指针</span></span><br><span class="line">    d.f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A's <span class="keyword">int</span> a <span class="number">100</span></span><br><span class="line">C's <span class="keyword">int</span> a <span class="number">2</span></span><br><span class="line">B's <span class="keyword">int</span> a <span class="number">1</span></span><br><span class="line">D's <span class="keyword">int</span> a <span class="number">0</span></span><br><span class="line">D'<span class="function">s <span class="title">f</span><span class="params">()</span>100</span></span><br><span class="line">B's f()100</span><br><span class="line">C'<span class="function">s <span class="title">f</span><span class="params">()</span>100</span></span><br></pre></td></tr></table></figure>

<p><strong>虚继承和非虚继承同时存在</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    A(<span class="keyword">int</span> a):a(a)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"A's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B()&#123;&#125;</span><br><span class="line">    <span class="comment">// 此时B不会调用A的构造函数</span></span><br><span class="line">    B(<span class="keyword">int</span> a):A(<span class="number">2</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"B's f()"</span> &lt;&lt; A::a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C()&#123;&#125;</span><br><span class="line">    <span class="comment">// 此时C不会调用A的构造函数</span></span><br><span class="line">    C(<span class="keyword">int</span> a):A(<span class="number">1</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"C's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"C's f()"</span> &lt;&lt; A::a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    E()&#123;&#125;</span><br><span class="line">    E(<span class="keyword">int</span> a):A(<span class="number">1000</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"E's int a "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"E's f()"</span> &lt;&lt; A::a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> E,<span class="keyword">public</span> C, <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D()&#123;&#125;</span><br><span class="line">    <span class="comment">// 虚基类的构造函数优先非虚基类的构造函数执行</span></span><br><span class="line">    D(<span class="keyword">int</span> a):B(<span class="number">1</span>),C(<span class="number">2</span>),E(<span class="number">3</span>),A(<span class="number">100</span>)&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"D's int a "</span> &lt;&lt; a &lt;&lt; B::a &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"D's f()"</span> &lt;&lt; <span class="built_in">endl</span>; B::f(); C::f();E::f();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">D <span class="title">d</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// B和C公用同一个A，持用指向同一个a对象的指针，且和D中的相同</span></span><br><span class="line">    <span class="comment">// E有自己的A</span></span><br><span class="line">    d.f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A's <span class="keyword">int</span> a <span class="number">100</span></span><br><span class="line">A's <span class="keyword">int</span> a <span class="number">1000</span></span><br><span class="line">E's <span class="keyword">int</span> a <span class="number">3</span></span><br><span class="line">C's <span class="keyword">int</span> a <span class="number">2</span></span><br><span class="line">B's <span class="keyword">int</span> a <span class="number">1</span></span><br><span class="line">D's <span class="keyword">int</span> a <span class="number">0100</span></span><br><span class="line">D'<span class="function">s <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">B's f()100</span><br><span class="line">C'<span class="function">s <span class="title">f</span><span class="params">()</span>100</span></span><br><span class="line">E's f()1000</span><br></pre></td></tr></table></figure>

<h3 id="小结和补充"><a href="#小结和补充" class="headerlink" title="小结和补充"></a>小结和补充</h3><p>一个子类可以继承多个类，每一个继承都可以有自己的继承方式，成员变量的情况和单继承一样，只不过是多个</p>
<p>多继承的构造函数的调用顺序为派生列表中基类的出现顺序保持一致，且子类只能负责直接基类的构造函数调用（非虚继承的情况下）</p>
<p>子类可以继承构造函数，但是如果继承而来的构造函数是一样的，那么就会出错，此时子类必须要有自定义版本的该构造函数</p>
<p><img alt class="post-img b-lazy" data-img="https://s2.ax1x.com/2019/12/31/l1XQEt.png" data-index="3" data-src="https://s2.ax1x.com/2019/12/31/l1XQEt.png"></p>
<p><strong>类型转化的二义性错误</strong></p>
<p><img alt class="post-img b-lazy" data-img="https://s2.ax1x.com/2019/12/31/l1XT2D.png" data-index="4" data-src="https://s2.ax1x.com/2019/12/31/l1XT2D.png"></p>
<p><strong>同名的变量或者方法的二义性错误</strong></p>
<p><img alt class="post-img b-lazy" data-img="https://s2.ax1x.com/2019/12/31/l1jzwR.png" data-index="5" data-src="https://s2.ax1x.com/2019/12/31/l1jzwR.png"></p>
<p>除非指明调用的版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; d.B::a &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p><strong>内存布局</strong></p>
<p><img alt class="post-img b-lazy" data-img="https://s2.ax1x.com/2019/12/31/l3SY0H.png" data-index="6" data-src="https://s2.ax1x.com/2019/12/31/l3SY0H.png"></p>

                </article>
                <ul class="tags-postTags">
                    
                    <li>
                        <a href="/tags/c/" rel="tag"># c++</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </div>

    
    <nav id="gobottom" class="pagination">
        
        <a class="prev-post" title="flink源码阅读和解析笔记--任务执行" href="/2020/03/15/flink源码阅读和解析笔记-任务执行/">
            ← flink源码阅读和解析笔记--任务执行
        </a>
        
        <span class="prev-next-post">·</span>
        
        <a class="next-post" title="设计模式-结构型模式" href="/2019/12/24/设计模式-结构型模式/">
            设计模式-结构型模式 →
        </a>
        
    </nav>

    
    <script src="https://utteranc.es/client.js" repo="CaesarRoot/caesarroot.github.io" issue-term="pathname" label="blog" theme="github-light" crossorigin="anonymous" async>
    </script>
</div>

<div class="toc-bar">
    <div class="toc-btn-bar">
        <a href="#site-main" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M793.024 710.272a32 32 0 1 0 45.952-44.544l-310.304-320a32 32 0 0 0-46.4 0.48l-297.696 320a32 32 0 0 0 46.848 43.584l274.752-295.328 286.848 295.808z"/></svg>
        </a>
        <div class="toc-btn toc-switch">
            <svg class="toc-open" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M779.776 480h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M779.776 672h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M256 288a32 32 0 1 0 0 64 32 32 0 0 0 0-64M392.576 352h387.2a32 32 0 0 0 0-64h-387.2a32 32 0 0 0 0 64M256 480a32 32 0 1 0 0 64 32 32 0 0 0 0-64M256 672a32 32 0 1 0 0 64 32 32 0 0 0 0-64"/></svg>
            <svg class="toc-close hide" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 960c-247.039484 0-448-200.960516-448-448S264.960516 64 512 64 960 264.960516 960 512 759.039484 960 512 960zM512 128.287273c-211.584464 0-383.712727 172.128262-383.712727 383.712727 0 211.551781 172.128262 383.712727 383.712727 383.712727 211.551781 0 383.712727-172.159226 383.712727-383.712727C895.712727 300.415536 723.551781 128.287273 512 128.287273z"/><path d="M557.05545 513.376159l138.367639-136.864185c12.576374-12.416396 12.672705-32.671738 0.25631-45.248112s-32.704421-12.672705-45.248112-0.25631l-138.560301 137.024163-136.447897-136.864185c-12.512727-12.512727-32.735385-12.576374-45.248112-0.063647-12.512727 12.480043-12.54369 32.735385-0.063647 45.248112l136.255235 136.671523-137.376804 135.904314c-12.576374 12.447359-12.672705 32.671738-0.25631 45.248112 6.271845 6.335493 14.496116 9.504099 22.751351 9.504099 8.12794 0 16.25588-3.103239 22.496761-9.247789l137.567746-136.064292 138.687596 139.136568c6.240882 6.271845 14.432469 9.407768 22.65674 9.407768 8.191587 0 16.352211-3.135923 22.591372-9.34412 12.512727-12.480043 12.54369-32.704421 0.063647-45.248112L557.05545 513.376159z"/></svg>
        </div>
        <a href="#gobottom" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M231.424 346.208a32 32 0 0 0-46.848 43.584l297.696 320a32 32 0 0 0 46.4 0.48l310.304-320a32 32 0 1 0-45.952-44.544l-286.848 295.808-274.752-295.36z"/></svg>
        </a>
    </div>
    <div class="toc-main">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要有OO"><span class="toc-text">为什么要有OO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数"><span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重载构造函数"><span class="toc-text">重载构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员初始化表"><span class="toc-text">成员初始化表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#析构函数"><span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拷贝构造函数"><span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-和-delete"><span class="toc-text">new 和 delete</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要有new和delete？"><span class="toc-text">为什么要有new和delete？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-vs-malloc"><span class="toc-text">new vs malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用重载构造函数"><span class="toc-text">调用重载构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const成员函数"><span class="toc-text">const成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态成员"><span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#友元"><span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要有友元？"><span class="toc-text">为什么要有友元？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不完全声明"><span class="toc-text">不完全声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问权限"><span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承权限"><span class="toc-text">继承权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不完全声明-1"><span class="toc-text">不完全声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承成员"><span class="toc-text">继承成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数调用顺序"><span class="toc-text">构造函数调用顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承构造函数"><span class="toc-text">继承构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚函数"><span class="toc-text">虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值相容，类型相容"><span class="toc-text">赋值相容，类型相容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#前期绑定vs后期绑定"><span class="toc-text">前期绑定vs后期绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#限制"><span class="toc-text">限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚析构函数"><span class="toc-text">虚析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#到底调用哪个版本"><span class="toc-text">到底调用哪个版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数和析构函数中调用虚函数"><span class="toc-text">构造函数和析构函数中调用虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-amp-amp-override"><span class="toc-text">final &amp;&amp; override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纯虚函数"><span class="toc-text">纯虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚函数的默认参数"><span class="toc-text">虚函数的默认参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多继承"><span class="toc-text">多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#小结和补充"><span class="toc-text">小结和补充</span></a></li></ol></li></ol></li></ol>
    </div>
</div>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>




	</div>
	


<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
            

<article class="read-next-card" style="background-image: url(https://i.loli.net/2017/11/26/5a19c56faa29f.jpg)">
  <header class="read-next-card-header">
    <small class="read-next-card-header-sitetitle">&mdash; 羊男 &mdash;</small>
    <h3 class="read-next-card-header-title">Recent Posts</h3>
  </header>
  <div class="read-next-divider">
    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
      <path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/>
    </svg>
  </div>
  <div class="read-next-card-content">
    <ul>
      
      
      
      <li>
        <a href="/2020/08/25/从字节跳动到苏州微软-当我们在谈实习时我们在谈些什么/">从字节跳动到苏州微软-当我们在谈实习时我们在谈些什么</a>
      </li>
      
      
      
      <li>
        <a href="/2020/04/30/ffmpeg常用功能精简使用指南/">ffmpeg常用功能精简使用指南</a>
      </li>
      
      
      
      <li>
        <a href="/2020/03/15/flink源码阅读和解析笔记-任务执行/">flink源码阅读和解析笔记--任务执行</a>
      </li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </ul>
  </div>
  <footer class="read-next-card-footer">
    <a href="/archives">  MORE  → </a>
  </footer>
</article>

            
            
            

<article class="read-next-card" style="background-image: url(https://i.loli.net/2017/11/26/5a19c56faa29f.jpg)">
    <header class="read-next-card-header tagcloud-card">
        <h3 class="read-next-card-header-title">Categories</h3>
    </header>
    <div class="read-next-card-content">
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/并行计算/">并行计算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件设计/">软件设计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul>
    </div>
</article>


            
            
            

<article class="read-next-card" style="background-image: url(https://i.loli.net/2017/11/26/5a19c56faa29f.jpg)">
	<header class="read-next-card-header tagcloud-card">
		<h3 class="read-next-card-header-title">Tag Cloud</h3>
	</header>
	<div class="read-next-card-content-ext">
		<a href="/tags/Hello-World/" style="font-size: 14px;">Hello World</a> <a href="/tags/c/" style="font-size: 24px;">c++</a> <a href="/tags/flink/" style="font-size: 14px;">flink</a> <a href="/tags/linux/" style="font-size: 14px;">linux</a> <a href="/tags/stl/" style="font-size: 17.33px;">stl</a> <a href="/tags/tmux/" style="font-size: 14px;">tmux</a> <a href="/tags/容器/" style="font-size: 17.33px;">容器</a> <a href="/tags/软件设计/" style="font-size: 20.67px;">软件设计</a>
	</div>
</article>

            
        </div>
    </div>
</aside>

	




<div id="search" class="search-overlay">
    <div class="search-form">
        
        <div class="search-overlay-logo">
        	<img src="https://avatars0.githubusercontent.com/u/35787647?s=400&u=84a9297891a0fe94cdd18ce2f80d2c3d825c15fb&v=4" alt="羊男">
        </div>
        
        <input id="local-search-input" class="search-input" type="text" name="search" placeholder="Search ...">
        <a class="search-overlay-close" href="#"></a>
    </div>
    <div id="local-search-result"></div>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<footer class="site-footer outer">
	<div class="site-footer-content inner">
		<div class="copyright">
			<a href="/" title="羊男">羊男 &copy; 2020  </a>
			
				
    		
			<span id="busuanzi_container_site_pv">
			    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
			</span>
		</div>
		<nav class="site-footer-nav">
			
			<a href="https://hexo.io" title="Hexo" target="_blank" rel="noopener">Hexo</a>
			<a href="https://github.com/xzhih/hexo-theme-casper" title="Casper" target="_blank" rel="noopener">Casper</a>
		</nav>
	</div>
</footer>
	


<script>
    if(window.navigator && navigator.serviceWorker) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
            for(let registration of registrations) {
                registration.unregister()
            }
        })
    }
</script>


<script id="scriptLoad" src="/js/allinone.min.js" async></script>


<script>
    document.getElementById('scriptLoad').addEventListener('load', function () {
        
        
            var bLazy = new Blazy();
        

        
        

        
        
        
            searchFunc("/");
        
        
    })
</script>



<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>








</body>
</html>
